<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>as3522</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tangyilong.com/"/>
  <updated>2019-02-20T13:06:34.149Z</updated>
  <id>http://www.tangyilong.com/</id>
  
  <author>
    <name>as3522</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo不显示图片,不需要插件,超简单</title>
    <link href="http://www.tangyilong.com/2019/02/20/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87-%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8F%92%E4%BB%B6-%E8%B6%85%E7%AE%80%E5%8D%95/"/>
    <id>http://www.tangyilong.com/2019/02/20/Hexo插入图片-不需要插件-超简单/</id>
    <published>2019-02-20T13:02:42.000Z</published>
    <updated>2019-02-20T13:06:34.149Z</updated>
    
    <content type="html"><![CDATA[<p>当使用Hexo创建文件搭建博客的时候，就会遇到图片插图，以及插入的图片无法显示的问题，差不多网上大多数的解决方案就是第一种（但我本人没使用这个方案）</p><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>1.找到<code>Hexo</code>下的<code>_config.yml</code>里的<code>post_asset_folder</code>，把这个选项从<code>false</code>改成<code>true</code></p><p>2.在<code>Hexo</code>目录下打开Git Brsh，执行一个下载上传图片插件的命令<code>npm install hexo-asset-image --save</code>。</p><p>3.继续在Git Brsh下利用<code>hexo n &quot;xxxx&quot;</code>来生成md的文件（” “里的内容填自己的文件名），这时就会在同级的目录下生成一个同名的文件夹。</p><p>4.在<code>.md</code>的文件中要插入图片时，先要把所要插入的图片放在生成的同名文件夹下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">你想输入的替代文字</span>](<span class="link">xxxx/图片名.jpg</span>)</span><br></pre></td></tr></table></figure><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>上面的方案是一种解决方法，那么接下来我自己找到解决方案分享给大家，个人感觉更加简单方便。</p><p>在Hexo的目录source中创建一个图片文件夹，例如pic</p><p><img src="/pic/Hexo-pic001.png" alt="img1"></p><p>把你要插入的图片文件放到该目录下面，在你的文章中正常使用markdown的语法插入图片即可</p><p>例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">/pic/xxx.png</span>)</span><br></pre></td></tr></table></figure><p>到此你就完成了插图，并且图片在你的博客上面也会正常显示！</p><p>记住在pic前面有一个<code>/</code>,表示根目录的意思，因为对于hexo来说它的资源文件的根目录就是source,当然你也可以修改_config.yml改变这个配置</p><p><img src="/pic/Hexo-pic002.png" alt="img2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当使用Hexo创建文件搭建博客的时候，就会遇到图片插图，以及插入的图片无法显示的问题，差不多网上大多数的解决方案就是第一种（但我本人没使用这个方案）&lt;/p&gt;
&lt;h2 id=&quot;第一种&quot;&gt;&lt;a href=&quot;#第一种&quot; class=&quot;headerlink&quot; title=&quot;第一种&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim快速查找</title>
    <link href="http://www.tangyilong.com/2019/02/20/vim%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE/"/>
    <id>http://www.tangyilong.com/2019/02/20/vim快速查找/</id>
    <published>2019-02-20T11:40:46.000Z</published>
    <updated>2019-02-20T11:41:10.304Z</updated>
    
    <content type="html"><![CDATA[<p> vim有强大的字符串查找功能。</p><p>   我们通常在vim下要查找字符串的时候， 都是输入 / 或者 ？  加 需要查找的字符串来进行搜索，比如想搜索 super 这个单词， 可以输入  /super  或者  ？super，  两者的区别是前者是从上往下搜索，后者是从下往上搜索。<br>   那么如果我想搜索本行中某个单词，并且这个单词很长的时候， 手动输入该字符串是非常麻烦的， 当然可以使用模糊匹配(如* 或 ？)来做， 不过这样可能搜得到很多其他的，不完全匹配的字符串。<br>   可以使用如下方式来实现快速查找：</p><p>1， 最快的方式是让光标停留在想要查找的单词的任意一个字母上面， 然后输入<code>Shift + *</code>，即可快速选中该单词，并且可以通过<code>n</code>或<code>N</code>进行上一个或下一个的匹配。</p><p>2， 让光标停留在单词的第一个字母上， 然后输入yw拷贝该单词， 然后输入 / (Ctrl + R) 0 （即 /“0），回车， 就查找到了第一个匹配的单词， 并且可以通过<code>n</code>或<code>N</code>进行上一个或下一个的匹配。</p><p>解释一下：</p><p>Ctrl + r 是指使用寄存器 ， 你会发现先输入/ ， 然后输入 Ctrl + r , 会立刻变为 “ ， 即寄存器的前缀， 然后 “0 就可以理解了吧？ 合起来就是 /“0， 就是查找刚才复制的那个单词，</p><p>3， 还有一种方式， 和第二种方式差不多，不过是将单词拷贝到系统剪贴板， 然后再从系统剪贴板拿出来。 即选中需要查找的单词， 然后输入 “”+y， 然后输入/（Shfit + Ctrl + v）， 就查找到了第一个匹配的单词， 并且可以通过<code>n</code>或<code>N</code>进行上一个或下一个的匹配。</p><p>以上， 最方便的还是第一种， 高效快捷， 值得推荐！！</p><hr><p>原文：<a href="https://blog.csdn.net/ballack_linux/article/details/53187283" target="_blank" rel="noopener">https://blog.csdn.net/ballack_linux/article/details/53187283</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; vim有强大的字符串查找功能。&lt;/p&gt;
&lt;p&gt;   我们通常在vim下要查找字符串的时候， 都是输入 / 或者 ？  加 需要查找的字符串来进行搜索，比如想搜索 super 这个单词， 可以输入  /super  或者  ？super，  两者的区别是前者是从上往下搜索，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>container_of图文分析</title>
    <link href="http://www.tangyilong.com/2019/02/20/container-of%E5%9B%BE%E6%96%87%E5%88%86%E6%9E%90/"/>
    <id>http://www.tangyilong.com/2019/02/20/container-of图文分析/</id>
    <published>2019-02-20T11:39:45.000Z</published>
    <updated>2019-02-20T12:21:16.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="container-of-函数分析"><a href="#container-of-函数分析" class="headerlink" title="container of()函数分析"></a>container of()函数分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Container_of在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲<strong>就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。</strong></p><p>Container_of的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;    \</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);    \</span><br><span class="line">(type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure><p><img src="/pic/container_of.png" alt="img"></p><p> 其实，原理很简单：  已知结构体type的成员member的地址ptr，求解结构体type的起始地址。</p><p>​                  type的起始地址 = ptr - size      (这里需要都转换为char *，因为它为单位字节)。</p><p>具体来说分为两步：</p><p>   第一步，首先定义一个临时的数据类型（通过typeof( ((type *)0)-&gt;member )获得）与ptr相同的指针变量__mptr，然后用它来保存ptr的值。<br>   第二步，用(char *)__mptr减去member在结构体中的偏移量，得到的值就是整个结构体变量的首地址（整个宏的返回值就是这个首地址）。</p><p>==把mptr指针强转成(char *)是因为，char指针减法只移一个字节，如果这样才可能得出准确的地址，否则，改为int类型，在减1就移动4个就乱了。==</p><h2 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h2><p>其中的语法难点就是如何得出成员相对结构体的偏移量？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-2.6.38.8/include/linux/compiler-gcc4.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __compiler_offsetof(a,b) __builtin_offsetof(a,b)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* linux-2.6.38.8/include/linux/stddef.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> offsetof</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __compiler_offsetof</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> fl;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offsetof(struct test_struct, num) = %d\n"</span>, </span><br><span class="line">offsetof(struct test_struct, num));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offsetof(struct test_struct,  ch) = %d\n"</span>, </span><br><span class="line">offsetof(struct test_struct, ch));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offsetof(struct test_struct,  fl) = %d\n"</span>, </span><br><span class="line">offsetof(struct test_struct, fl));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明，__builtin_offsetof(a,b)是GCC的内置函数，可认为它的实现与((size_t) &amp;((TYPE *)0)-&gt;MEMBER)这段代码是一致的。</p><p>​    例子输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">offsetof(struct test_struct, num) = 0</span><br><span class="line">offsetof(struct test_struct,  ch) = 4</span><br><span class="line">offsetof(struct test_struct,  fl) = 8</span><br></pre></td></tr></table></figure><p>其中代码难以理解的地方就是它灵活地运用了0地址。如果觉得&amp;( (struct test_struct <em>)0 )-&gt;ch这样的代码不好理解，那么我们可以假设在0地址分配了一个结构体变量struct test_struct a，然后定义结构体指针变量p并指向a（struct test_struct </em>p = &amp;a），如此我们就可以通过&amp;p-&gt;ch获得成员ch的地址。由于a的首地址为0x0，所以成员ch的首地址为0x4</p><p><img src="/pic/container_of002.gif" alt="img2"></p><p>最后通过强制类型转换（size_t）把一个地址值转换为一个整数</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   container_of（ptr, type,member）函数的实现包括两部分：</p><p>​    1、判断ptr 与 member 是否为同意类型</p><p>​    2、计算size大小，结构体的起始地址 = (type <em>)((char </em>)ptr - size)   (注：强转为该结构体指针)</p><p>   现在我们知道container_of()的作用就是通过一个结构变量中一个成员的地址找到这个结构体变量的首地址。</p><p>   container_of(ptr,type,member),这里面有ptr,type,member分别代表指针、类型、成员。</p><hr><p><a href="https://blog.csdn.net/npy_lp/article/details/7010752" target="_blank" rel="noopener">https://blog.csdn.net/npy_lp/article/details/7010752</a></p><p><a href="https://blog.csdn.net/s2603898260/article/details/79371024" target="_blank" rel="noopener">https://blog.csdn.net/s2603898260/article/details/79371024</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;container-of-函数分析&quot;&gt;&lt;a href=&quot;#container-of-函数分析&quot; class=&quot;headerlink&quot; title=&quot;container of()函数分析&quot;&gt;&lt;/a&gt;container of()函数分析&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>同步内核缓冲区 sync,fsync和fdatasync函数</title>
    <link href="http://www.tangyilong.com/2019/02/20/%E5%90%8C%E6%AD%A5%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2%E5%8C%BA-sync-fsync%E5%92%8Cfdatasync%E5%87%BD%E6%95%B0/"/>
    <id>http://www.tangyilong.com/2019/02/20/同步内核缓冲区-sync-fsync和fdatasync函数/</id>
    <published>2019-02-20T11:37:58.000Z</published>
    <updated>2019-02-20T12:24:01.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步内核缓冲区"><a href="#同步内核缓冲区" class="headerlink" title="同步内核缓冲区"></a>同步内核缓冲区</h2><h3 id="1-缓冲区简单介绍"><a href="#1-缓冲区简单介绍" class="headerlink" title="1.缓冲区简单介绍"></a>1.缓冲区简单介绍</h3><p>   人生三大错觉之中的一个：在调用函数write()时，我们觉得该函数一旦返回，数据便已经写到了文件里.可是这样的概念仅仅是宏观上的.实际上。操作系统实现某些文件I/O时（如磁盘文件）。为了保证I/O的效率，在内核一般会用到一片专门的区域（内存或独立的I/O地址空间）作为I/O数据缓冲区.它用在输入输出设备和CPU之间，用来缓存数据，使得低速的设备和快速的CPU可以协调工作避免低速的输入输出设备长时间占用CPU。降低系统调用，提高了CPU的工作效率.</p><h3 id="2-不同步的write"><a href="#2-不同步的write" class="headerlink" title="2.不同步的write()"></a>2.不同步的write()</h3><p>  传统的UNIX或LINUX系统在设计时使用了内核缓冲区，设有快速缓冲区或页面快速缓冲区，大多数磁盘I/O都通过缓冲区进行.==当将数据写入文件时，内核通常先将该数据拷贝到当中一个缓冲区。假设该缓冲区尚未写满。则并不将其排入输出队列，而是等待其写满或者当内核须要重用该缓冲区以便存放其它磁盘块数据时，再将该缓冲区排入输出队列；然后待其到达队首时。才进行实际的I/O操作.这样的输出方式被称为延迟写.==<br>   当调用write()函数写出数据时，数据一旦写到该缓冲区（关键：仅仅是写到缓冲区），函数便马上返回.此时写出的数据能够用read()读回，也能够被其它进程读到，可是并不意味着它们已经被写到了外部永久存储介质上。即使调用close()关闭文件后也可能如此. 由于缓冲区的数据可能还在等待输出.<br>   因此。从数据被实际写到磁盘的角度来看。用write()写出的文件数据与外部存储设备并非全然同步的.不同步的时间间隔非常短，一般仅仅有几秒或十几秒，详细取决于写出的数据量和I/O数据缓冲区的状态.虽然不同步的时间间隔非常短，可是假设在此期间发生掉电或者系统崩溃，则会导致所写数据来不及写至磁盘而丢失的情况.<br>   ==注意：内核将缓冲区中的数据“写”到标准输入磁盘文件里，这里“写”不是将缓冲区中的数据移动到磁盘文件里，而是复制到磁盘文件里，也就说此时磁盘文件里还保留一份缓冲区内容的备份.==</p><p>  如图1所看到的.做出这一设计也是有其道理的。假设写出到磁盘文件上，磁盘坏了或满了等等，总之就是无法将数据送出，假如没备份。那数据不是丢掉了.也就是说内核会等待写入磁盘动作完毕后，才放心的将备份的数据删除掉.在下文讨论的三个函数中也将涉及到这个过程.</p><p> <img src="/pic/fysnc.png" alt="img"></p><p>​                     图1 数据传入过程示意图</p><p>   为了保证磁盘上实际文件系统与缓冲区快速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数.</p><h3 id="3-sync函数"><a href="#3-sync函数" class="headerlink" title="3.sync函数"></a>3.sync函数</h3><p>头文件：#include&lt;unistd.h&gt;<br>定义函数：void sync(void)；<br>返回值：若成功则返回0，若出错则返回-1。同一时候设置errno以指明错误.<br>函数说明：<br>   sync负责将系统缓冲区的数据“写入”磁盘。以确保数据的一致性和同步性.==注意：sync函数仅仅是将全部改动过的块缓冲区排入写队列，然后就返回。他并不等待实际I/O操作结束.所以不要觉得调用了sync函数，就觉得数据已安全的送到磁盘文件上，有可能会出现故障，可是sync函数是无法得知的.==<br>   系统守候进程一般每隔一段时间调用一次sync函数，确保定期刷新内核的块缓存.UNIX系统中，系统守候进程update会周期性地（一般每一个30秒）调用sync函数.命令sync(1)也调用sync函数.</p><h3 id="4-fsync函数"><a href="#4-fsync函数" class="headerlink" title="4.fsync函数"></a>4.fsync函数</h3><p>头文件：#include&lt;unistd.h&gt;<br>定义函数：int fsync(int filedes)；<br>返回值：若成功则返回0。若出错则返回-1。同一时候设置errno以指明错误.<br>函数说明：<br>   与sync函数不同，fsync函数仅仅对由文件描符filedes指定的单一文件起作用，强制与描写叙述字fildes相连文件的全部改动过的数据（包含核内I/O缓冲区中的数据）传送到外部永久介质。即刷新fildes给出的文件的全部信息。而且等待写磁盘操作结束，然后返回.调用<code>fsync()</code>的进程将堵塞直到设备报告传送已经完毕.这个fsync就安全点了.<br>   一个程序在写出数据之后。假设继续进行兴许处理之前要求确保所写数据已写到磁盘，则应当调用fsync().比如，==<strong>数据库应用一般会在调用write()保存关键交易数据的同一时候也调用<code>fsync()</code>.这样更能保证数据的安全可靠.</strong>==</p><h3 id="5-fdatasync函数"><a href="#5-fdatasync函数" class="headerlink" title="5.fdatasync函数"></a>5.fdatasync函数</h3><p>头文件：#include&lt;unistd.h&gt;<br>定义函数：int fdatasync(int filedes)；<br>返回值：若成功则返回0。若出错则返回-1，同一时候设置errno以指明错误.<br>函数说明：<br>   fdatasync函数类似于fsync函数，<strong>但它仅仅影响文件数据部分。强制传送用户已写出的数据至物理存储设备。不包含文件本身的特征数据.这样能够适当降低文件刷新时的数据传送量</strong>.而除数据外，fdatasync还会同步更新文件的属性.</p><h3 id="6-错误代码"><a href="#6-错误代码" class="headerlink" title="6.错误代码"></a>6.错误代码</h3><p>EBADF：文件描写叙述符无效。或文件已关闭.<br>EIO ： 读写的过程中错误发生 .<br>EROFS， EINVAL：文件所在的文件系统不支持同步.</p><h3 id="7-fflush-与fsync-的联系"><a href="#7-fflush-与fsync-的联系" class="headerlink" title="7.fflush()与fsync()的联系"></a>7.fflush()与fsync()的联系</h3><p>   内核I/O缓冲区是由操作系统管理的空间，而流缓冲区是由标准I/O库管理的用户空间.fflush()仅仅刷新位于用户空间中的流缓冲区.fflush()返回后。仅仅保证数据已不在流缓冲区中，并不保证它们一定被写到了磁盘.此时。从流缓冲区刷新的数据可能已被写至磁盘。也可能还待在内核I/O缓冲区中.要确保流I/O写出的数据已写至磁盘，那么在调用fflush()后还应当调用fsync().</p><h3 id="8-综述"><a href="#8-综述" class="headerlink" title="8.综述"></a>8.综述</h3><p>   尽管延迟写降低了磁盘读写次数，可是却降低了文件内容的更新速度，使得欲写到文件里数据在一段时间内并没有写到磁盘上。当系统发生问题时，这样的延迟可能造成文件更新内容的丢失。</p><hr><p><a href="https://www.cnblogs.com/bhlsheji/p/5222271.html" target="_blank" rel="noopener">https://www.cnblogs.com/bhlsheji/p/5222271.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步内核缓冲区&quot;&gt;&lt;a href=&quot;#同步内核缓冲区&quot; class=&quot;headerlink&quot; title=&quot;同步内核缓冲区&quot;&gt;&lt;/a&gt;同步内核缓冲区&lt;/h2&gt;&lt;h3 id=&quot;1-缓冲区简单介绍&quot;&gt;&lt;a href=&quot;#1-缓冲区简单介绍&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算术移位逻辑移位</title>
    <link href="http://www.tangyilong.com/2019/02/20/%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D/"/>
    <id>http://www.tangyilong.com/2019/02/20/算术移位逻辑移位/</id>
    <published>2019-02-20T11:31:46.000Z</published>
    <updated>2019-02-20T12:24:26.714Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     i = i&lt;&lt;<span class="number">3</span>;<span class="comment">//输出结果i = 64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问：上面的变量i是采用逻辑移位还是算术移位呢？</p><p>逻辑移位，简单理解就是物理上按位进行的左右移动，两头用0进行补充，不关心数值的符号问题。</p><p>算术移位，同样也是物理上按位进行的左右移动，两头用0进行补充，但必须确保符号位不改变。</p><ul><li><strong>逻辑移位</strong></li></ul><p>逻辑移位是指逻辑左移和逻辑右移，移出的空位都用0来补。</p><p>此组指令有：逻辑左移SHL(ShiftLogical Left)和逻辑右移SHR(ShiftLogical Right)。它们的指令格式如下：SHL/SHR Reg/Mem, CL/Imm，受影响的标志位：CF、OF、PF、SF和ZF(AF无定义)。逻辑左移/右移指令只有它们的移位方向不同，移位后空出的位都补<strong>0</strong></p><p>（1）逻辑左移SHL<br><img src="/pic/算术移位003.png" alt="img1"><br>（2）逻辑右移SHR<br><img src="/pic/算术移位004.png" alt="img1"></p><ul><li><strong>算术移位</strong></li></ul><p>算术移位 就需要分有符号型值和无符号型值<br>==对于无符号型值，算术移位等同于逻辑移位==<br>==而对于有符号型值 ，算术左移等同于逻辑左移，算术右移补的是符号位，正数补0，负数补1。==</p><p>算术移位指令有：算术左移SAL(ShiftAlgebraic Left)和算术右移SAR(ShiftAlgebraic Right)。它们的指令格式如下：SAL/SAR Reg/Mem, CL/Imm，受影响的标志位：CF、OF、PF、SF和ZF(AF无定义)。算术移位指令的功能描述如下：</p><p>（1）算术左移SAL把目的操作数的低位向高位移，空出的低位补0；<br><img src="/pic/算术移位001.png" alt="img1"><br>（2）算术右移SAR把目的操作数的高位向低位移，空出的高位用最高位(符号位)填补。<br><img src="/pic/算术移位002.png" alt="img1"></p><ul><li><strong>那么C编译器中采用的是那种移位方式呢？</strong></li></ul><p>在汇编指令中，shl和shr表示逻辑左移和逻辑右移，sal和sar表示算术左移和算术右移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">65</span>;  <span class="comment">//有符号整型 0100 0001</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">65</span>; <span class="comment">//无符号整型 0100 0001</span></span><br><span class="line">    a &lt;&lt;= <span class="number">1</span>; <span class="comment">//1000 0010  130</span></span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>; <span class="comment">//0010 0000  32</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">127</span>; <span class="comment">//0111 1111</span></span><br><span class="line">    c &lt;&lt;= <span class="number">3</span>; <span class="comment">//1111 1000 -8</span></span><br><span class="line">    <span class="keyword">char</span> d = <span class="number">127</span>; <span class="comment">//0111 1111</span></span><br><span class="line">    d &gt;&gt;= <span class="number">3</span>; <span class="comment">//0000 1111 15</span></span><br><span class="line">    <span class="keyword">char</span> e = <span class="number">-8</span>; <span class="comment">//内存以补码为1111 1000存储  源码为1000 1000 反码为1111 0111</span></span><br><span class="line">    e &gt;&gt;= <span class="number">3</span>; <span class="comment">//-1  补码1111 1111 源码 1000 0001 反码1111 1110</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);<span class="comment">//130 32</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,c,d);<span class="comment">//-8  15</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,e);  <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来看一看这一段代码的汇编代码 </p><p><img src="/pic/算术移位005.png" alt="img1"></p><p>只看汇编代码进行分析：</p><p>汇编代码的第四行和第七行以及第十一行是对a，b，c三个变量进行的移位操作，即有符号型变量左移和无符号型右移C编译器都处理为逻辑移位，用的指令是shl和shr，移出的空位用0来补。</p><p>而对于汇编代码的第十五行和第十九行是对d，e两个变量进行的移位操作，即正数和负数的有符号型变量的右移，C编译器处理为算术移位，用的指令是sar，移出的空位，正数补0，负数补1。</p><p>对于C编译器的逻辑移位和算术移位的总结<br>我所使用的C编译器是VS2008，基于该编译器采用对无符号型int，short，char进行移位时，编译器默认生成的汇编指令是逻辑左移和逻辑右移。<br>而对于有符号的int，short，char进行移位时，左移还是逻辑左移，但右移时生成的汇编指令是算术右移。</p><hr><p>参考：</p><p><a href="https://blog.csdn.net/xzg_2017/article/details/80158215" target="_blank" rel="noopener">https://blog.csdn.net/xzg_2017/article/details/80158215</a></p><p><a href="https://www.cnblogs.com/hpcpp/p/6291710.html" target="_blank" rel="noopener">https://www.cnblogs.com/hpcpp/p/6291710.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux memalign,valloc函数</title>
    <link href="http://www.tangyilong.com/2019/02/20/linux-memalign-valloc%E5%87%BD%E6%95%B0/"/>
    <id>http://www.tangyilong.com/2019/02/20/linux-memalign-valloc函数/</id>
    <published>2019-02-20T11:30:53.000Z</published>
    <updated>2019-02-20T11:31:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>  在GNU系统中，malloc或realloc返回的内存块地址都是8的倍数（如果是64位系统，则为16的倍数）。如果你需要更大的粒度，请使用memalign或valloc。这些函数在头文件“stdlib.h”中声明。</p><p>​    在GNU库中，可以使用函数free释放memalign和valloc返回的内存块。但无法在BSD系统中使用，而且BSD系统中并未提供释放这样的内存块的途径。</p><p>​    函数：void * memalign (size_t boundary, size_t size)<br>​    函数memalign将分配一个由size指定大小，地址是boundary的倍数的内存块。参数boundary必须是2的幂！函数memalign可以分配较大的内存块，并且可以为返回的地址指定粒度。</p><p>​    函数：void <em> valloc (size_t size)<br>​    使用函数valloc与使用函数memalign类似，函数valloc的内部实现里，使用页的大小作为对齐长度，使用memalign来分配内存。它的实现如下所示：<br>​    void </em><br>​    valloc (size_t size)<br>​    {<br>​      return memalign (getpagesize (), size);<br>​    }  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  在GNU系统中，malloc或realloc返回的内存块地址都是8的倍数（如果是64位系统，则为16的倍数）。如果你需要更大的粒度，请使用memalign或valloc。这些函数在头文件“stdlib.h”中声明。&lt;/p&gt;
&lt;p&gt;​    在GNU库中，可以使用函数fr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程属性-pthread_attr_init</title>
    <link href="http://www.tangyilong.com/2019/02/20/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7-pthread-attr-init/"/>
    <id>http://www.tangyilong.com/2019/02/20/线程属性-pthread-attr-init/</id>
    <published>2019-02-20T11:29:40.000Z</published>
    <updated>2019-02-20T11:30:13.598Z</updated>
    
    <content type="html"><![CDATA[<p>我们一般创建线程是这样</p><p>pthread_t tid;</p><p>pthread_create(&amp;tid, NULL, func, NULL);</p><p>第二个参数是线程属性设置，一般设置为了NULL，但是可以通过系统API进一步设置第二个参数，细化创建的线程的属性。</p><p>大致步骤为：</p><p>pthread_attr_t attr;</p><p>pthread_attr_init(&amp;attr);</p><p>pthread_attr_setXXX(&amp;attr, 目标值);</p><p>……//创建线程，其他代码</p><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p><strong>1．线程属性</strong></p><p>​       线程具有属性，用<em>pthread_attr_t</em>表示，在对该结构进行处理之前必须进行初始化，在使用后需要对其去除初始化。我们用<em>pthread_attr_init</em>函数对其初始化，用<em>pthread_attr_destroy</em>对其去除初始化。 </p><p><em>1</em>．</p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_init/pthread_attr_destroy</em></th></tr></thead><tbody><tr><td>功能：</td><td>对线程属性初始化<em>/</em>去除初始化</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_init(pthread_attr_t\</em>attr);<em><br></em>int pthread_attr_destroy(pthread_attr_t*attr);*</td></tr><tr><td>参数：</td><td><em>Attr</em>   线程属性变量</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p>调用<em>pthread_attr_init</em>之后，<em>pthread_t</em>结构所包含的内容就是操作系统实现支持的线程所有属性的默认值。</p><p>   如果要去除对<em>pthread_attr_t</em>结构的初始化，可以调用<em>pthread_attr_destroy</em>函数。如果<em>pthread_attr_init</em>实现时为属性对象分配了动态内存空间，<em>pthread_attr_destroy</em>还会用无效的值初始化属性对象，因此如果经<em>pthread_attr_destroy</em>去除初始化之后的<em>pthread_attr_t</em>结构被<em>pthread_create</em>函数调用，将会导致其返回错误。</p><p>线程属性结构如下：</p><p><em>typedef struct</em></p><p><em>{</em></p><p>​       <em>int                               detachstate;</em>   线程的分离状态</p><p>​       <em>int                               schedpolicy;</em>  线程调度策略</p><p>​       <em>structsched_param              schedparam;</em>  线程的调度参数</p><p>​       <em>int                               inheritsched;</em>  线程的继承性</p><p>​       <em>int                                scope;</em>       线程的作用域</p><p>​       <em>size_t                           guardsize;</em>   线程栈末尾的警戒缓冲区大小</p><p>​       <em>int                                stackaddr_set;</em></p><p>​       <em>void\</em>                          stackaddr;*   线程栈的位置</p><p>​       <em>size_t                           stacksize;</em>    线程栈的大小</p><p><em>}pthread_attr_t;</em></p><p>每个个属性都对应一些函数对其查看或修改。下面我们分别介绍。</p><h3 id="二、线程的分离状态"><a href="#二、线程的分离状态" class="headerlink" title="二、线程的分离状态"></a><strong>二、线程的分离状态</strong></h3><p>​    线程的分离状态决定一个线程以什么样的方式来终止自己。在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p><p>而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。所以如果我们在创建线程时就知道不需要了解线程的终止状态，则可以<em>pthread_attr_t</em>结构中的<em>detachstate</em>线程属性，让线程以分离状态启动。</p><p><em>2</em>．</p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_getdetachstate/pthread_attr_setdetachstate</em></th></tr></thead><tbody><tr><td>功能：</td><td>获取<em>/</em>修改线程的分离状态属性</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_getdetachstate(const pthread_attr_t \</em>attr,int *detachstate);<em><br></em>int pthread_attr_setdetachstate(pthread_attr_t *attr,intdetachstate);*</td></tr><tr><td>参数：</td><td><em>Attr</em>   线程属性变量<em>Detachstate</em>  线程的分离状态属性</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p>可以使用<em>pthread_attr_setdetachstate</em>函数把线程属性<em>detachstate</em>设置为下面的两个合法值之一：设置为<em>PTHREAD_CREATE_DETACHED,</em>以分离状态启动线程；或者设置为<em>PTHREAD_CREATE_JOINABLE,</em>正常启动线程。可以使用<em>pthread_attr_getdetachstate</em>函数获取当前的<em>datachstate</em>线程属性。</p><p>以分离状态创建线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(“child thread run!\n”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[ ])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      pthread_ttid;</span><br><span class="line">      pthread_attr_tattr;</span><br><span class="line">      pthread_attr_init(&amp;attr);</span><br><span class="line">      pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);<span class="comment">//分离</span></span><br><span class="line">      pthread_create(&amp;tid,&amp;attr,fn,arg);</span><br><span class="line">      pthread_attr_destroy(&amp;attr);</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、线程的继承性"><a href="#三、线程的继承性" class="headerlink" title="三、线程的继承性"></a><strong>三、线程的继承性</strong></h3><p>​    函数<em>pthread_attr_setinheritsched</em>和<em>pthread_attr_getinheritsched</em>分别用来设置和得到线程的继承性，这两个函数的定义如下： </p><p><em>3.</em></p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_getinheritsched**pthread_attr_setinheritsched</em></th></tr></thead><tbody><tr><td>功能：</td><td>获得<em>/</em>设置线程的继承性</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_getinheritsched(const pthread_attr_t\</em>attr,int *inheritsched);<em><br></em>int pthread_attr_setinheritsched(pthread_attr_t *attr,intinheritsched);*</td></tr><tr><td>参数：</td><td><em>attr</em>            线程属性变量<em>inheritsched</em>     线程的继承性</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p> 这两个函数具有两个参数，第<em>1</em>个是指向属性对象的指针，第<em>2</em>个是继承性或指向继承性的指针。继承性决定调度的参数是从创建的进程中继承还是使用在<em>schedpolicy</em>和<em>schedparam</em>属性中显式设置的调度信息。<em>Pthreads</em>不为<em>inheritsched</em>指定默认值，因此如果你关心线程的调度策略和参数，必须先设置该属性。</p><p>​    继承性的可能值是<em>PTHREAD_INHERIT_SCHED</em>（表示新现成将继承创建线程的调度策略和参数）和<em>PTHREAD_EXPLICIT_SCHED</em>（表示使用在<em>schedpolicy</em>和<em>schedparam</em>属性中显式设置的调度策略和参数）。</p><p>​    如果你需要显式的设置一个线程的调度策略或参数，那么你必须在设置之前将<em>inheritsched</em>属性设置为<em>PTHREAD_EXPLICIT_SCHED.</em></p><p>​    下面我来讲进程的调度策略和调度参数。我会结合下面的函数给出本函数的程序例子。</p><h3 id="四、线程的调度策略"><a href="#四、线程的调度策略" class="headerlink" title="四、线程的调度策略"></a><strong>四、线程的调度策略</strong></h3><p>   函数<em>pthread_attr_setschedpolicy</em>和<em>pthread_attr_getschedpolicy</em>分别用来设置和得到线程的调度策略。</p><p><em>4.</em></p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_getschedpolicy**pthread_attr_setschedpolicy</em></th></tr></thead><tbody><tr><td>功能：</td><td>获得<em>/</em>设置线程的调度策略</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_getschedpolicy(const pthread_attr_t\</em>attr,int *policy);<em><br></em>int pthread_attr_setschedpolicy(pthread_attr_t *attr,intpolicy);*</td></tr><tr><td>参数：</td><td><em>attr</em>           线程属性变量<em>policy</em>         调度策略</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p>这两个函数具有两个参数，第<em>1</em>个参数是指向属性对象的指针，第<em>2</em>个参数是调度策略或指向调度策略的指针。调度策略可能的值是先进先出（<em>SCHED_FIFO</em>）、轮转法（<em>SCHED_RR</em>）<em>,</em>或其它（<em>SCHED_OTHER</em>）。</p><p>​    <em>SCHED_FIFO</em>策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。在<em>SCHED_FIFO</em>调度策略下，当有一个线程准备好时，除非有平等或更高优先级的线程已经在运行，否则它会很快开始执行。</p><p>   <em>SCHED_RR(</em>轮循<em>)</em>策略是基本相同的，不同之处在于：如果有一个<em>SCHED_RR</em></p><p>策略的线程执行了超过一个固定的时期<em>(</em>时间片间隔<em>)</em>没有阻塞，而另外的<em>SCHED_RR</em>或<em>SCHBD_FIPO</em>策略的相同优先级的线程准备好时，运行的线程将被抢占以便准备好的线程可以执行。</p><p>​    当有<em>SCHED_FIFO</em>或<em>SCHED_RR</em>策赂的线程在一个条件变量上等持或等持加锁同一个互斥量时，它们将以优先级顺序被唤醒。即，如果一个低优先级的<em>SCHED_FIFO</em>线程和一个高优先织的<em>SCHED_FIFO</em>线程都在等待锁相同的互斥且，则当互斥量被解锁时，高优先级线程将总是被首先解除阻塞。 </p><h3 id="五、线程的调度参数（优先级）"><a href="#五、线程的调度参数（优先级）" class="headerlink" title="五、线程的调度参数（优先级）"></a><strong>五、线程的调度参数（优先级）</strong></h3><p>​    函数<em>pthread_attr_getschedparam</em> 和<em>pthread_attr_setschedparam</em>分别用来设置和得到线程的调度参数。 </p><p><em>5.</em></p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_getschedparam**pthread_attr_setschedparam</em></th></tr></thead><tbody><tr><td>功能：</td><td>获得<em>/</em>设置线程的调度参数</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_getschedparam(const pthread_attr_t\</em>attr,struct sched_param *param);<em><br></em>int pthread_attr_setschedparam(pthread_attr_t *attr,conststruct sched_param *param);*</td></tr><tr><td>参数：</td><td><em>attr</em>           线程属性变量<em>param          sched_param</em>结构</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p>这两个函数具有两个参数，第<em>1</em>个参数是指向属性对象的指针，第<em>2</em>个参数是<em>sched_param</em>结构或指向该结构的指针。结构<em>sched_param</em>在文件<em>/usr/include/bits/sched.h</em>中定义如下：​     </p><p><em>struct sched_param</em></p><p><em>{</em></p><p>​       <em>intsched_priority;</em></p><p><em>};</em></p><p>结构<em>sched_param</em>的子成员<em>sched_priority</em>控制一个优先权值，大的优先权值对应高的优先权。系统支持的最大和最小优先权值可以用<em>sched_get_priority_max</em>函数和<em>sched_get_priority_min</em>函数分别得到。</p><p>注意：如果不是编写实时程序，不建议修改线程的优先级。因为，调度策略是一件非常复杂的事情，如果不正确使用会导致程序错误，从而导致死锁等问题。如：在多线程应用程序中为线程设置不同的优先级别，有可能因为共享资源而导致优先级倒置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span><span class="title">params</span>;</span></span><br><span class="line"><span class="comment">/* first get the scheduling parameter, then set the new priority */</span></span><br><span class="line"><span class="comment">//设置线程的优先级</span></span><br><span class="line">rval = pthread_attr_getschedparam(attr, &amp;params);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rval = pthreadGetPriorityScope(&amp;minPriority, &amp;maxPriority);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (priority &lt; minPriority)</span><br><span class="line">&#123;</span><br><span class="line">priority = minPriority;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (priority &gt; maxPriority)</span><br><span class="line">&#123;</span><br><span class="line">priority = maxPriority;</span><br><span class="line">&#125;</span><br><span class="line">params.sched_priority = priority;</span><br><span class="line">rval = pthread_attr_setschedparam(attr, &amp;params);</span><br></pre></td></tr></table></figure><h3 id="六、线程的竞争范围"><a href="#六、线程的竞争范围" class="headerlink" title="六、线程的竞争范围"></a>六、线程的竞争范围</h3><p>int pthread_attr_getscope(const pthread_attr_t *restrict attr,</p><p>int *restrict contentionscope);</p><p>int pthread_attr_setscope(pthread_attr_t *attr, int contentionscope);</p><p>定义创建的线程的竞争范围为PTHREAD_SCOPE_SYSTEM、PTHREAD_SCOPE_PROCESS。</p><p>Linux Threads只实现了PTHREAD_SCOPE_SYSTEM，这意味着，它将和机器上运行的所有进程竞争CPU时间。</p><p>标准指定的另外一个值，PTHREAD_SCOPE_PROCESS，表示竞争只存在于运行中的进程的线程之间：即，线程的优先级是相对于其它进程中的线程的优先级的，而不必考虑进程的优先级如何。LinuxThread不支持PTHREAD_SCOPE_PROCESS。</p><p>若成功返回0，若失败返回-1。</p><h3 id="七、线程的栈的地址和大小"><a href="#七、线程的栈的地址和大小" class="headerlink" title="七、线程的栈的地址和大小"></a>七、线程的栈的地址和大小</h3><p>(1)</p><p>int pthread_attr_getstack(pthread_attr_t <em>attr,void **stackaddr,size_t</em>stacksize);</p><p>int pthread_attr_setstack(pthread_attr_t <em>attr, void </em>stackaddr,size_t stacksize);</p><p>设置线程栈的起始地址和栈大小。默认起始地址0，大小0x800000（8M，我的机子……）。</p><p>PS:使用get时往往显示的是addr = 0，size = 0，这可能是系统的BUG，size应给为8M而不是0。</p><p>(2)</p><p>上面的2个函数可以细化成4个：</p><p>int pthread_attr_setstackaddr(pthread_attr_t <em>attr, void </em>stackaddr);</p><p>int pthread_attr_getstackaddr(pthread_attr_t *attr, void**stackaddr);</p><p>int pthread_attr_setstacksize(pthread_attr_t *attr, size_tstacksize);</p><p>int pthread_attr_getstacksize(pthread_attr_t <em>attr, size_t</em>stacksize);</p><p>这里get得到的size为8M，所以pthread_attr_getstack获得的size大小是不能说明栈的大小的。</p><h3 id="八、栈溢出保护区大小"><a href="#八、栈溢出保护区大小" class="headerlink" title="八、栈溢出保护区大小"></a>八、栈溢出保护区大小</h3><p>intpthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);</p><p>intpthread_attr_getguardsize(pthread_attr_t <em>attr, size_t </em>guardsize);</p><p>设置线程的栈溢出保护区大小，默认4096B，即4K。</p><h3 id="九、设置-获取线程属性对象里CPU-姻亲属性"><a href="#九、设置-获取线程属性对象里CPU-姻亲属性" class="headerlink" title="九、设置/获取线程属性对象里CPU 姻亲属性"></a>九、设置/获取线程属性对象里CPU 姻亲属性</h3><p>int pthread_attr_setaffinity_np(pthread_attr_t *attr,size_tcpusetsize,</p><p>const cpu_set_t *cpuset);</p><p>int pthread_attr_getaffinity_np(pthread_attr_t *attr, size_tcpusetsize,</p><p>cpu_set_t *cpuset);</p><p>函数把 attr 引用的线程属性对象中的 CPU 姻亲掩码设置为cpuset 指定的值。这个属性决定了使用线程属性对象 attr 创建的线程的 CPU 姻亲掩码。</p><h3 id="十、获取实时优先级的最大最小值"><a href="#十、获取实时优先级的最大最小值" class="headerlink" title="十、获取实时优先级的最大最小值"></a>十、获取实时优先级的最大最小值</h3><h4 id="Synopsis"><a href="#Synopsis" class="headerlink" title="Synopsis"></a>Synopsis</h4><p><strong>#include &lt;sched.h&gt;</strong></p><p>int sched_get_priority_max(int <em>policy**</em>);<strong>int sched_get_priority_min(int <em>policy</em></strong>);** </p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>The <em>sched_get_priority_max</em>() and <em>sched_get_priority_min</em>() functions shall return the appropriate maximum or minimum, respectively, for the scheduling policy specified by<em>policy</em>.</p><p>The value of <em>policy</em> shall be one of the scheduling policy values defined in <em>&lt;sched.h&gt;</em>.</p><h4 id="Return-Value"><a href="#Return-Value" class="headerlink" title="Return Value"></a>Return Value</h4><p>If successful, the <em>sched_get_priority_max</em>() and <em>sched_get_priority_min</em>() functions shall return the appropriate maximum or minimum values, respectively. If unsuccessful, they shall return a value of -1 and set <em>errno</em> to indicate the error.</p><h4 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h4><p>The <em>sched_get_priority_max</em>() and <em>sched_get_priority_min</em>() functions shall fail if:</p><ul><li><p><strong>EINVAL</strong></p><p>The value of the <em>policy</em> parameter does not represent a defined scheduling policy.</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function: setPthreadAttr</span></span><br><span class="line"><span class="comment"> * Description: set the pthread's attribute: priority and the stack size in details</span></span><br><span class="line"><span class="comment"> * Input:priority - [minPriority, maxPriority] </span></span><br><span class="line"><span class="comment"> *stacksize - the pthread's stack size</span></span><br><span class="line"><span class="comment"> * Output:  attr - the pthread's attribute</span></span><br><span class="line"><span class="comment"> * Return:  0 if successful, otherwise return -1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setPthreadAttr</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> priority, <span class="keyword">size_t</span>* stacksize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span><span class="title">params</span>;</span></span><br><span class="line"><span class="keyword">int</span> maxPriority, minPriority;</span><br><span class="line"></span><br><span class="line">rval = pthread_attr_init(attr);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* normally, need not to set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 </span></span><br><span class="line">rval = pthread_attr_setinheritsched(attr, PTHREAD_EXPLICIT_SCHED);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rval = pthread_attr_setscope(attr, PTHREAD_SCOPE_SYSTEM);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rval == ENOTSUP)</span><br><span class="line">&#123;</span><br><span class="line">PRINT(<span class="string">"The system does not support the %s scope, using %s\n"</span>,</span><br><span class="line"><span class="string">"PTHREAD_SCOPE_SYSTEM"</span>, <span class="string">"PTHREAD_SCOPE_PROCESS"</span>);</span><br><span class="line"></span><br><span class="line">rval = pthread_attr_setscope(attr, PTHREAD_SCOPE_PROCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rval)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* use the round robin scheduling algorithm */</span></span><br><span class="line"><span class="comment">//设置线程调度模式，循环</span></span><br><span class="line">rval = pthread_attr_setschedpolicy(attr, SCHED_RR);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set the thread to be detached */</span></span><br><span class="line"><span class="comment">//设置为分离线程，让线程结束的话释放自己的资源</span></span><br><span class="line">rval = pthread_attr_setdetachstate(attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* first get the scheduling parameter, then set the new priority */</span></span><br><span class="line"><span class="comment">//设置线程的优先级</span></span><br><span class="line">rval = pthread_attr_getschedparam(attr, &amp;params);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rval = pthreadGetPriorityScope(&amp;minPriority, &amp;maxPriority);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (priority &lt; minPriority)</span><br><span class="line">&#123;</span><br><span class="line">priority = minPriority;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (priority &gt; maxPriority)</span><br><span class="line">&#123;</span><br><span class="line">priority = maxPriority;</span><br><span class="line">&#125;</span><br><span class="line">params.sched_priority = priority;</span><br><span class="line">rval = pthread_attr_setschedparam(attr, &amp;params);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* when set stack size, we define a minmum value to avoid fail */</span></span><br><span class="line"><span class="comment">//设置栈大小，最小8192</span></span><br><span class="line"><span class="keyword">if</span> (*stacksize &lt; PTHREAD_STACK_MIN)</span><br><span class="line">&#123;</span><br><span class="line">*stacksize = PTHREAD_STACK_MIN;</span><br><span class="line">&#125;</span><br><span class="line">rval = pthread_attr_setstacksize(attr, *stacksize);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function: pthreadSpawn</span></span><br><span class="line"><span class="comment"> * Description: create a pthread, this is a variadic function</span></span><br><span class="line"><span class="comment"> * Input:priority - [minPriority, maxPriority]</span></span><br><span class="line"><span class="comment"> *          stacksize - new thread's stack size(byte)</span></span><br><span class="line"><span class="comment"> *          funcptr - function addr to start the new thread</span></span><br><span class="line"><span class="comment"> *          args - total optional arguments pass to the above function</span></span><br><span class="line"><span class="comment"> *          ... - optional arguments</span></span><br><span class="line"><span class="comment"> * Output:  ptid - pthread id</span></span><br><span class="line"><span class="comment"> * Return:  0 if successful, otherwise an error number returned</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthreadSpawn</span><span class="params">(<span class="keyword">pthread_t</span> *ptid, <span class="keyword">int</span> priority, <span class="keyword">size_t</span> stacksize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *(*funcptr)(<span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*), </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> args, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (funcptr == <span class="literal">NULL</span> || args &gt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> i, rval;</span><br><span class="line"><span class="keyword">void</span> *arg[] = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">START_ROUTINE start;</span><br><span class="line"><span class="keyword">pthread_t</span> tid, *raw;</span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">va_list ap;</span><br><span class="line"><span class="keyword">size_t</span> actStackSize = stacksize;</span><br><span class="line"></span><br><span class="line">va_start(ap, args);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; args; i++)</span><br><span class="line">&#123;</span><br><span class="line">arg[i] = va_arg(ap, <span class="keyword">void</span> *);</span><br><span class="line">PRINTA(<span class="string">"pthreadSpawn: arg[%d] = %d\n"</span>, i, (<span class="keyword">int</span>)arg[i]);</span><br><span class="line">&#125;</span><br><span class="line">va_end(ap);</span><br><span class="line">rval = setPthreadAttr(&amp;attr, priority, &amp;actStackSize);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">PRINTA(<span class="string">"setPthreadAttr failed %d,sys errno %d\n"</span>,rval,errno);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptid != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">raw = ptid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">raw = &amp;tid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * If the total optional argumens is 0 or 1, we call the pthread_create directly. </span></span><br><span class="line"><span class="comment"> * Otherwise, we wrap a start routine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (args &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">rval = pthread_create(raw, &amp;attr, (START_ROUTINE)funcptr, arg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">FUNC_WRAPPER2 *func;</span><br><span class="line">func = (FUNC_WRAPPER2 *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FUNC_WRAPPER2));</span><br><span class="line"><span class="keyword">if</span> (func == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="keyword">void</span>) pthread_attr_destroy(&amp;attr);</span><br><span class="line"><span class="keyword">return</span> ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line">start = threadWrapper2;</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)func, <span class="number">0</span>, <span class="keyword">sizeof</span>(FUNC_WRAPPER2));</span><br><span class="line">func-&gt;entry = funcptr;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; args; i++)</span><br><span class="line">&#123;</span><br><span class="line">func-&gt;arg[i] = arg[i];</span><br><span class="line">&#125;</span><br><span class="line">rval = pthread_create(raw, &amp;attr, start, (<span class="keyword">void</span> *)func);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>((<span class="keyword">char</span> *)func);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br><span class="line">PRINTA(<span class="string">"pthread create: tid = %d, priority = %d, stacksize = %d\n"</span>, (<span class="keyword">int</span>)*raw, priority, actStackSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>原文2：<a href="https://blog.csdn.net/Gpengtao/article/details/7792860" target="_blank" rel="noopener">https://blog.csdn.net/Gpengtao/article/details/7792860</a> </p><p>原文1：<a href="https://blog.csdn.net/pbymw8iwm/article/details/6721038" target="_blank" rel="noopener">https://blog.csdn.net/pbymw8iwm/article/details/6721038</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们一般创建线程是这样&lt;/p&gt;
&lt;p&gt;pthread_t tid;&lt;/p&gt;
&lt;p&gt;pthread_create(&amp;amp;tid, NULL, func, NULL);&lt;/p&gt;
&lt;p&gt;第二个参数是线程属性设置，一般设置为了NULL，但是可以通过系统API进一步设置第二个参数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AF_INET和PE_INET区别</title>
    <link href="http://www.tangyilong.com/2019/02/20/AF-INET%E5%92%8CPE-INET%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.tangyilong.com/2019/02/20/AF-INET和PE-INET区别/</id>
    <published>2019-02-20T11:26:24.000Z</published>
    <updated>2019-02-20T11:26:43.959Z</updated>
    
    <content type="html"><![CDATA[<p>在写网络程序的时候，建立TCP socket：<br>   sock = socket(PF_INET, SOCK_STREAM, 0);<br>然后在绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_INET，即使用IP。</p><p>相关头文件中的定义：AF = Address Family<br>​                 PF = Protocol Family<br>​                 ==AF_INET = PF_INET==</p><p>在windows中的Winsock2.h中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET AF_INET</span></span><br></pre></td></tr></table></figure><p>所以在windows中AF_INET与PF_INET完全一样. </p><p>  而在Unix/Linux系统中，在不同的版本中这两者有微小差别.对于BSD,是AF,对于POSIX是PF.</p><p>  理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。当然AF_INET和PF_INET的值是相同的，混用也不会有太大的问题。也就是说你socket时候用PF_xxxx，设置的时候用AF_xxxx也是没关系的，这点随便找个TCPIP例子就可以验证出来了。如下，不论是AF_INET还是PF_INET都是可行的，只不过这样子的话，有点不符合规范。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在写网络程序的时候，建立TCP socket：&lt;br&gt;   sock = socket(PF_INET, SOCK_STREAM, 0);&lt;br&gt;然后在绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_I
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>va_list,va_start,va_arg,va_end使用说明</title>
    <link href="http://www.tangyilong.com/2019/02/20/va-list-va-start-va-arg-va-end%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://www.tangyilong.com/2019/02/20/va-list-va-start-va-arg-va-end使用说明/</id>
    <published>2019-02-20T11:22:23.000Z</published>
    <updated>2019-02-20T12:36:15.241Z</updated>
    
    <content type="html"><![CDATA[<p>在ANSI C中，这些宏的定义位于stdarg.h中，典型的实现如下：</p><p><strong>typedef char *va_list;</strong></p><p><strong>va_start宏</strong>，获取可变参数列表的第一个参数的地址（list是类型为va_list的指针，param1是可变参数最左边的参数）：</p><p>#define va_start(list,param1)   ( list = (va_list)&amp;param1+ sizeof(param1) )</p><p><strong>va_arg宏</strong>，获取可变参数的当前参数，返回指定类型并将指针指向下一参数（mode参数描述了当前参数的类型）：</p><p>#define va_arg(list,mode)   ( (mode *) ( list += sizeof(mode) ) )[-1]</p><p><strong>va_end宏</strong>，清空va_list可变参数列表：</p><p>#define va_end(list) ( list = (va_list)0 )</p><p>注：以上sizeof()只是为了说明工作原理，实际实现中，增加的字节数需保证为为int的整数倍</p><p>如：#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )</p><p>为了理解这些宏的作用，我们必须先搞清楚：C语言中函数参数的内存布局。首先，函数参数是存储在栈中的，函数参数从右往左依次入栈。</p><p>以下面函数为讨论对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> *para1，<span class="keyword">char</span> *param2，<span class="keyword">char</span> *param3, <span class="keyword">char</span> *param4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      va_list <span class="built_in">list</span>;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在linux中，栈由高地址往低地址生长,调用test函数时，其参数入栈情况如下：</p><p><img src="/pic/va_list1.jpg" alt="img"></p><p> 当调用va_start(list,param1) 时：list指针指向情况对应下图：</p><p><img src="/pic/va_list2.png" alt="img"></p><p>最复杂的宏是va_arg。它必须返回一个由va_list所指向的恰当的类型的数值，同时递增va_list，使它指向参数列表中的一个参数(即递增的大小等于与va_arg宏所返回的数值具有相同类型的对象的长度)。因为类型转换的结果不能作为赋值运算的目标，所以va_arg宏首先使用sizeof来确定需要递增的大小，然后把它直接加到va_list上，这样得到的指针再被转换为要求的类型。因为该指针现在指向的位置”过”了一个类型单位的大小，所以我们使用了下标-1来存取正确的返回参数。</p><p> 下面是实际用例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">var_test</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list <span class="built_in">list</span>;</span><br><span class="line">    va_start(<span class="built_in">list</span>,format);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         ch = va_arg(<span class="built_in">list</span>, <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">strcmp</span>(ch,<span class="string">""</span>) == <span class="number">0</span>)</span><br><span class="line">         &#123;    </span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%s "</span>,ch);</span><br><span class="line">     &#125;</span><br><span class="line">     va_end(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    var_test(<span class="string">"test"</span>,<span class="string">"this"</span>,<span class="string">"is"</span>,<span class="string">"a"</span>,<span class="string">"test"</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附：可变参数应用实例</p><p>1.printf实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">     </span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    n = <span class="built_in">vprintf</span>(format, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> n;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定制错误打印函数error</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: "</span>);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="http://www.cnblogs.com/bettercoder/p/3488299.html" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在ANSI C中，这些宏的定义位于stdarg.h中，典型的实现如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;typedef char *va_list;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;va_start宏&lt;/strong&gt;，获取可变参数列表的第一个参数的地址（li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>struct-iovec</title>
    <link href="http://www.tangyilong.com/2019/02/20/struct-iovec/"/>
    <id>http://www.tangyilong.com/2019/02/20/struct-iovec/</id>
    <published>2019-02-20T11:20:45.000Z</published>
    <updated>2019-02-20T11:21:17.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="struct-iovec-结构体定义与使用"><a href="#struct-iovec-结构体定义与使用" class="headerlink" title="struct iovec 结构体定义与使用"></a>struct iovec 结构体定义与使用</h1><p>1 .struct iovec定义了一个向量元素。通常，这个结构用作一个多元素的数组。对于每一个传输的元素，指针成员iov_base指向一个缓冲区，这个缓冲区是存放的是readv所接收的数据或是writev将要发送的数据。成员iov_len在各种情况下分别确定了接收的最大长度以及实际写入的长度。</p><p>2 .在这里，主要介绍readv和writev两个函数；readv(2)与writev(2)函数都使用一个I/O向量的概念；在头文件中定义了struct iovec 结构体，其定义和各成员如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line"> <span class="comment">/* Starting address (内存起始地址）*/</span></span><br><span class="line">   <span class="keyword">void</span>  *iov_base;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of bytes to transfer（这块内存长度） */</span></span><br><span class="line">   <span class="keyword">size_t</span> iov_len;    </span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure><p>linux中使用这样的结构体变量作为参数的函数很多，常见的有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">头文件：</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ssize_t</span> preadv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset);</span><br><span class="line"> <span class="keyword">ssize_t</span> pwritev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt,<span class="keyword">off_t</span> offset);     </span><br><span class="line"> <span class="keyword">ssize_t</span> preadv2(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> flags);</span><br><span class="line"> <span class="keyword">ssize_t</span> pwritev2(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure><p>readv和writev作为read与write函数的衍生函数，在一个原子操作中读取或是写入多个缓冲区。readv和writev函数中的各参数的含义如下：<br>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br></pre></td></tr></table></figure><p>这两个函数需要三个参数：<br>   要在其上进行读或是写的文件描述符fd<br>   读或写所用的I/O向量(vector)<br>   要使用的向量元素个数(count)<br>这些函数的返回值是readv所读取的字节数或是writev所写入的字节数。如果有错误发生，就会返回-1，而errno存有错误代码。注意，也其他I/O函数类似，可以返回错误码EINTR来表明他被一个信号所中断。</p><p>3 .示例代码1<br>代码的功能是：向终端（屏幕）打印字符串：i am happy.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> * File Name: struct_iovec.c</span></span><br><span class="line"><span class="comment"> * Author:    The answer</span></span><br><span class="line"><span class="comment"> * Function:  Other        </span></span><br><span class="line"><span class="comment"> * Mail:      2412799512@qq.com </span></span><br><span class="line"><span class="comment"> * Created Time: 2017年06月17日 星期六 20时36分21秒</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(ptr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="string">"i"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p2 = <span class="string">" am"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">" happy.\n"</span>;</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = p1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(p1);</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = p2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(p2);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">2</span>].iov_base = p3;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="built_in">strlen</span>(p3);</span><br><span class="line">    <span class="keyword">ssize_t</span> ret = writev(STDOUT_FILENO,iov,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"writev"</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>原文：<a href="https://blog.csdn.net/lixiaogang_theanswer/article/details/73385643" target="_blank" rel="noopener">https://blog.csdn.net/lixiaogang_theanswer/article/details/73385643</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;struct-iovec-结构体定义与使用&quot;&gt;&lt;a href=&quot;#struct-iovec-结构体定义与使用&quot; class=&quot;headerlink&quot; title=&quot;struct iovec 结构体定义与使用&quot;&gt;&lt;/a&gt;struct iovec 结构体定义与使用&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>source_insight的查找功能</title>
    <link href="http://www.tangyilong.com/2019/02/20/source-insight%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.tangyilong.com/2019/02/20/source-insight的查找功能/</id>
    <published>2019-02-20T11:19:01.000Z</published>
    <updated>2019-02-20T11:19:43.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="source-insight的查找功能"><a href="#source-insight的查找功能" class="headerlink" title="source insight的查找功能"></a>source insight的查找功能</h1><p>sourceinsight是一款很好的代码阅读编辑工具，方便对project管理，方便程序的阅读和编辑。查找功能使用十分频繁，选项较多，与其它软件的查找功能也类似，下面对英文版的查找功能，做简单说明：</p><p>查找参数：<br>whole wordsonly :                 全字匹配查找<br>casesensitive  ：                  区分大小写<br>projectwide  :                        项目内查找<br>includesubdirectories :          包含子目录查找<br>skip inactivecode :               跳过无效代码查找<br>skipcomments  :                  跳过注释查找<br>search onlycomments :       仅在注释在查找</p><h3 id="Loopup-References"><a href="#Loopup-References" class="headerlink" title="Loopup References"></a>Loopup References</h3><p>我们最常用的一种查找方式是选择<strong>Search/Lookup References</strong>或按Ctrl+/组合键再或者鼠标点 R按钮，在弹出的Loopup References窗口进行查找操作。 在SearchMethod中有四种可选的查找方式：<strong>Simple String、Regular Expression、 KeywordExpression和Look Up Reference</strong>。其中<strong>SimpleString是最普通的查找方式，可以查找文件中出现的任意字符或字符，甚至可以查找 _upap || u这样的字符串</strong>，但是在工程较大时，查找过程会较慢。<strong>RegularExpression查找方式，正则表达式用来做搜索</strong>。 Keyword Expression和Look UpReference查找的结果基本相同，但是显示方式略有差异。这两种方式都是使用SI预先建立的数据库，查找起来速度相当快。但通常这种速度只对在查找标识符时有明显效果。对于像函数名，变量名等的查找，强烈建议使用这两种方式进行查找。</p><h3 id="SearchFiles"><a href="#SearchFiles" class="headerlink" title="SearchFiles"></a>SearchFiles</h3><p>选择Search/Search Files或按Ctrl+Shift+F组合键，在弹出的Search Files窗口进行查找操作。在File Name框中可以填入文件名或文件夹。注意当要查询的文件夹双包含子文件夹时，可以勾选Options中的IncludeSubdirectiories，实现对各层文件的递归搜索。</p><h3 id="SearchProject"><a href="#SearchProject" class="headerlink" title="SearchProject"></a>SearchProject</h3><p>选择Search/Search Project，在弹出的Search Project窗口进行查找操作。操作与LoopupReferences几乎完全一致，它们各自保存上次搜索的配置。</p><h3 id="几个较常用的快捷键"><a href="#几个较常用的快捷键" class="headerlink" title="几个较常用的快捷键"></a>几个较常用的快捷键</h3><p>默认情况下，SI已经定义了很多非常实用的快捷键：<br>F5<br>指定行号，实现行跳转，在遇到编译错误的时候，能特别方便的找到出错行。<br>Shift+F8<br>高亮显示指定标识，快速浏览标识的使用情况。<br>Ctrl+鼠标点击标识<br>直接跳转至标识定义处。<br>Ctrl+F<br>本文件内查找。<br>F3<br>本文件查找结果的上一个。<br>F4<br>本文件查找结果的下一个。<br>F7<br>打开Browse Project Symbols窗口，快速浏览工程内标识定义。<br>Ctrl+M<br>创建或查找书签，方便下次找回此位置。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;source-insight的查找功能&quot;&gt;&lt;a href=&quot;#source-insight的查找功能&quot; class=&quot;headerlink&quot; title=&quot;source insight的查找功能&quot;&gt;&lt;/a&gt;source insight的查找功能&lt;/h1&gt;&lt;p&gt;so
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大小端和结构体位域</title>
    <link href="http://www.tangyilong.com/2019/01/30/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%8D%E5%9F%9F/"/>
    <id>http://www.tangyilong.com/2019/01/30/大小端和结构体位域/</id>
    <published>2019-01-30T09:07:32.000Z</published>
    <updated>2019-01-30T09:08:02.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大小端和结构体位域"><a href="#大小端和结构体位域" class="headerlink" title="大小端和结构体位域"></a>大小端和结构体位域</h1><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><h3 id="什么是大小端"><a href="#什么是大小端" class="headerlink" title="什么是大小端"></a>什么是大小端</h3><p>Big-Endian和Little-Endian的定义如下：<br>1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：<br><strong>1)大端模式：</strong><br>低地址 —————–&gt; 高地址<br>0x12  |  0x34  |  0x56  |  0x78<br><strong>2)小端模式：</strong><br>低地址 ——————&gt; 高地址<br>0x78  |  0x56  |  0x34  |  0x12<br><strong>可见，大端模式和字符串的存储模式类似。</strong><br><strong>3)下面是两个具体例子：</strong><br>16bit宽的数0x1234在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p><table><thead><tr><th>内存地址</th><th>小端模式存放内容</th><th>大端模式存放内容</th></tr></thead><tbody><tr><td><strong>0x4000</strong></td><td><strong>0x34</strong></td><td><strong>0x12</strong></td></tr><tr><td><strong>0x4001</strong></td><td><strong>0x12</strong></td><td><strong>0x34</strong></td></tr></tbody></table><p><strong>32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</strong></p><table><thead><tr><th><strong>内存地址</strong></th><th><strong>小端模式存放内容</strong></th><th><strong>大端模式存放内容</strong></th></tr></thead><tbody><tr><td><strong>0x4000</strong></td><td><strong>0x78</strong></td><td><strong>0x12</strong></td></tr><tr><td><strong>0x4001</strong></td><td><strong>0x56</strong></td><td><strong>0x34</strong></td></tr><tr><td><strong>0x4002</strong></td><td><strong>0x34</strong></td><td><strong>0x56</strong></td></tr><tr><td><strong>0x4003</strong></td><td><strong>0x12</strong></td><td><strong>0x78</strong></td></tr></tbody></table><p> <strong>4)大端小端没有谁优谁劣，各自优势便是对方劣势：</strong><br>大端：容易判断正负（offset(0)）；<br><strong>ps:通常情况下，ARM是大端模式；X86是小端模式；</strong><br><strong>小端：易于进行数据类型转换，1、2、4字节的存储方式一样。</strong></p><h3 id="判断大小端"><a href="#判断大小端" class="headerlink" title="判断大小端"></a>判断大小端</h3><p> <strong>可以使用程序判断CPU模式是大端还是小端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0x1234</span>;</span><br><span class="line"><span class="keyword">char</span> b=*(<span class="keyword">char</span>*)&amp;a;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0x12</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"big end\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"little end\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。<strong>位段成员必须声明为int、unsigned int或signed int类型（short char long）。</strong></p><p>一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名     </span></span><br><span class="line"><span class="class">&#123;</span> 位域列表 &#125;;</span><br></pre></td></tr></table></figure><p>其中位域列表的形式为： 类型说明符 位域名：位域长度<br>例如：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">int</span> a:<span class="number">8</span>;     </span><br><span class="line"><span class="keyword">int</span> b:<span class="number">2</span>;     </span><br><span class="line"><span class="keyword">int</span> c:<span class="number">6</span>;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。</p><ol><li>如果一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：     </li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">unsigned</span> a:<span class="number">4</span>     </span><br><span class="line"><span class="keyword">unsigned</span> :<span class="number">0</span> <span class="comment">/*空域*/</span>     </span><br><span class="line"><span class="keyword">unsigned</span> b:<span class="number">4</span> <span class="comment">/*从下一单元开始存放*/</span>     </span><br><span class="line"><span class="keyword">unsigned</span> c:<span class="number">4</span>     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。     </p><p>2.位域的长度不能大于数据类型本身的长度，比如int类型就能超过32位二进位。</p><p><em>3.</em> 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">int</span> a:<span class="number">1</span>     </span><br><span class="line"><span class="keyword">int</span> :<span class="number">2</span> <span class="comment">/*该2位不能使用*/</span>     </span><br><span class="line"><span class="keyword">int</span> b:<span class="number">3</span>     </span><br><span class="line"><span class="keyword">int</span> c:<span class="number">2</span>     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。</p><p>二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名.位域名 位域允许用各种格式输出。     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line">    <span class="keyword">unsigned</span> a:<span class="number">1</span>;     </span><br><span class="line">    <span class="keyword">unsigned</span> b:<span class="number">3</span>;     </span><br><span class="line">    <span class="keyword">unsigned</span> c:<span class="number">4</span>;     </span><br><span class="line">&#125; bit,*pbit;     </span><br><span class="line">bit.a=<span class="number">1</span>;     </span><br><span class="line">bit.b=<span class="number">7</span>; <span class="comment">//注意：位域的赋值不能超过该域所能表示的最大值，如b只有3位，能表示的最大数为7，若赋为8，就会出错   </span></span><br><span class="line">bit.c=<span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，<br>允许其它类型类型的存在。<br>使用位域的主要目的是压缩存储，其大致规则为：</p><p>1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止<br>2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；<br>3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++，GCC采取压缩方式；<br>4) 如果位域字段之间穿插着非位域字段，则不进行压缩；<br>5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大小端和结构体位域&quot;&gt;&lt;a href=&quot;#大小端和结构体位域&quot; class=&quot;headerlink&quot; title=&quot;大小端和结构体位域&quot;&gt;&lt;/a&gt;大小端和结构体位域&lt;/h1&gt;&lt;h2 id=&quot;大小端&quot;&gt;&lt;a href=&quot;#大小端&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>svn基本操作</title>
    <link href="http://www.tangyilong.com/2019/01/30/svn%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.tangyilong.com/2019/01/30/svn基本操作/</id>
    <published>2019-01-30T09:05:54.000Z</published>
    <updated>2019-01-30T09:06:35.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="svn常用操作命令"><a href="#svn常用操作命令" class="headerlink" title="svn常用操作命令"></a>svn常用操作命令</h1><p><a href="https://www.cnblogs.com/liwanggui/archive/2016/06/28/5624147.html" target="_blank" rel="noopener">原文地址</a></p><h2 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span><br><span class="line">svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">svn co svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">svn co http://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br><span class="line">svn checkout svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">svn checkouthttp://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br></pre></td></tr></table></figure><blockquote><p>注：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。<br>　　 其中 username 与 password前是两个短线，不是一个。<br>　　 不指定本地目录全路径，则检出到当前目录下。</p></blockquote><h2 id="导出-导出一个干净的不带-svn文件夹的目录树"><a href="#导出-导出一个干净的不带-svn文件夹的目录树" class="headerlink" title="导出(导出一个干净的不带.svn文件夹的目录树)"></a>导出(导出一个干净的不带.svn文件夹的目录树)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">svn  export  [-r 版本号]  http://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  [-r 版本号]  svn://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">svn export svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">svn export svn://localhost/test/testapp --username wzhnsc</span><br><span class="line">svn export /home/testapp /home/testtools</span><br></pre></td></tr></table></figure><blockquote><p>注：第一种从版本库导出干净工作目录树的形式是指定URL，<br>如果指定了修订版本号，会导出相应的版本，<br>如果没有指定修订版本，则会导出最新的，导出到指定位置。<br>如果省略 本地目录全路径，URL的最后一部分会作为本地目录的名字。<br>第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留，<br>但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。</p></blockquote><h2 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">svn　add　文件名</span><br><span class="line">注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！</span><br><span class="line">例子：</span><br><span class="line">svn add test.php ＜－ 添加test.php </span><br><span class="line">svn commit -m <span class="string">"添加我的测试用test.php"</span> test.php</span><br><span class="line">svn add *.php ＜－ 添加当前目录下所有的php文件</span><br><span class="line">svn commit -m <span class="string">"添加我的测试用全部php文件"</span> *.php</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">svn　commit　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line">svn　ci　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line">必须带上-m参数，参数可以为空，但是必须写上-m</span><br><span class="line">例子：</span><br><span class="line">svn commit -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> * ＜－ 注意这个*表示全部文件</span><br><span class="line">svn commit -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">svn commit -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php ＜－ 保持锁就用–no-unlock开关</span><br><span class="line">svn ci -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> * ＜－ 注意这个*表示全部文件</span><br><span class="line">svn ci -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">svn ci -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php ＜－ 保持锁就用–no-unlock开关</span><br></pre></td></tr></table></figure><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">svn　update</span><br><span class="line">svn　update　-r　修正版本　文件名</span><br><span class="line">svn　update　文件名</span><br><span class="line">例子：</span><br><span class="line">svn update ＜－ 后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span><br><span class="line">svn update -r 200 test.cpp ＜－ 将版本库中的文件 test.cpp 还原到修正版本（revision）200</span><br><span class="line">svn update test.php ＜－ 更新与版本库同步。</span><br><span class="line">　　　　　　　　　　　 提交的时候提示过期冲突，需要先 update 修改文件，</span><br><span class="line">　　　　　　　　　　　 然后清除svn resolved，最后再提交commit。</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">svn　delete　svn://路径(目录或文件的全路径) -m <span class="string">"删除备注信息文本"</span></span><br><span class="line">推荐如下操作：</span><br><span class="line">svn　delete　文件名 </span><br><span class="line">svn　ci　-m　<span class="string">"删除备注信息文本"</span></span><br><span class="line">例子：</span><br><span class="line">svn delete svn://localhost/testapp/test.php -m <span class="string">"删除测试文件test.php"</span></span><br><span class="line">推荐如下操作：</span><br><span class="line">svn delete test.php </span><br><span class="line">svn ci -m <span class="string">"删除测试文件test.php"</span></span><br></pre></td></tr></table></figure><h2 id="加锁-解锁"><a href="#加锁-解锁" class="headerlink" title="加锁/解锁"></a>加锁/解锁</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　lock　-m　<span class="string">"加锁备注信息文本"</span>　[--force]　文件名 </span><br><span class="line">svn　unlock　文件名</span><br><span class="line">例子：</span><br><span class="line">svn lock -m <span class="string">"锁信测试用test.php文件"</span> test.php </span><br><span class="line">svn unlock test.php</span><br></pre></td></tr></table></figure><h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　diff　文件名 </span><br><span class="line">svn　diff　-r　修正版本号m:修正版本号n　文件名</span><br><span class="line">例子：</span><br><span class="line">svn diff test.php＜－ 将修改的文件与基础版本比较</span><br><span class="line">svn diff -r 200:201 test.php＜－ 对 修正版本号200 和 修正版本号201 比较差异</span><br></pre></td></tr></table></figure><h2 id="查看文件或者目录状态"><a href="#查看文件或者目录状态" class="headerlink" title="查看文件或者目录状态"></a>查看文件或者目录状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">svn st 目录路径/名</span><br><span class="line">svn status 目录路径/名＜－ 目录下的文件和子目录的状态，正常状态不显示 </span><br><span class="line">　　　　　　　　　　　　　【?：不在svn的控制中；  M：内容被修改；C：发生冲突；</span><br><span class="line">　　　　　　　　　　　　　　A：预定加入到版本库；K：被锁定】 </span><br><span class="line">svn  -v 目录路径/名</span><br><span class="line">svn status -v 目录路径/名＜－ 显示文件和子目录状态</span><br><span class="line">　　　　　　　　　　　　　　【第一列保持相同，第二列显示工作版本号，</span><br><span class="line">　　　　　　　　　　　　　　 第三和第四列显示最后一次修改的版本号和修改人】</span><br></pre></td></tr></table></figure><blockquote><p>注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，<br>　　原因是svn在本地的.svn中保留了本地版本的原始拷贝。</p></blockquote><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn　<span class="built_in">log</span>　文件名</span><br><span class="line">例子：</span><br><span class="line">svn <span class="built_in">log</span> test.php＜－ 显示这个文件的所有修改记录，及其版本号的变化</span><br></pre></td></tr></table></figure><h2 id="查看文件详细信息"><a href="#查看文件详细信息" class="headerlink" title="查看文件详细信息"></a>查看文件详细信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn　info　文件名</span><br><span class="line">例子：</span><br><span class="line">svn info test.php</span><br></pre></td></tr></table></figure><h2 id="SVN-帮助"><a href="#SVN-帮助" class="headerlink" title="SVN 帮助"></a>SVN 帮助</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　help ＜－ 全部功能选项</span><br><span class="line">svn　help　ci ＜－ 具体功能的说明</span><br></pre></td></tr></table></figure><h2 id="查看版本库下的文件和目录列表"><a href="#查看版本库下的文件和目录列表" class="headerlink" title="查看版本库下的文件和目录列表"></a>查看版本库下的文件和目录列表</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　list　svn://路径(目录或文件的全路径)</span><br><span class="line">svn　ls　svn://路径(目录或文件的全路径)</span><br><span class="line">例子：</span><br><span class="line">svn list svn://localhost/<span class="built_in">test</span></span><br><span class="line">svn ls svn://localhost/<span class="built_in">test</span> ＜－ 显示svn://localhost/<span class="built_in">test</span>目录下的所有属于版本库的文件和目录</span><br></pre></td></tr></table></figure><h2 id="创建纳入版本控制下的新目录"><a href="#创建纳入版本控制下的新目录" class="headerlink" title="创建纳入版本控制下的新目录"></a>创建纳入版本控制下的新目录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　mkdir　目录名</span><br><span class="line">svn　mkdir　-m　<span class="string">"新增目录备注文本"</span>　http://目录全路径</span><br><span class="line">例子：</span><br><span class="line">svn mkdir newdir</span><br><span class="line">svn mkdir -m <span class="string">"Making a new dir."</span> svn://localhost/<span class="built_in">test</span>/newdir</span><br></pre></td></tr></table></figure><blockquote><p>注：添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败”</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">svn update</span></span><br></pre></td></tr></table></figure><blockquote><p>注：如果手工在checkout出来的目录里创建了一个新文件夹newsubdir，<br>　　再用svn mkdir newsubdir命令后，SVN会提示：<br>　　svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？<br>　　svn: 无法创建目录“hello”: 文件已经存在<br>　　此时，用如下命令解决：<br>　　svn add –non-recursive newsubdir<br>　　在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录<br>　　再用 svn mkdir -m “添hello功能模块文件” <a href="svn://localhost/test/newdir/newsubdir" target="_blank" rel="noopener">svn://localhost/test/newdir/newsubdir</a> 命令，<br>　　SVN提示：<br>　　svn: File already exists: filesystem ‘/data/svnroot/test/db’, transaction ‘4541-1’,<br>　　path ‘/newdir/newsubdir ‘</p></blockquote><h2 id="恢复本地修改"><a href="#恢复本地修改" class="headerlink" title="恢复本地修改"></a>恢复本地修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　revert　[--recursive]　文件名</span><br><span class="line">注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span><br><span class="line">例子：</span><br><span class="line">svn revert foo.c ＜－ 丢弃对一个文件的修改</span><br><span class="line">svn revert --recursive . ＜－恢复一整个目录的文件，. 为当前目录</span><br></pre></td></tr></table></figure><h2 id="把工作拷贝更新到别的URL"><a href="#把工作拷贝更新到别的URL" class="headerlink" title="把工作拷贝更新到别的URL"></a>把工作拷贝更新到别的URL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn　switch　http://目录全路径　本地目录全路径</span><br><span class="line">例子：</span><br><span class="line">svn switch http://localhost/<span class="built_in">test</span>/456 . ＜－ (原为123的分支)当前所在目录分支到localhost/<span class="built_in">test</span>/456</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">svn　resolved　[本地目录全路径]</span><br><span class="line">例子：</span><br><span class="line">$ svn update</span><br><span class="line">C foo.c</span><br><span class="line">Updated to revision 31.</span><br><span class="line">如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span><br><span class="line">$ ls</span><br><span class="line">foo.c</span><br><span class="line">foo.c.mine</span><br><span class="line">foo.c.r30</span><br><span class="line">foo.c.r31</span><br><span class="line">当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span><br><span class="line">你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</span><br></pre></td></tr></table></figure><h2 id="不checkout而查看输出特定文件或URL的内容"><a href="#不checkout而查看输出特定文件或URL的内容" class="headerlink" title="不checkout而查看输出特定文件或URL的内容"></a>不checkout而查看输出特定文件或URL的内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">svn　cat　http://文件全路径</span><br><span class="line">例子：</span><br><span class="line">svn cat http://localhost/<span class="built_in">test</span>/readme.txt</span><br><span class="line">新建一个分支copy</span><br><span class="line">svn copy branchA branchB  -m <span class="string">"make B branch"</span> // 从branchA拷贝出一个新分支branchB</span><br><span class="line">合并内容到分支merge</span><br><span class="line">svn merge branchA branchB  // 把对branchA的修改合并到分支branchB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;svn常用操作命令&quot;&gt;&lt;a href=&quot;#svn常用操作命令&quot; class=&quot;headerlink&quot; title=&quot;svn常用操作命令&quot;&gt;&lt;/a&gt;svn常用操作命令&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liwanggui
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CoreDump</title>
    <link href="http://www.tangyilong.com/2019/01/30/CoreDump/"/>
    <id>http://www.tangyilong.com/2019/01/30/CoreDump/</id>
    <published>2019-01-30T08:59:10.000Z</published>
    <updated>2019-02-20T12:33:14.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-Core-Dump"><a href="#Linux-Core-Dump" class="headerlink" title="Linux Core Dump"></a>Linux Core Dump</h1><p>​    当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做<strong>Core Dump</strong>（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。</p><p>​    OS在出Core的同时，虽然会终止掉当前进程，但是也会保留下第一手的现场数据，OS仿佛是一架被按下快门的相机，而照片就是产出的Core文件。里面含有当进程被终止时内存、CPU寄存器等信息，可以供后续开发人员进行调试。 </p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>​    在半导体作为电脑内存材料之前，电脑内存使用的是 <a href="http://en.wikipedia.org/wiki/Core_memory" target="_blank" rel="noopener"><strong>磁芯内存</strong></a>（Magnetic Core Memory），Core Dump 中的 Core 沿用了磁芯内存的 <strong>Core</strong> 表达。</p><p>​    <strong>Dump</strong> 指的是拷贝一种存储介质中的部分内容到另一个存储介质，或者将内容打印、显示或者其它输出设备。dump 出来的内容是格式化的，可以使用一些工具来解析它。</p><p>​    现代操作系统中，用 <strong>Core Dump</strong> 表示当程序异常终止或崩溃时，将进程此时的内存中的内容拷贝到磁盘文件中存储，以方便编程人员调试。</p><h2 id="Core-Dump-如何产生"><a href="#Core-Dump-如何产生" class="headerlink" title="Core Dump 如何产生"></a>Core Dump 如何产生</h2><p>上面说当程序运行过程中<strong>异常终止</strong>或<strong>崩溃</strong>时会发生 core dump，但还没说到什么具体的情景程序会发生异常终止或崩溃，例如我们使用 <code>kill -9</code> 命令杀死一个进程会发生 core dump 吗？实验证明是不能的，那么什么情况会产生呢？</p><p>Linux 中信号是一种异步事件处理的机制，每种信号对应有其默认的操作，你可以在 <strong>这里</strong> 查看 Linux 系统提供的信号以及默认处理。默认操作主要包括忽略该信号（Ingore）、暂停进程（Stop）、终止进程（Terminate）、终止并发生core dump（core）等。如果我们信号均是采用默认操作，那么，以下列出几种信号，它们在发生时会产生 core dump:</p><table><thead><tr><th>Signal</th><th>Action</th><th>Comment</th></tr></thead><tbody><tr><td>SIGQUIT</td><td>Core</td><td>Quit from keyboard</td></tr><tr><td>SIGILL</td><td>Core</td><td>Illegal Instruction</td></tr><tr><td>SIGABRT</td><td>Core</td><td>Abort signal from <a href="http://man7.org/linux/man-pages/man3/abort.3.html" target="_blank" rel="noopener">abort</a></td></tr><tr><td>SIGSEGV</td><td>Core</td><td>Invalid memory reference</td></tr><tr><td>SIGTRAP</td><td>Core</td><td>Trace/breakpoint trap</td></tr></tbody></table><p>当然不仅限于上面的几种信号。这就是为什么我们使用 <code>Ctrl+z</code> 来挂起一个进程或者 <code>Ctrl+C</code> 结束一个进程均不会产生 core dump，因为前者会向进程发出 <strong>SIGTSTP</strong> 信号，该信号的默认操作为暂停进程（Stop Process）；后者会向进程发出<strong>SIGINT</strong> 信号，该信号默认操作为终止进程（Terminate Process）。同样上面提到的 <code>kill -9</code> 命令会发出 <strong>SIGKILL</strong> 命令，该命令默认为终止进程。而如果我们使用 <code>Ctrl+\</code> 来终止一个进程，会向进程发出 <strong>SIGQUIT</strong> 信号，默认是会产生 core dump 的。还有其它情景会产生 core dump， 如：程序调用 <code>abort()</code> 函数、访存错误、非法指令等等。</p><p>下面举两个例子来说明：</p><ul><li><p>终端下比较 <code>Ctrl+C</code> 和 <code>Ctrl+\</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">guohailin@guohailin:~$ sleep 10        #使用sleep命令休眠 10 s</span><br><span class="line">^C                           #使用 Ctrl+C 终止该程序,不会产生 core dump</span><br><span class="line">guohailin@guohailin:~$ sleep 10</span><br><span class="line">^\Quit (core dumped)                #使用 Ctrl+\ 退出程序, 会产生 core dump</span><br><span class="line">guohailin@guohailin:~$ ls         #多出下面一个 core 文件</span><br><span class="line">-rw-------  1 guohailin guohailin 335872 10月 22 11:31 sleep.core.21990</span><br></pre></td></tr></table></figure></li><li><p>小程序产生 core dump</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *null_ptr = NULL;</span><br><span class="line">    *null_ptr = 10;            //对空指针指向的内存区域写,会发生段错误</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译执行</span></span><br><span class="line">guohailin@guohailin:~$ ./a.out</span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">guohailin@guohailin:~$ ls      <span class="comment">#多出下面一个 core 文件</span></span><br><span class="line">-rw-------  1 guohailin guohailin 200704 10月 22 11:35 a.out.core.22070</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何打开Core-Dump"><a href="#如何打开Core-Dump" class="headerlink" title="如何打开Core Dump"></a>如何打开Core Dump</h2><ul><li><p><strong>打开 core dump 功能</strong></p><ul><li>在终端中输入命令 <code>ulimit -c</code> ，输出的结果为 0，说明默认是关闭 core dump 的，即当程序异常终止时，也不会生成 core dump 文件。</li><li>我们可以使用命令 <code>ulimit -c unlimited</code> 来开启 core dump 功能，并且不限制 core dump 文件的大小； 如果需要限制文件的大小，将 unlimited 改成你想生成 core 文件最大的大小，注意单位为 blocks（KB）。</li><li>用上面命令只会对当前的终端环境有效，如果想需要永久生效，可以修改文件 <code>/etc/security/limits.conf</code>文件，关于此文件的设置参看 <strong>这里</strong> 。增加一行:</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/security/limits.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#Each line describes a limit for a user in the form:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#&lt;domain&gt;   &lt;type&gt;   &lt;item&gt;   &lt;value&gt;</span></span><br><span class="line">    *          soft     core   unlimited</span><br></pre></td></tr></table></figure></li><li><p><strong>修改 core 文件保存的路径</strong></p><ul><li><p>默认生成的 core 文件保存在可执行文件所在的目录下，文件名就为 <code>core</code>。</p></li><li><p>通过修改 <code>/proc/sys/kernel/core_uses_pid</code> 文件可以让生成 core 文件名是否自动加上 pid 号。<br>例如 <code>echo 1 &gt; /proc/sys/kernel/core_uses_pid</code> ，生成的 core 文件名将会变成 <code>core.pid</code>，其中 pid 表示该进程的 PID。</p></li><li><p>还可以通过修改 <code>/proc/sys/kernel/core_pattern</code> 来控制生成 core 文件保存的位置以及文件名格式。<br>例如可以用 <code>echo &quot;/tmp/corefile-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern</code> 设置生成的 core 文件保存在 “/tmp/corefile” 目录下，文件名格式为 “core-命令名-pid-时间戳”。<strong>这里</strong> 有更多详细的说明！</p></li><li><p>修改/proc/sys/kernel/core_pattern文件，此文件用于控制Core文件产生的文件名，默认情况下，此文件内容只有一行内容：“core”，此文件支持定制，一般使用%配合不同的字符，这里罗列几种：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">p</span></span>  出Core进程的PID</span><br><span class="line"><span class="tag">%<span class="selector-tag">u</span></span>  出Core进程的UID</span><br><span class="line"><span class="tag">%<span class="selector-tag">s</span></span>  造成Core的signal号</span><br><span class="line"><span class="tag">%<span class="selector-tag">t</span></span>  出Core的时间，从1970-01-0100:00:00开始的秒数</span><br><span class="line"><span class="tag">%<span class="selector-tag">e</span></span>  出Core进程对应的可执行文件名</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>程序中开启core dump，通过如下API可以查看和设置RLIMIT_CORE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><p>resource：可能的选择有</p><p>RLIMIT_AS //进程的最大虚内存空间，字节为单位。<br>RLIMIT_CORE //内核转存文件的最大长度。<br>RLIMIT_CPU //最大允许的CPU使用时间，秒为单位。当进程达到软限制，内核将给其发送SIGXCPU信号，这一信号的默认行为是终止进程的执行。然而，可以捕捉信号，处理句柄可将控制返回给主程序。如果进程继续耗费CPU时间，核心会以每秒一次的频率给其发送SIGXCPU信号，直到达到硬限制，那时将给进程发送 SIGKILL信号终止其执行。<br>RLIMIT_DATA //进程数据段的最大值。<br>RLIMIT_FSIZE //进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。<br>RLIMIT_LOCKS //进程可建立的锁和租赁的最大值。<br>RLIMIT_MEMLOCK //进程可锁定在内存中的最大数据量，字节为单位。<br>RLIMIT_MSGQUEUE //进程可为POSIX消息队列分配的最大字节数。<br>RLIMIT_NICE //进程可通过setpriority() 或 nice()调用设置的最大完美值。<br>RLIMIT_NOFILE //指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误。<br>RLIMIT_NPROC //用户可拥有的最大进程数。<br>RLIMIT_RTPRIO //进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。<br>RLIMIT_SIGPENDING //用户可拥有的最大挂起信号数。<br>RLIMIT_STACK //最大的进程堆栈，以字节为单位。</p><p>rlim：描述资源软硬限制的结构体，原型如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回说明：</p><p>成功执行时，返回0。失败返回-1，errno被设为以下的某个值<br>EFAULT：rlim指针指向的空间不可访问<br>EINVAL：参数无效<br>EPERM：增加资源限制值时，权能不允许</p><p>延伸阅读：</p><p>ulimit和setrlimit轻松修改task进程资源上限值</p><p>在linux系统中，Resouce limit指在一个进程的执行过程中，它所能得到的资源的限制，比如进程的core file的最大值，虚拟内存的最大值等。</p><p>Resouce limit的大小可以直接影响进程的执行状况。其有两个最重要的概念：soft limit 和 hard limit。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_cur;　　<span class="comment">//soft limit</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_max;　　<span class="comment">//hard limit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>soft limit是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。<br>hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_SIZE   1024 * 1024 * 500</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlmt</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_CORE, &amp;rlmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Before set rlimit CORE dump current is:%d, max is:%d\n"</span>, (<span class="keyword">int</span>)rlmt.rlim_cur, (<span class="keyword">int</span>)rlmt.rlim_max);</span><br><span class="line"></span><br><span class="line">    rlmt.rlim_cur = (<span class="keyword">rlim_t</span>)CORE_SIZE;</span><br><span class="line">    rlmt.rlim_max  = (<span class="keyword">rlim_t</span>)CORE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setrlimit(RLIMIT_CORE, &amp;rlmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_CORE, &amp;rlmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After set rlimit CORE dump current is:%d, max is:%d\n"</span>, (<span class="keyword">int</span>)rlmt.rlim_cur, (<span class="keyword">int</span>)rlmt.rlim_max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试非法内存，产生core文件*/</span></span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    *ptr = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行./main, 生成的core文件如下所示</p><p><img src="/pic/COreDump1.png" alt="img"></p><h2 id="GDB-调试CORE文件"><a href="#GDB-调试CORE文件" class="headerlink" title="GDB 调试CORE文件"></a>GDB 调试CORE文件</h2><p>产生了 core 文件，我们该如何使用该 Core 文件进行调试呢？Linux 中可以使用 GDB 来调试 core 文件，步骤如下：</p><ul><li>首先，使用 gcc 编译源文件，加上 <code>-g</code> 以增加调试信息；</li><li>按照上面打开 core dump 以使程序异常终止时能生成 core 文件；</li><li>运行程序，当core dump 之后，使用命令 <code>gdb program core</code> 来查看 core 文件，其中 program 为可执行程序名，core 为生成的 core 文件名。<br><img src="/pic/COreDump2.png" alt="img"></li></ul><h3 id="另一个简单的例子"><a href="#另一个简单的例子" class="headerlink" title="另一个简单的例子"></a>另一个简单的例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = *p;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> func(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译加上调试信息, 运行之后core dump, 使用 gdb 查看 core 文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">guohailin@guohailin:~$ gcc core_demo.c -o core_demo -g</span><br><span class="line">guohailin@guohailin:~$ ./core_demo </span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line"></span><br><span class="line">guohailin@guohailin:~$ gdb core_demo core_demo.core.24816</span><br><span class="line">...</span><br><span class="line">Core was generated by <span class="string">'./core_demo'</span>.</span><br><span class="line">Program terminated with signal 11, Segmentation fault.</span><br><span class="line"><span class="comment">#0  0x080483cd in func (p=0x0) at core_demo.c:5</span></span><br><span class="line">5       int y = *p;</span><br><span class="line">(gdb)  <span class="built_in">where</span></span><br><span class="line"><span class="comment">#0  0x080483cd in func (p=0x0) at core_demo.c:5</span></span><br><span class="line"><span class="comment">#1  0x080483ef in main () at core_demo.c:12</span></span><br><span class="line">(gdb) info frame</span><br><span class="line">Stack level 0, frame at 0xffd590a4:</span><br><span class="line"> eip = 0x80483cd <span class="keyword">in</span> func (core_demo.c:5); saved eip 0x80483ef</span><br><span class="line"> called by frame at 0xffd590c0</span><br><span class="line"> <span class="built_in">source</span> language c.</span><br><span class="line"> Arglist at 0xffd5909c, args: p=0x0</span><br><span class="line"> Locals at 0xffd5909c, Previous frame<span class="string">'s sp is 0xffd590a4</span></span><br><span class="line"><span class="string"> Saved registers:</span></span><br><span class="line"><span class="string">  ebp at 0xffd5909c, eip at 0xffd590a0</span></span><br><span class="line"><span class="string">(gdb)</span></span><br></pre></td></tr></table></figure><p>从上面可以看出,我们可以还原 core_demo 执行时的场景,并使用 <code>where</code> 可以查看当前程序调用函数栈帧, 还可以使用 gdb 中的命令查看寄存器,变量等信息.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-Core-Dump&quot;&gt;&lt;a href=&quot;#Linux-Core-Dump&quot; class=&quot;headerlink&quot; title=&quot;Linux Core Dump&quot;&gt;&lt;/a&gt;Linux Core Dump&lt;/h1&gt;&lt;p&gt;​    当程序运行的过程中异常终止
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Socket编程详解</title>
    <link href="http://www.tangyilong.com/2018/12/25/Socket%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.tangyilong.com/2018/12/25/Socket编程详解/</id>
    <published>2018-12-25T07:18:15.000Z</published>
    <updated>2019-02-20T12:39:46.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket编程详解"><a href="#Socket编程详解" class="headerlink" title="Socket编程详解"></a>Socket编程详解</h1><h2 id="什么是TCP-IP、UDP"><a href="#什么是TCP-IP、UDP" class="headerlink" title="什么是TCP/IP、UDP"></a>什么是TCP/IP、UDP</h2><p>TCP/IP协议族包括运输层、网络层、链路层，而socket所在位置如图，Socket是应用层与TCP/IP协议族通信的中间软件抽象层。</p><p><img src="/pic/1334044170_5136.jpg" alt="1334044170_5136"></p><h2 id="Socket是什么"><a href="#Socket是什么" class="headerlink" title="Socket是什么"></a>Socket是什么</h2><p>socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）.<br>​     说白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，<strong>它是一组接口</strong>。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>​       注意：其实socket也没有层的概念，它只是一个facade设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过socket实现的。</p><p> <strong>基本的SOCKET接口函数</strong></p><p><img src="/pic/1334045011_9586.jpg" alt="1334045011_9586"></p><p> <strong>三次握手</strong></p><p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers)。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>一个完整的三次握手也就是： 请求—应答—再次确认</p><p><img src="/pic/1334045728_5744.png" alt="1334045728_5744"></p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立</p><p><strong>四次握手</strong></p><p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭(half-close)造成的，如图：</p><p><img src="/pic/1334046363_4881.jpg" alt="1334046363_4881"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p><p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p><p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p><p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</p><p>对应函数接口如图：</p><p><img src="/pic/1334046534_7834.png" alt="1334046534_7834"></p><h2 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h2><p>server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File Name: server.c */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_PORT 8000  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>    socket_fd, connect_fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>     <span class="title">servaddr</span>;</span>  </span><br><span class="line">    <span class="keyword">char</span>    buff[<span class="number">4096</span>];  </span><br><span class="line">    <span class="keyword">int</span>     n;  </span><br><span class="line">    <span class="comment">//初始化Socket  </span></span><br><span class="line">    <span class="keyword">if</span>( (socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span> )&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//初始化  </span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//IP地址设置成INADDR_ANY,让系统自动获取本机的IP地址。  </span></span><br><span class="line">    servaddr.sin_port = htons(DEFAULT_PORT);<span class="comment">//设置的端口为DEFAULT_PORT  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将本地地址绑定到所创建的套接字上  </span></span><br><span class="line">    <span class="keyword">if</span>( bind(socket_fd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bind socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//开始监听是否有客户端连接  </span></span><br><span class="line">    <span class="keyword">if</span>( listen(socket_fd, <span class="number">10</span>) == <span class="number">-1</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listen socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"======waiting for client's request======\n"</span>);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line"><span class="comment">//阻塞直到有客户端连接，不然多浪费CPU资源。  </span></span><br><span class="line">        <span class="keyword">if</span>( (connect_fd = accept(socket_fd, (struct sockaddr*)<span class="literal">NULL</span>, <span class="literal">NULL</span>)) == <span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"accept socket error: %s(errno: %d)"</span>,strerror(errno),errno);  </span><br><span class="line">        <span class="keyword">continue</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//接受客户端传过来的数据  </span></span><br><span class="line">    n = recv(connect_fd, buff, MAXLINE, <span class="number">0</span>);  </span><br><span class="line"><span class="comment">//向客户端发送回应数据  </span></span><br><span class="line">    <span class="keyword">if</span>(!fork())&#123; <span class="comment">/*紫禁城*/</span>  </span><br><span class="line">        <span class="keyword">if</span>(send(connect_fd, <span class="string">"Hello,you are connected!\n"</span>, <span class="number">26</span>,<span class="number">0</span>) == <span class="number">-1</span>)  </span><br><span class="line">        perror(<span class="string">"send error"</span>);  </span><br><span class="line">        close(connect_fd);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    buff[n] = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv msg from client: %s\n"</span>, buff);  </span><br><span class="line">    close(connect_fd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(socket_fd);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File Name: client.c */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>    sockfd, n,rec_len;  </span><br><span class="line">    <span class="keyword">char</span>    recvline[<span class="number">4096</span>], sendline[<span class="number">4096</span>];  </span><br><span class="line">    <span class="keyword">char</span>    buf[MAXLINE];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>    <span class="title">servaddr</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usage: ./client &lt;ipaddress&gt;\n"</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_port = htons(<span class="number">8000</span>);  </span><br><span class="line">    <span class="keyword">if</span>( inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"inet_pton error for %s\n"</span>,argv[<span class="number">1</span>]);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>( connect(sockfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send msg to server: \n"</span>);  </span><br><span class="line">    fgets(sendline, <span class="number">4096</span>, <span class="built_in">stdin</span>);  </span><br><span class="line">    <span class="keyword">if</span>( send(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>) &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send msg error: %s(errno: %d)\n"</span>, strerror(errno), errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>((rec_len = recv(sockfd, buf, MAXLINE,<span class="number">0</span>)) == <span class="number">-1</span>) &#123;  </span><br><span class="line">       perror(<span class="string">"recv error"</span>);  </span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    buf[rec_len]  = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Received : %s "</span>,buf);  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inet_pton 是Linux下IP地址转换函数，可以在将IP地址在“点分十进制”和“整数”之间转换 ，是inet_addr的扩展。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;<span class="comment">//转换字符串到网络地址:</span></span><br></pre></td></tr></table></figure><p>第一个参数af是地址族，转换后存在dst中<br>​    af = AF_INET:src为指向字符型的地址，即ASCII的地址的首地址（ddd.ddd.ddd.ddd格式的），函数将该地址转换为in_addr的结构体，并复制在<em>dst中<br>　　af =AF_INET6:src为指向IPV6的地址，函数将该地址转换为in6_addr的结构体，并复制在</em>dst中<br>如果函数出错将返回一个负值，并将errno设置为EAFNOSUPPORT，如果参数af指定的地址族和src格式不对，函数将返回0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Socket编程详解&quot;&gt;&lt;a href=&quot;#Socket编程详解&quot; class=&quot;headerlink&quot; title=&quot;Socket编程详解&quot;&gt;&lt;/a&gt;Socket编程详解&lt;/h1&gt;&lt;h2 id=&quot;什么是TCP-IP、UDP&quot;&gt;&lt;a href=&quot;#什么是TCP-I
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>POSIX消息队列</title>
    <link href="http://www.tangyilong.com/2018/12/25/POSIX%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://www.tangyilong.com/2018/12/25/POSIX消息队列/</id>
    <published>2018-12-25T06:51:03.000Z</published>
    <updated>2019-02-20T12:35:41.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="POSIX消息队列"><a href="#POSIX消息队列" class="headerlink" title="POSIX消息队列"></a>POSIX消息队列</h1><p><a href="https://blog.csdn.net/anonymalias/article/details/9799645" target="_blank" rel="noopener">原文地址</a></p><p>消息队列是Linux IPC中很常用的一种通信方式，它通常用来在不同进程间发送特定格式的消息数据。</p><p>消息队列和之前讨论过的管道和FIFO有很大的区别，主要有以下两点：</p><p>一个进程向消息队列写入消息之前，并不需要某个进程在该队列上等待该消息的到达，而管道和FIFO是相反的，进程向其中写消息时，管道和FIFO必需已经打开来读，那么内核会产生SIGPIPE信号(感谢shanshan_fangfang的指正)。<br> IPC的持续性不同。管道和FIFO是随进程的持续性，当管道和FIFO最后一次关闭发生时，仍在管道和FIFO中的数据会被丢弃。消息队列是随内核的持续性，即一个进程向消息队列写入消息后，然后终止，另外一个进程可以在以后某个时刻打开该队列读取消息。只要内核没有重新自举，消息队列没有被删除。<br>消息队列中的每条消息通常具有以下属性：</p><p>一个表示优先级的整数；<br>消息的数据部分的长度；<br> 消息数据本身；<br>POSIX消息队列的一个可能的设计是一个如下图所示的消息链表，链表头部有消息队列的属性信息。  </p><p><img src="/pic/20130806231545312.jpg" alt="20130806231545312"></p><h2 id="1-POSIX消息队列的创建和关闭"><a href="#1-POSIX消息队列的创建和关闭" class="headerlink" title="1 POSIX消息队列的创建和关闭"></a>1 POSIX消息队列的创建和关闭</h2><p>POSIX消息队列的创建，关闭和删除用到以下三个函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_open(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, <span class="comment">/* mode_t mode, struct mq_attr *attr */</span>);</span><br><span class="line"><span class="comment">//成功返回消息队列描述符，失败返回-1</span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_close(<span class="keyword">mqd_t</span> mqdes);</span><br><span class="line"><span class="keyword">mqd_t</span> mq_unlink(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>mq_open用于打开或创建一个消息队列。</p><p><strong>name</strong>：表示消息队列的名字，它符合POSIX IPC的名字规则。</p><p><strong>oflag</strong>：表示打开的方式，和open函数的类似。有必须的选项：O_RDONLY，O_WRONLY，O_RDWR，还有可选的选项：O_NONBLOCK，O_CREAT，O_EXCL。</p><p><strong>mode</strong>：是一个可选参数，在oflag中含有O_CREAT标志且消息队列不存在时，才需要提供该参数。表示默认访问权限。可以参考open。</p><p><strong>attr</strong>：也是一个可选参数，在oflag中含有O_CREAT标志且消息队列不存在时才需要。该参数用于给新队列设定某些属性，如果是空指针，那么就采用默认属性。</p><p>mq_open返回值是mqd_t类型的值，被称为消息队列描述符。在Linux 2.6.18中该类型的定义为整型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">mqd_t</span>;</span><br></pre></td></tr></table></figure></p><p>mq_close用于关闭一个消息队列，和文件的close类型，关闭后，消息队列并不从系统中删除。一个进程结束，会自动调用关闭打开着的消息队列。</p><p>mq_unlink用于删除一个消息队列。消息队列创建后只有通过调用该函数或者是内核自举才能进行删除。每个消息队列都有一个保存当前打开着描述符数的引用计数器，和文件一样，因此本函数能够实现类似于unlink函数删除一个文件的机制。</p><p>POSIX消息队列的名字==所创建的真正路径名和具体的系统实现有关==，关于具体POSIX IPC的名字规则可以参考《UNIX 网络编程 卷2：进程间通信》的P14。</p><p>经过测试，在Linux 2.6.18中，所创建的POSIX消息队列不会在文件系统中创建真正的路径名。且POSIX的名字只能以一个’/’开头，名字中不能包含其他的’/’。</p><h2 id="2-POSIX消息队列的属性"><a href="#2-POSIX消息队列的属性" class="headerlink" title="2 POSIX消息队列的属性"></a>2 POSIX消息队列的属性</h2><p>POSIX标准规定消息队列属性mq_attr必须要含有以下四个内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span>    mq_flags <span class="comment">//消息队列的标志：0或O_NONBLOCK,用来表示是否阻塞 </span></span><br><span class="line"><span class="keyword">long</span>    mq_maxmsg  <span class="comment">//消息队列的最大消息数</span></span><br><span class="line"><span class="keyword">long</span>    mq_msgsize  <span class="comment">//消息队列中每个消息的最大字节数</span></span><br><span class="line"><span class="keyword">long</span>    mq_curmsgs  <span class="comment">//消息队列中当前的消息数目</span></span><br></pre></td></tr></table></figure><p>在Linux 2.6.18中mq_attr结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/mqueue.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_flags;      <span class="comment">/* Message queue flags.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_maxmsg;   <span class="comment">/* Maximum number of messages.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_msgsize;   <span class="comment">/* Maximum message size.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_curmsgs;   <span class="comment">/* Number of messages currently queued.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __pad[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>POSIX消息队列的属性设置和获取可以通过下面两个函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_getattr(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *attr);</span><br><span class="line"><span class="keyword">mqd_t</span> mq_setattr(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *newattr, struct mq_attr *oldattr);</span><br><span class="line">                               <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>mq_getattr用于获取当前消息队列的属性，mq_setattr用于设置当前消息队列的属性。其中mq_setattr中的oldattr用于保存修改前的消息队列的属性，可以为空。</p><p>mq_setattr==可以设置的属性只有mq_flags==，用来设置或清除消息队列的非阻塞标志。newattr结构的其他属性被忽略。mq_maxmsg和mq_msgsize属性只能在创建消息队列时通过mq_open来设置。==mq_open只会设置该两个属性，忽略另外两个属性==。mq_curmsgs属性只能被获取而不能被设置。</p><p>下面是测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqID;</span><br><span class="line">    mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (mq_getattr(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"get the message queue attribute error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_flags:"</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_maxmsg:"</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_msgsize:"</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_curmsgs:"</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Linux 2.6.18中执行结果是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure></p><h2 id="3-POSIX消息队列的使用"><a href="#3-POSIX消息队列的使用" class="headerlink" title="3 POSIX消息队列的使用"></a>3 POSIX消息队列的使用</h2><p>POSIX消息队列可以通过以下两个函数来进行发送和接收消息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_send(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> msg_prio);</span><br><span class="line">                     <span class="comment">//成功返回0，出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mqd_t</span> mq_receive(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> *msg_prio);</span><br><span class="line">                     <span class="comment">//成功返回接收到消息的字节数，出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_timedsend(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> msg_prio,</span><br><span class="line">                      <span class="keyword">const</span> struct timespec *abs_timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">mqd_t</span> mq_timedreceive(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> *msg_prio,</span><br><span class="line">                      <span class="keyword">const</span> struct timespec *abs_timeout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>mq_send向消息队列中写入一条消息，mq_receive从消息队列中读取一条消息。</p><p><em>mqdes</em>：消息队列描述符；</p><p><em>msg_ptr</em>：指向消息体缓冲区的指针；</p><p><em>msg_len</em>：消息体的长度，其中==mq_receive的该参数不能小于能写入队列中消息的最大大小，即一定要大于等于该队列的mq_attr结构中mq_msgsize的大小==。如果mq_receive中的msg_len小于该值，就会返回EMSGSIZE错误。POXIS消息队列发送的消息长度可以为0。</p><p><em>msg_prio</em>：消息的优先级；它是一个小于MQ_PRIO_MAX的数，数值越大，优先级越高。POSIX消息队列在调用mq_receive时总是返回队列中最高优先级的最早消息。如果消息不需要设定优先级，那么可以在mq_send是置msg_prio为0，mq_receive的msg_prio置为NULL。</p><p>还有两个XSI定义的扩展接口限时发送和接收消息的函数：mq_timedsend和mq_timedreceive函数。默认情况下mq_send和mq_receive是阻塞进行调用，可以通过mq_setattr来设置为O_NONBLOCK。</p><p>下面是消息队列使用的测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqID;</span><br><span class="line">    mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT | O_EXCL, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">            mq_unlink(<span class="string">"/anonymQueue"</span>);</span><br><span class="line">            mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mq_attr mqAttr;</span><br><span class="line">        mq_getattr(mqID, &amp;mqAttr);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[mqAttr.mq_msgsize];</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mq_receive(mqID, buf, mqAttr.mq_msgsize, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"receive message  failed. "</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"error info:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">     </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"receive message "</span>&lt;&lt;i&lt;&lt;<span class="string">": "</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> msg[] = <span class="string">"yuki"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mq_send(mqID, msg, <span class="keyword">sizeof</span>(msg), i) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"send message "</span>&lt;&lt;i&lt;&lt;<span class="string">" failed. "</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error info:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"send message "</span>&lt;&lt;i&lt;&lt;<span class="string">" success. "</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">     </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Linux 2.6.18下的执行结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">send message 1 success. </span><br><span class="line">receive message 1: yuki</span><br><span class="line">send message 2 success. </span><br><span class="line">receive message 2: yuki</span><br><span class="line">send message 3 success. </span><br><span class="line">receive message 3: yuki</span><br><span class="line">send message 4 success. </span><br><span class="line">receive message 4: yuki</span><br><span class="line">send message 5 success. </span><br><span class="line">receive message 5: yuki</span><br></pre></td></tr></table></figure></p><h2 id="4-POSIX消息队列的限制"><a href="#4-POSIX消息队列的限制" class="headerlink" title="4 POSIX消息队列的限制"></a>4 POSIX消息队列的限制</h2><p>POSIX消息队列本身的限制就是mq_attr中的mq_maxmsg和mq_msgsize，分别用于限定消息队列中的最大消息数和每个消息的最大字节数。在前面已经说过了，这两个参数可以在调用mq_open创建一个消息队列的时候设定。当这个设定是受到系统内核限制的。</p><p>下面是在Linux 2.6.18下shell对启动进程的POSIX消息队列大小的限制：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -a |grep message</span></span><br><span class="line">POSIX <span class="keyword">message</span> queues     (bytes, -q) <span class="number">819200</span></span><br></pre></td></tr></table></figure></p><p>限制大小为800KB，==该大小是整个消息队列的大小，不仅仅是最大消息数*消息的最大大小；还包括消息队列的额外开销==。前面我们知道Linux 2.6.18下POSIX消息队列默认的最大消息数和消息的最大大小分别为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mq_maxmsg</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">mq_msgsize</span> = <span class="number">8192</span></span><br></pre></td></tr></table></figure><p>为了说明上面的限制大小包括消息队列的额外开销，下面是测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqID;</span><br><span class="line">    mq_attr attr;</span><br><span class="line">    attr.mq_maxmsg = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    attr.mq_msgsize = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT | O_EXCL, <span class="number">0666</span>, &amp;attr);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">            mq_unlink(<span class="string">"/anonymQueue"</span>);</span><br><span class="line">            mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, &amp;attr);</span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span>(mqID &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (mq_getattr(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"get the message queue attribute error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_flags:"</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_maxmsg:"</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_msgsize:"</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_curmsgs:"</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面进行创建消息队列时设置最大消息数和消息的最大大小进行测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@idcserver program]<span class="comment"># g++ -g test.cpp -lrt</span></span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 81920</span></span><br><span class="line">open message queue error...Cannot allocate memory</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 80000</span></span><br><span class="line">open message queue error...Cannot allocate memory</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 70000</span></span><br><span class="line">open message queue error...Cannot allocate memory</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 60000</span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:60000</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure></p><p>从上面可以看出消息队列真正存放消息数据的大小是没有819200B的。可以通过修改该限制参数，来改变消息队列的所能容纳消息的数量。可以通过下面方式来修改限制，但这会在shell启动进程结束后失效，可以将设置写入开机启动的脚本中执行，例如.bashrc，rc.local。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@idcserver ~]# ulimit -q 1024000000</span><br><span class="line">[root@idcserver ~]# ulimit -a |grep message</span><br><span class="line">POSIX message queues     (bytes, -q) 1024000000</span><br></pre></td></tr></table></figure><p>下面再次测试可以设置的消息队列的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 81920</span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:81920</span><br><span class="line">mq_curmsgs:0</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 819200</span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:819200</span><br><span class="line">mq_curmsgs:0</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 1000 8192  </span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:1000</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure></p><p>POSIX消息队列在实现上还有另外两个限制：</p><p><strong>MQ_OPEN_MAX</strong>：一个进程能同时打开的消息队列的最大数目，POSIX要求至少为8；</p><p><strong>MQ_PRIO_MAX</strong>：消息的最大优先级，POSIX要求至少为32；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;POSIX消息队列&quot;&gt;&lt;a href=&quot;#POSIX消息队列&quot; class=&quot;headerlink&quot; title=&quot;POSIX消息队列&quot;&gt;&lt;/a&gt;POSIX消息队列&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/anonymalias
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GCC编译过程和动态静态库</title>
    <link href="http://www.tangyilong.com/2018/12/25/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://www.tangyilong.com/2018/12/25/GCC编译过程和动态静态库/</id>
    <published>2018-12-25T06:39:56.000Z</published>
    <updated>2019-02-20T12:34:36.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GCC编译过程和动态静态库"><a href="#GCC编译过程和动态静态库" class="headerlink" title="GCC编译过程和动态静态库"></a>GCC编译过程和动态静态库</h1><p><em>outline</em></p><p>[TOC]</p><p>本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。<strong>库有两种：静态库（.a、.lib）和动态库（.so、.dll）。 windows上对应的是.lib .dll linux上对应的是.a .so</strong></p><p>编译过程：</p><p><img src="/pic/GCC1.png" alt="img"></p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>之所以成为【静态库】，<strong>是因为在链接阶段，会将汇编生成的目标文件</strong>.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p><p>试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，<strong>那么静态库必定跟</strong>.o文件格式相似<strong>其实一个静态库可以简单看成是</strong>一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：</p><ul><li>静态库对函数库的链接是放在编译时期完成的</li><li>程序在运行时与函数库再无瓜葛，移植方便。</li><li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li></ul><p>Linux静态库命名规范，必须是”lib[your_library_name].a”：lib为前缀，中间是静态库名，扩展名为==.a==</p><p>通过上面的流程可以知道，Linux创建静态库过程如下：</p><p>首先，将代码文件编译成目标文件.o（StaticMath.o）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-c</span> <span class="selector-tag">StaticMath</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">StaticMath</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure><p>注意带参数-c，否则直接编译为可执行文件</p><p>然后，通过ar工具将目标文件打包成.a静态库文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ar</span> <span class="selector-tag">-crv</span> <span class="selector-tag">libstaticmath</span><span class="selector-class">.a</span> <span class="selector-tag">StaticMath</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure><p>生成静态库<strong>libstaticmath.a</strong></p><p><strong>使用</strong></p><p>Linux下使用静态库，只需要在编译的时候，指定静态库的搜索路径（-L选项）、指定静态库名（不需要lib前缀和.a后缀，-l选项）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test<span class="selector-class">.c</span> -L ./ -lstaticmath</span><br></pre></td></tr></table></figure><ul><li><p>-L：表示要连接的库所在目录</p></li><li><p>-I：指定链接时需要的动态库，编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a或.so来确定库的名称。</p></li></ul><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>为什么需要动态库，其实也是静态库的特点导致。</p><p><strong>空间浪费是静态库的一个问题。</strong></p><p><img src="/pic/GCC2.png" alt="clip_image021[4]"></p><p>另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，<strong>全量更新</strong>）</p><p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。<strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</strong>，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，<strong>增量更新</strong>。</p><p><img src="/pic/GCC3.png" alt="img"></p><p> <strong>创建动态库</strong> </p><p>动态链接库的名字形式为 libxxx.so，前缀是lib，后缀名为“.so”。</p><ul><li><p>针对于实际库文件，每个共享库都有个特殊的名字“soname”。在程序启动后，程序通过这个名字来告诉动态加载器该载入哪个共享库。</p></li><li><p>在文件系统中，soname仅是一个链接到实际动态库的链接。对于动态库而言，每个库实际上都有另一个名字给编译器来用。它是一个指向实际库镜像文件的链接文件（lib+soname+.so）</p></li></ul><ul><li><p>首先，生成目标文件，此时要加编译器选项-fpic</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-fPIC</span> <span class="selector-tag">-c</span> <span class="selector-tag">DynamicMath</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><p>-fPIC创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</p></li><li><p>然后，生成动态库，此时要加链接器选项-shared</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">g</span>++ <span class="selector-tag">-shared</span> <span class="selector-tag">-o</span> <span class="selector-tag">libdynmath</span><span class="selector-class">.so</span> <span class="selector-tag">DynamicMath</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure><p>-shared指定生成动态链接库。<br>其实上面两个步骤可以合并为一个命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">g</span>++ <span class="selector-tag">-fPIC</span> <span class="selector-tag">-shared</span> <span class="selector-tag">-o</span> <span class="selector-tag">libdynmath</span><span class="selector-class">.so</span> <span class="selector-tag">DynamicMath</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><p><strong>使用动态库</strong></p></li></ul><p>引用动态库编译成可执行文件（跟静态库方式一样）：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ TestDynamicLibrary<span class="selector-class">.cpp</span> -L../DynamicLibrary -ldynmath</span><br></pre></td></tr></table></figure></p><p>然后运行：./a.out，发现竟然报错了！！！</p><p>解决方法：首先使用export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH将当前目录加入LD_LIBRARY_PATH变量中。再次运行</p><p>1) 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader)。<br>2) 对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib 目录找到库文件后将其载入内存。<br>如何让系统能够找到它：<br>如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。<br>如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下：<br>编辑/etc/ld.so.conf文件，加入库文件所在目录的路径<br>运行ldconfig ，该命令会重建/etc/ld.so.cache文件<br>我们将创建的动态库复制到/usr/lib下面，然后运行测试程序。</p><h2 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h2><p>编译过程可以被细分为四个阶段：</p><p><strong>预处理</strong>（ Pre-Processing ）<br><strong>编译</strong>（ Compiling ）<br><strong>汇编</strong>（ Asse mbling ）<br><strong>链接</strong>（ Linking ）</p><p><img src="/pic/GCC4.png" alt="img"></p><p><img src="/pic/GCC5.png" alt="img"></p><p><strong>GCC编译过程</strong></p><p>1）gcc 预处理阶段：主要对包含的头文件（＃include ）和宏定义（＃define,#ifdef … ）进行处理。可以使用“gcc -E” 让gcc 在预处理之后停止编译过程，生成 *.i 文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-E</span> <span class="selector-tag">hello</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.i</span></span><br></pre></td></tr></table></figure><p>2）gcc 编译阶段：gcc 首先要检查代码的规范性，是否有语法错误等。以确定代码实际要做的工作，在检查无误后，gcc 把代码翻译成汇编语言。用户可以使用-S 选项进行查看，该选项只进<br>行编译而不进行汇编，生成汇编代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-S</span> <span class="selector-tag">hello</span><span class="selector-class">.i</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.s</span></span><br></pre></td></tr></table></figure><p>3）gcc 汇编阶段：生成目标代码 <em>.o ；有两种方式：使用 gcc 直接从源代码生成目标代码 gcc -c </em>.s -o <em>.o 以及使用汇编器从汇编代码生成目标代码 as </em>.s -o *.o</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello<span class="selector-class">.s</span> -o hello.o</span><br><span class="line">as hello<span class="selector-class">.s</span> -o hello.o</span><br></pre></td></tr></table></figure><p>也可以直接使用as <em>.s, 将<strong>执行汇编、链接过程生成可执行文件a.out</strong>, 可以像上面使用<strong>-o 选项</strong>指定输出文件的格式。<br>4）gcc 链接阶段：生成可执行文件；可以生成的可执行文件格式有： a.out/</em>/,当然可能还有其它格式。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello<span class="selector-class">.o</span>     生成可执行文件 <span class="selector-tag">a</span>.out</span><br><span class="line">gcc hello<span class="selector-class">.o</span> -o hello        生成可执行文件 hello</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GCC编译过程和动态静态库&quot;&gt;&lt;a href=&quot;#GCC编译过程和动态静态库&quot; class=&quot;headerlink&quot; title=&quot;GCC编译过程和动态静态库&quot;&gt;&lt;/a&gt;GCC编译过程和动态静态库&lt;/h1&gt;&lt;p&gt;&lt;em&gt;outline&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;[T
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建Hexo执行 hexo 命令报错:ERROR Local hexo not found in xxx 二种解决方案</title>
    <link href="http://www.tangyilong.com/2018/11/29/ERROR-Local-hexo-not-found-in-Hexo/"/>
    <id>http://www.tangyilong.com/2018/11/29/ERROR-Local-hexo-not-found-in-Hexo/</id>
    <published>2018-11-29T11:57:29.000Z</published>
    <updated>2018-11-29T13:02:01.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案"><a href="#搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案" class="headerlink" title="搭建Hexo执行 hexo 命令报错:ERROR Local hexo not found in xxx 二种解决方案"></a>搭建Hexo执行 hexo 命令报错:ERROR Local hexo not found in xxx 二种解决方案</h1><h2 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h2><p>当输入hexo命令的时候会出现下面这张情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@:hexo_web# hexo -v</span><br><span class="line">ERROR Local hexo not found in ~/share/Hexo/hexo_web</span><br><span class="line">ERROR Try running: 'npm install hexo --save'</span><br></pre></td></tr></table></figure><p>导致这个原因为在自己的博客文件夹中,.gitignore文件中添加了node_modules/,导致更新的时候,这个文件夹被忽略,没有被更新上去。</p><p>解决方案:</p><p>​    1.cmd进入博客当前文件夹路径</p><p>​    2.执行 npm install</p><p>​    3.执行 hexo server</p><p>​    4.执行成功后,再到博客下的git中执行 hexo 命令 发现可以执行成功。</p><h2 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h2><p>首先是我是在网上找到的第一种方案，但是没有效果，所以就自己试着寻找一些蛛丝马迹</p><p>首先你在你的hexo目录下面使用hexo命令是不成功的</p><p>但是呢，当你退到上层目录的时候，hexo命令却是可以正常使用的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@:/home/share/Hexo/hexo_web# hexo -v</span><br><span class="line">ERROR Local hexo not found in ~/share/Hexo/hexo_web</span><br><span class="line">ERROR Try running: 'npm install hexo --save'</span><br><span class="line">root@:/home/share/Hexo/hexo_web# cd ..</span><br><span class="line">root@:/home/share/Hexo# hexo -v</span><br><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Linux 4.15.0-39-generic linux x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 4.2.6                      &lt;================</span><br><span class="line">v8: 6.8.275.32-node.36</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.14.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0i</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure><p>我注意到有一个地方不太对，那就是node的版本是4.2.6，版本太老了。</p><p>所以我就试着更新node的版本，把node的版本更新到最新版10.13.0</p><p>更新之后我们再进入到hexo的博客目录下面去执行命令，查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@:/home/share/Hexo/hexo_web# hexo -v</span><br><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Linux 4.15.0-39-generic linux x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.13.0              &lt;==========================</span><br><span class="line">v8: 6.8.275.32-node.36</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.14.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0i</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure><p>附上手动更新node的方法</p><h2 id="下载nodj二进制源码：xz结尾的压缩文件"><a href="#下载nodj二进制源码：xz结尾的压缩文件" class="headerlink" title="下载nodj二进制源码：xz结尾的压缩文件"></a>下载nodj二进制源码：xz结尾的压缩文件</h2><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node官网</a></p><p>注意：选择合适版本，我使用的是ubuntu,所以选择linux包下载下来就是源码，解压之后就存在node和npm。无需重复编译。</p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf node-v9.5.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在底部添加</span></span><br><span class="line">export NODE_HOME=/opt/nodejs/node-v11.1.0-linux-x64/bin</span><br><span class="line">export PATH=$NODE_HOME:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">激活修改</span></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证</span></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果全局安装pm2包，可以验证</span></span><br><span class="line">pm2 list</span><br></pre></td></tr></table></figure><p>那么我不是这么使用的，我是直接复制粘贴覆盖原来的node文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@:# which node</span><br><span class="line">/usr/bin/node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 到下载的最新node目录下面</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将bin里面的node拷贝过去</span></span><br><span class="line">root@:/opt/node-v10.13.0-linux-x64/bin# cp ./node /usr/bin/node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证</span></span><br><span class="line">root@:# node -v</span><br><span class="line">v10.13.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案&quot;&gt;&lt;a href=&quot;#搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案&quot; 
      
    
    </summary>
    
    
  </entry>
  
</feed>
