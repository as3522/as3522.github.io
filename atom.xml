<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>as3522</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tangyilong.com/"/>
  <updated>2019-04-13T06:22:45.864Z</updated>
  <id>http://www.tangyilong.com/</id>
  
  <author>
    <name>as3522</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字母对应的ASCII码和CTRL加字母的</title>
    <link href="http://www.tangyilong.com/2019/04/13/%E5%AD%97%E6%AF%8D%E5%AF%B9%E5%BA%94%E7%9A%84ASCII%E7%A0%81%E5%92%8CCTRL%E5%8A%A0%E5%AD%97%E6%AF%8D%E7%9A%84/"/>
    <id>http://www.tangyilong.com/2019/04/13/字母对应的ASCII码和CTRL加字母的/</id>
    <published>2019-04-13T06:22:22.000Z</published>
    <updated>2019-04-13T06:22:45.864Z</updated>
    
    <content type="html"><![CDATA[<p>对于字母的ASCII码来说。网上已经罗列出来了，这是很容易就获取的，然后对于ctrl+字母的以及shift+字母的却有点小难了。</p><p>最近在写脚本的时候，需要用到一些组合键，但是苦于不知道这些组合键对应的键盘码，就很尴尬</p><h2 id="CTRL-字母"><a href="#CTRL-字母" class="headerlink" title="CTRL+字母"></a>CTRL+字母</h2><p>  ASCII码1，2，3…分别依次对应键盘按键的Ctrl+A键，Ctrl+B键，Ctrl+C键，…Ctrl+Z键的ASCII为26.参考大写字母后的编码，按键Ctrl+[键产生ASCII码27，Ctrl+\键产生ASCII码28，Ctrl+]键产生ASCII码29，Ctrl+^键产生ASCII码30。常用的控制字符有退格（8），制表符（9），换行（10）.流量控制字符Xoff（17）和Xon（19），对应的按键分别是Ctrl+S，Ctrl+Q。 </p><p>  按照控制字符ASCII码于键盘按键的对应关系，在一个字符终端输入数据时，按下Ctrl+M与按下回车键的效果相同，应为回车的ASCII是13，M在字母表中排在第13位。同样按下Ctrl+J实际上是一个换行符，没有响应键盘按键对应。按下Ctrl+I与按下Tab键的效果相同，Ctrl+[与ESC相同。可以用Ctrl+H代替BackSpace键，在没有BackSpace的终端上，就是直接按Ctrl+H键。</p><p>ctrl+字母的ASCII码=字母的ASCII码&amp;0x1f</p><p>最后分享一个小软件可以查看对应的按键码，</p><p><a href="https://download.csdn.net/download/softimite_zifeng/9688867" target="_blank" rel="noopener">KeyCode</a></p><h2 id="键盘各键对应的编码值（key-code）"><a href="#键盘各键对应的编码值（key-code）" class="headerlink" title="键盘各键对应的编码值（key code）"></a>键盘各键对应的编码值（key code）</h2><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody><tr><td>backspace</td><td>8</td></tr><tr><td>tab</td><td>9</td></tr><tr><td>enter</td><td>13</td></tr><tr><td>shift</td><td>16</td></tr><tr><td>ctrl</td><td>17</td></tr><tr><td>alt</td><td>18</td></tr><tr><td>pause/break</td><td>19</td></tr><tr><td>caps lock</td><td>20</td></tr><tr><td>escape</td><td>27</td></tr><tr><td>page up</td><td>33</td></tr><tr><td>page down</td><td>34</td></tr><tr><td>end</td><td>35</td></tr><tr><td>home</td><td>36</td></tr><tr><td>left arrow</td><td>37</td></tr><tr><td>up arrow</td><td>38</td></tr><tr><td>right arrow</td><td>39</td></tr><tr><td>down arrow</td><td>40</td></tr><tr><td>insert</td><td>45</td></tr><tr><td>delete</td><td>46</td></tr><tr><td>0</td><td>48</td></tr><tr><td>1</td><td>49</td></tr><tr><td>2</td><td>50</td></tr><tr><td>3</td><td>51</td></tr><tr><td>4</td><td>52</td></tr><tr><td>5</td><td>53</td></tr><tr><td>6</td><td>54</td></tr><tr><td>7</td><td>55</td></tr><tr><td>8</td><td>56</td></tr><tr><td>9</td><td>57</td></tr><tr><td>a</td><td>65</td></tr><tr><td>b</td><td>66</td></tr><tr><td>c</td><td>67</td></tr><tr><td>d</td><td>68</td></tr></tbody></table><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody><tr><td>e</td><td>69</td></tr><tr><td>f</td><td>70</td></tr><tr><td>g</td><td>71</td></tr><tr><td>h</td><td>72</td></tr><tr><td>i</td><td>73</td></tr><tr><td>j</td><td>74</td></tr><tr><td>k</td><td>75</td></tr><tr><td>l</td><td>76</td></tr><tr><td>m</td><td>77</td></tr><tr><td>n</td><td>78</td></tr><tr><td>o</td><td>79</td></tr><tr><td>p</td><td>80</td></tr><tr><td>q</td><td>81</td></tr><tr><td>r</td><td>82</td></tr><tr><td>s</td><td>83</td></tr><tr><td>t</td><td>84</td></tr><tr><td>u</td><td>85</td></tr><tr><td>v</td><td>86</td></tr><tr><td>w</td><td>87</td></tr><tr><td>x</td><td>88</td></tr><tr><td>y</td><td>89</td></tr><tr><td>z</td><td>90</td></tr><tr><td>left window key</td><td>91</td></tr><tr><td>right window key</td><td>92</td></tr><tr><td>select key</td><td>93</td></tr><tr><td>numpad 0</td><td>96</td></tr><tr><td>numpad 1</td><td>97</td></tr><tr><td>numpad 2</td><td>98</td></tr><tr><td>numpad 3</td><td>99</td></tr><tr><td>numpad 4</td><td>100</td></tr><tr><td>numpad 5</td><td>101</td></tr><tr><td>numpad 6</td><td>102</td></tr><tr><td>numpad 7</td><td>103</td></tr></tbody></table><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody><tr><td>numpad 8</td><td>104</td></tr><tr><td>numpad 9</td><td>105</td></tr><tr><td>multiply</td><td>106</td></tr><tr><td>add</td><td>107</td></tr><tr><td>subtract</td><td>109</td></tr><tr><td>decimal point</td><td>110</td></tr><tr><td>divide</td><td>111</td></tr><tr><td>f1</td><td>112</td></tr><tr><td>f2</td><td>113</td></tr><tr><td>f3</td><td>114</td></tr><tr><td>f4</td><td>115</td></tr><tr><td>f5</td><td>116</td></tr><tr><td>f6</td><td>117</td></tr><tr><td>f7</td><td>118</td></tr><tr><td>f8</td><td>119</td></tr><tr><td>f9</td><td>120</td></tr><tr><td>f10</td><td>121</td></tr><tr><td>f11</td><td>122</td></tr><tr><td>f12</td><td>123</td></tr><tr><td>num lock</td><td>144</td></tr><tr><td>scroll lock</td><td>145</td></tr><tr><td>semi-colon</td><td>186</td></tr><tr><td>equal sign</td><td>187</td></tr><tr><td>comma</td><td>188</td></tr><tr><td>dash</td><td>189</td></tr><tr><td>period</td><td>190</td></tr><tr><td>forward slash</td><td>191</td></tr><tr><td>grave accent</td><td>192</td></tr><tr><td>open bracket</td><td>219</td></tr><tr><td>back slash</td><td>220</td></tr><tr><td>close braket</td><td>221</td></tr><tr><td>single quote</td><td>222</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于字母的ASCII码来说。网上已经罗列出来了，这是很容易就获取的，然后对于ctrl+字母的以及shift+字母的却有点小难了。&lt;/p&gt;
&lt;p&gt;最近在写脚本的时候，需要用到一些组合键，但是苦于不知道这些组合键对应的键盘码，就很尴尬&lt;/p&gt;
&lt;h2 id=&quot;CTRL-字母&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>select一直返回0的问题解决和总结</title>
    <link href="http://www.tangyilong.com/2019/04/13/select%E4%B8%80%E7%9B%B4%E8%BF%94%E5%9B%9E0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://www.tangyilong.com/2019/04/13/select一直返回0的问题解决和总结/</id>
    <published>2019-04-13T06:21:29.000Z</published>
    <updated>2019-04-13T06:23:31.902Z</updated>
    
    <content type="html"><![CDATA[<p>select是Linux/Unix环境下的高级网络I/O编程接口，它使我们能够进行基于I/O多路转接。I/0多路转接（multiplexing）的核心思想是：先构造一张有关描述符的列表，然后调用一个函数，直到这些描述符中的一个已经准备好进行I/O时，该函数才返回。在返回时，它告诉进程哪些描述符已准备好可以进行I/O操作。</p><p>在Linux中，我们可以使用select函数实现I/O端口的复用（多路转接），传递给select函数的参数会告诉内核：</p><ul><li><p>我们所关心的描述符，可能为文件描述符或网络套接字描述符。</p></li><li><p>对每个描述符，我们所关心的状态。(我们是要想从一个文件描述符中读或者写，还是关注一个描述符中是否出现异常)</p></li><li><p>我们愿意等待多长时间。(可以无限等待，等待固定的一段时间，或者完全不等待)</p></li></ul><p>从 select函数返回后，内核告诉我们一下信息：</p><ul><li><p>对我们的要求已经做好准备的描述符的个数</p></li><li><p>对于三种状态（读，写或异常）中的每一个，哪些描述符已经做好准备.</p><p>有了这些返回信息，我们可以调用合适的I/O函数(通常是 read 或 write)，并且这些函数不会再阻塞.</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout)</span></span>;</span><br><span class="line">返回值：做好准备的文件描述符的个数，超时为<span class="number">0</span>，错误为 <span class="number">-1.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span>      </span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">/*秒 */</span>  </span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">/*微秒 */</span>     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   首先我们先看一下最后一个参数。它指明我们要等待的时间，有如下三种情况：</p><ul><li><p>timeout == NULL  等待无限长的时间。等待可以被一个信号中断。当有一个描述符做好准备或者是捕获到一个信号时函数会返回。如果捕获到一个信号， select函数将返回 -1,并将变量 erro设为 EINTR。</p></li><li><p>timeout-&gt;tv_sec == 0 &amp;&amp;timeout-&gt;tv_usec == 0不等待，直接返回。加入描述符集的描述符都会被测试，并且返回满足要求的描述符的个数。这种方法通过轮询，无阻塞地获得了多个文件描述符状态。</p></li><li><p>timeout-&gt;tv_sec !=0 ||timeout-&gt;tv_usec!= 0 等待指定的时间。当有描述符符合条件或者超过超时时间的话，函数返回。在超时时间即将用完但又没有描述符合条件的话，返回 0。对于第一种情况，等待也会被信号所中断。</p><p>接着，我们看看中间的三个参数 readset, writset, exceptset,指向描述符集。这些参数指明了我们关心哪些描述符，和需要满足什么条件(可写，可读，异常)。一个文件描述集保存在 fd_set 类型中。fd_set类型变量每一位代表了一个描述符。我们也可以认为它只是一个由很多二进制位构成的数组。</p><p>理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。<br>（1）执行fd_set set;<br>(2) FD_ZERO(&amp;set);则set用位表示是0000,0000。<br>（3）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)<br>（4）若再加入fd＝2，fd=1,则set变为0001,0011<br>（5）执行select(6,&amp;set,0,0,0)阻塞等待<br>（6）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。</p><p>由于我是服务器端主程序，只关心是否收到对端发来的消息或通知事件，因此我只需要监听某个端口，采用select检查相应的套接字描述符是否有数据可读。调用FD_ZERO(&amp;readfds)将一个指定的fd_set变量（read_fds）所有位设置为0，调用FD_SET(m_server_sock, &amp;readfds)将read_fds变量的第m_server_sock个位置1。</p></li><li><p>如果select返回-1，说明有错误；如果为0， 说明超时了；否者说明我们关心的描述符准备好了。对于本文，我关心的是只有一个读文件描述符，当有数据可读时，内核(I/O)根据状态修改文件描述符集，select返回一个大于0的数,该数值表示已经准备好的描述符个数（本文是1，由于我只关心一个描述符）。准备好是什么意思呢？意思是，我关心的读集readfds中的其中一个描述符m_sock_fd描述符，有数据可读了，对其read操作不会阻塞。</p></li></ul><p>select调用是在while 循环loop里，而FD的设置却在while loop之外，即：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds<span class="comment">;</span></span><br><span class="line">FD_ZERO(&amp;readfds)<span class="comment">;</span></span><br><span class="line">FD_SET(m_server_sock, &amp;readfds)<span class="comment">;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> sockfd = <span class="number">-1</span><span class="comment">;</span></span><br><span class="line">  <span class="built_in">int</span> ret = <span class="keyword">select</span>(m_server_sock +<span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)<span class="comment">;</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是这个逻辑有问题呢？于是想到试试看：把FD_SET操作都放到select之前，即统一放到while Loop循环里。没想到，这么一改问题直接就解决了。</p><p>初步分析认为：</p><p>select返回后, 会把以前加入的但并无事件发生的fd从fd_set清除，因此需要重新调用select 前再次把关心的fd添加到FD_SET。否则就会出现本文的现象。</p><p>问题解决：每次调用select之前，调用FD_ZERO清空可读文件句柄集，并调用FD_SET把TCP套接字添加到该fd_set类型的集合中。<br>代码对比：</p><p><img src="/pic/select001.png" alt="img"></p><hr><p><a href="https://blog.csdn.net/acs713/article/details/17531827" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;select是Linux/Unix环境下的高级网络I/O编程接口，它使我们能够进行基于I/O多路转接。I/0多路转接（multiplexing）的核心思想是：先构造一张有关描述符的列表，然后调用一个函数，直到这些描述符中的一个已经准备好进行I/O时，该函数才返回。在返回时，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>串口清空输入输出缓存</title>
    <link href="http://www.tangyilong.com/2019/04/13/%E4%B8%B2%E5%8F%A3%E6%B8%85%E7%A9%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%93%E5%AD%98/"/>
    <id>http://www.tangyilong.com/2019/04/13/串口清空输入输出缓存/</id>
    <published>2019-04-13T06:20:29.000Z</published>
    <updated>2019-04-13T06:21:00.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux串口编程——清空输入输出缓存"><a href="#Linux串口编程——清空输入输出缓存" class="headerlink" title="Linux串口编程——清空输入输出缓存"></a>Linux串口编程——清空输入输出缓存</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们的工作中，串口是一种比较常用的数据传输方式。在某些应用场景下，当程序启动并打开串口后，我们不希望读出串口打开之前的输入缓存数据（即内核驱动已接收但是并未被应用层读出的数据），因此需要对输入缓存数据进行清空（刷清、丢弃）操作。下面以Linux系统上串口编程为例进行说明：</p><p>测试环境<br>硬件环境：PC<br>操作系统：Ubuntu 14.04虚拟机</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>方法一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"devpath"</span>, O_RDWR|O_NOCTTY);</span><br><span class="line">usleep(<span class="number">200000</span>);</span><br><span class="line">tcflush(fd, TCIFLUSH);    <span class="comment">//清空输入缓存</span></span><br><span class="line">tcflush(fd, TCOFLUSH);    <span class="comment">//清空输出缓存</span></span><br><span class="line">tcflush(fd, TCIOFLUSH);   <span class="comment">//清空输入输出缓存</span></span><br><span class="line">tcsetattr(m_ifd, TCSANOW, &amp;strctNewTermios)；</span><br></pre></td></tr></table></figure><p>方法二<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"devpath"</span>, O_RDWR|O_NOCTTY);</span><br><span class="line">usleep(<span class="number">200000</span>);</span><br><span class="line">ioctl(fd, TCFLSH, <span class="number">0</span>);    <span class="comment">//清空输入缓存</span></span><br><span class="line">ioctl(fd, TCFLSH, <span class="number">1</span>);    <span class="comment">//清空输出缓存</span></span><br><span class="line">ioctl(fd, TCFLSH, <span class="number">2</span>);    <span class="comment">//清空输入输出缓存</span></span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;strctNewTermios)；</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>必须在open和tcflush（或ioctl）操作间进行延时操作（具体时间未做验证），否则没有清空效果，原因未知，可能跟Linux内核版本有关<br>可自由选择只清空输入或只清空输出或两者都清空<br>tcflush和ioctl两种方法均有效，注意ioctl的第二个参数是TCFLSH</p><hr><p><a href="https://blog.csdn.net/zuoao123/article/details/81329875" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux串口编程——清空输入输出缓存&quot;&gt;&lt;a href=&quot;#Linux串口编程——清空输入输出缓存&quot; class=&quot;headerlink&quot; title=&quot;Linux串口编程——清空输入输出缓存&quot;&gt;&lt;/a&gt;Linux串口编程——清空输入输出缓存&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux编程之select</title>
    <link href="http://www.tangyilong.com/2019/04/13/linux%E7%BC%96%E7%A8%8B%E4%B9%8Bselect/"/>
    <id>http://www.tangyilong.com/2019/04/13/linux编程之select/</id>
    <published>2019-04-13T06:15:11.000Z</published>
    <updated>2019-04-13T06:16:27.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux编程之select"><a href="#Linux编程之select" class="headerlink" title="Linux编程之select"></a>Linux编程之select</h1><p>select系统调用的的用途是：在一段指定的时间内，监听用户感兴趣的文件描述符上可读、可写和异常等事件。</p><h2 id="select-机制的优势"><a href="#select-机制的优势" class="headerlink" title="select 机制的优势"></a>select 机制的优势</h2><p>为什么会出现select模型？</p><p>先看一下下面的这句代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iResult = recv(s, <span class="built_in">buffer</span>,<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>这是用来接收数据的，在默认的阻塞模式下的套接字里，recv会阻塞在那里，直到套接字连接上有数据可读，把数据读到buffer里后recv函数才会返回，不然就会一直阻塞在那里。在单线程的程序里出现这种情况会导致主线程（单线程程序里只有一个默认的主线程）被阻塞,这样整个程序被锁死在这里，如果永 远没数据发送过来，那么程序就会被永远锁死。这个问题可以用多线程解决，但是在有多个套接字连接的情况下，这不是一个好的选择，扩展性很差。</p><p>再看代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iResult = ioctlsocket(s, FIOBIO, (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ul);</span><br><span class="line">iResult = recv(s, <span class="built_in">buffer</span>,<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>这一次recv的调用不管套接字连接上有没有数据可以接收都会马上返回。原因就在于我们用ioctlsocket把套接字设置为非阻塞模式了。不过你跟踪一下就会发现，在没有数据的情况下，recv确实是马上返回了，但是也返回了一个错误：WSAEWOULDBLOCK，意思就是请求的操作没有成功完成。</p><p>看到这里很多人可能会说，那么就重复调用recv并检查返回值，直到成功为止，但是这样做效率很成问题，开销太大。</p><p>select模型的出现就是为了解决上述问题。<br>select模型的关键是使用一种有序的方式，对多个套接字进行统一管理与调度 。</p><p><img src="/pic/linux-select001.png" alt="img"></p><p>如上所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</p><p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><p>select流程伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    select(socket);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sockets = select();</span><br><span class="line">        <span class="keyword">for</span>(socket in sockets) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(can_read(socket)) </span><br><span class="line">            &#123;</span><br><span class="line">                read(socket, buffer);</span><br><span class="line">                process(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select相关API介绍与使用"><a href="#select相关API介绍与使用" class="headerlink" title="select相关API介绍与使用"></a>select相关API介绍与使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>maxfdp：被监听的文件描述符的总数，它比所有文件描述符集合中的文件描述符的最大值大1，因为文件描述符是从0开始计数的；</p><p>readfds、writefds、exceptset：分别指向可读、可写和异常等事件对应的描述符集合。</p><p>timeout:用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。timeout == NULL 表示等待无限长的时间</p><p>timeval结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span>      </span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">/*秒 */</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">/*微秒 */</span>   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值：超时返回0;失败返回-1；成功返回大于0的整数，这个整数表示就绪描述符的数目。</p><p>以下介绍与select函数相关的常见的几个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//一个 fd_set类型变量的所有位都设为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">//清除某个位时可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fd_set)</span></span>;   <span class="comment">//设置变量的某个位置位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">//测试某个位是否被置位</span></span><br></pre></td></tr></table></figure><p>select使用范例：<br>当声明了一个文件描述符集后，必须用FD_ZERO将所有位置零。之后将我们所感兴趣的描述符所对应的位置位，操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd_set rset;   </span><br><span class="line"><span class="keyword">int</span> fd;   </span><br><span class="line">FD_ZERO(&amp;rset);   </span><br><span class="line">FD_SET(fd, &amp;rset);   </span><br><span class="line">FD_SET(<span class="built_in">stdin</span>, &amp;rset);</span><br></pre></td></tr></table></figure><p>然后调用select函数，拥塞等待文件描述符事件的到来；如果超过设定的时间，则不再等待，继续往下执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(fd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>select返回后，用FD_ISSET测试给定位是否置位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(FD_ISSET(fd, &amp;rset)   </span><br><span class="line">&#123; </span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个最简单的select的使用例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set rd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rd);</span><br><span class="line">    FD_SET(<span class="number">0</span>,&amp;rd);</span><br><span class="line">    </span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    err = select(<span class="number">1</span>,&amp;rd,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;tv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(err == <span class="number">0</span>) <span class="comment">//超时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select time out!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(err == <span class="number">-1</span>)  <span class="comment">//失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail to select!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"data is available!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行该程序并且随便输入一些数据，程序就提示收到数据了。<br><img src="/pic/linux-select002.png" alt="img"></p><h2 id="深入理解select模型："><a href="#深入理解select模型：" class="headerlink" title="深入理解select模型："></a>深入理解select模型：</h2><p>理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。</p><p>（1）执行fd_set set; FD_ZERO(&amp;set); 则set用位表示是0000,0000。</p><p>（2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)</p><p>（3）若再加入fd＝2，fd=1,则set变为0001,0011</p><p>（4）执行select(6,&amp;set,0,0,0)阻塞等待</p><p>（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。</p><p>基于上面的讨论，可以轻松得出select模型的特点：</p><p>（1）可监控的文件描述符个数取决与sizeof(fd_set)的值。我这边服务器上sizeof(fd_set)＝512，每bit表示一个文件描述符，则我服务器上支持的最大文件描述符是512*8=4096。据说可调，另有说虽然可调，但调整上限受于编译内核时的变量值。</p><p>（2）将fd加入select监控集的同时，还要再使用一个数据结构array保存放到select监控集中的fd，一是用于再select返回后，array作为源数据和fd_set进行FD_ISSET判断。二是select返回后会把以前加入的但并无事件发生的fd清空，则每次开始select前都要重新从array取得fd逐一加入（FD_ZERO最先），扫描array的同时取得fd最大值maxfd，用于select的第一个参数。</p><p>（3）可见select模型必须在select前循环加fd，取maxfd，select返回后利用FD_ISSET判断是否有事件发生。</p><h2 id="用select处理带外数据"><a href="#用select处理带外数据" class="headerlink" title="用select处理带外数据"></a>用select处理带外数据</h2><p>网络程序中，select能处理的异常情况只有一种：socket上接收到带外数据。</p><p>什么是带外数据？</p><p>带外数据(out—of—band data)，有时也称为加速数据(expedited data)，<br>是指连接双方中的一方发生重要事情，想要迅速地通知对方。<br>这种通知在已经排队等待发送的任何“普通”(有时称为“带内”)数据之前发送。<br>带外数据设计为比普通数据有更高的优先级。<br>带外数据是映射到现有的连接中的，而不是在客户机和服务器间再用一个连接。</p><p>我们写的select程序经常都是用于接收普通数据的，当我们的服务器需要同时接收普通数据和带外数据，我们如何使用select进行处理二者呢？</p><p>下面给出一个小demo：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: ip address + port numbers\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ip: %s\n"</span>,ip);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"port: %d\n"</span>,port);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail to create listen socket!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = bind(listenfd,(struct sockaddr*)&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail to bind socket!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = listen(listenfd,<span class="number">5</span>); <span class="comment">//监听队列最大排队数设置为5</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail to listen socket!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span>  <span class="comment">//记录进行连接的客户端的地址</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(listenfd,(struct sockaddr*)&amp;client_address,&amp;client_addrlength);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail to accept!\n"</span>);</span><br><span class="line">        close(listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>]; <span class="comment">//数据接收缓冲区</span></span><br><span class="line">    fd_set read_fds;  <span class="comment">//读文件操作符</span></span><br><span class="line">    fd_set exception_fds; <span class="comment">//异常文件操作符</span></span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    FD_ZERO(&amp;exception_fds);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buff,<span class="number">0</span>,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="comment">/*每次调用select之前都要重新在read_fds和exception_fds中设置文件描述符connfd，因为事件发生以后，文件描述符集合将被内核修改*/</span></span><br><span class="line">        FD_SET(connfd,&amp;read_fds);</span><br><span class="line">        FD_SET(connfd,&amp;exception_fds);</span><br><span class="line">        </span><br><span class="line">        ret = select(connfd+<span class="number">1</span>,&amp;read_fds,<span class="literal">NULL</span>,&amp;exception_fds,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Fail to select!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(connfd, &amp;read_fds))</span><br><span class="line">        &#123;</span><br><span class="line">            ret = recv(connfd,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"get %d bytes of normal data: %s \n"</span>,ret,buff);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(FD_ISSET(connfd,&amp;exception_fds)) <span class="comment">//异常事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = recv(connfd,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>,MSG_OOB);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"get %d bytes of exception data: %s \n"</span>,ret,buff);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(connfd);</span><br><span class="line">    close(listenfd);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用select来解决socket中的多客户问题"><a href="#用select来解决socket中的多客户问题" class="headerlink" title="用select来解决socket中的多客户问题"></a>用select来解决socket中的多客户问题</h2><p>上面提到过，，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。在网络编程中，当涉及到多客户访问服务器的情况，我们首先想到的办法就是fork出多个进程来处理每个客户连接。现在，我们同样可以使用select来处理多客户问题，而不用fork。</p><p>服务器端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> server_sockfd, client_sockfd; </span><br><span class="line">    <span class="keyword">int</span> server_len, client_len; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> result; </span><br><span class="line">    fd_set readfds, testfds; </span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立服务器端socket </span></span><br><span class="line">    server_address.sin_family = AF_INET; </span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY); </span><br><span class="line">    server_address.sin_port = htons(<span class="number">8888</span>); </span><br><span class="line">    server_len = <span class="keyword">sizeof</span>(server_address); </span><br><span class="line">    bind(server_sockfd, (struct sockaddr *)&amp;server_address, server_len); </span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>); <span class="comment">//监听队列最多容纳5个 </span></span><br><span class="line">    FD_ZERO(&amp;readfds); </span><br><span class="line">    FD_SET(server_sockfd, &amp;readfds);<span class="comment">//将服务器端socket加入到集合中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> ch; </span><br><span class="line">        <span class="keyword">int</span> fd; </span><br><span class="line">        <span class="keyword">int</span> nread; </span><br><span class="line">        testfds = readfds;<span class="comment">//将需要监视的描述符集copy到select查询队列中，select会对其修改，所以一定要分开使用变量 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server waiting\n"</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*无限期阻塞，并测试文件描述符变动 */</span></span><br><span class="line">        result = select(FD_SETSIZE, &amp;testfds, (fd_set *)<span class="number">0</span>,(fd_set *)<span class="number">0</span>, (struct timeval *) <span class="number">0</span>); <span class="comment">//FD_SETSIZE：系统默认的最大文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(result &lt; <span class="number">1</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            perror(<span class="string">"server5"</span>); </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*扫描所有的文件描述符*/</span></span><br><span class="line">        <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; FD_SETSIZE; fd++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*找到相关文件描述符*/</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(fd,&amp;testfds)) </span><br><span class="line">            &#123; </span><br><span class="line">              <span class="comment">/*判断是否为服务器套接字，是则表示为客户请求连接。*/</span></span><br><span class="line">                <span class="keyword">if</span>(fd == server_sockfd) </span><br><span class="line">                &#123; </span><br><span class="line">                    client_len = <span class="keyword">sizeof</span>(client_address); </span><br><span class="line">                    client_sockfd = accept(server_sockfd, </span><br><span class="line">                    (struct sockaddr *)&amp;client_address, &amp;client_len); </span><br><span class="line">                    FD_SET(client_sockfd, &amp;readfds);<span class="comment">//将客户端socket加入到集合中</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"adding client on fd %d\n"</span>, client_sockfd); </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">/*客户端socket中有数据请求时*/</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123; </span><br><span class="line">                    ioctl(fd, FIONREAD, &amp;nread);<span class="comment">//取得数据量交给nread</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/*客户数据请求完毕，关闭套接字，从集合中清除相应描述符 */</span></span><br><span class="line">                    <span class="keyword">if</span>(nread == <span class="number">0</span>) </span><br><span class="line">                    &#123; </span><br><span class="line">                        close(fd); </span><br><span class="line">                        FD_CLR(fd, &amp;readfds); <span class="comment">//去掉关闭的fd</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"removing client on fd %d\n"</span>, fd); </span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">/*处理客户数据请求*/</span></span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123; </span><br><span class="line">                        read(fd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">                        sleep(<span class="number">5</span>); </span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"serving client on fd %d\n"</span>, fd); </span><br><span class="line">                        ch++; </span><br><span class="line">                        write(fd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> client_sockfd; </span><br><span class="line">    <span class="keyword">int</span> len; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span><span class="comment">//服务器端网络地址结构体 </span></span><br><span class="line">     <span class="keyword">int</span> result; </span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'A'</span>; </span><br><span class="line">    client_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立客户端socket </span></span><br><span class="line">    address.sin_family = AF_INET; </span><br><span class="line">    address.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">    address.sin_port = htons(<span class="number">8888</span>); </span><br><span class="line">    len = <span class="keyword">sizeof</span>(address); </span><br><span class="line">    result = connect(client_sockfd, (struct sockaddr *)&amp;address, len); </span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>) </span><br><span class="line">    &#123; </span><br><span class="line">         perror(<span class="string">"oops: client2"</span>); </span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//第一次读写</span></span><br><span class="line">    write(client_sockfd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">    read(client_sockfd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the first time: char from server = %c\n"</span>, ch); </span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二次读写</span></span><br><span class="line">    write(client_sockfd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">    read(client_sockfd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the second time: char from server = %c\n"</span>, ch);</span><br><span class="line">    </span><br><span class="line">    close(client_sockfd); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行流程：</p><p>客户端：启动-&gt;连接服务器-&gt;发送A-&gt;等待服务器回复-&gt;收到B-&gt;再发B给服务器-&gt;收到C-&gt;结束</p><p>服务器：启动-&gt;select-&gt;收到A-&gt;发A+1回去-&gt;收到B-&gt;发B+1过去</p><p>测试：我们先运行服务器，再运行客户端<br><img src="/pic/linux-select003.png" alt="img"></p><h2 id="select总结："><a href="#select总结：" class="headerlink" title="select总结："></a>select总结：</h2><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><p>1、单个进程可监视的fd数量被限制，即能监听端口的大小有限。一般来说这个数目和系统内存关系很大，具体数目可以cat/proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p><p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p><hr><p><a href="https://www.cnblogs.com/skyfsm/p/7079458.html" target="_blank" rel="noopener">转</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux编程之select&quot;&gt;&lt;a href=&quot;#Linux编程之select&quot; class=&quot;headerlink&quot; title=&quot;Linux编程之select&quot;&gt;&lt;/a&gt;Linux编程之select&lt;/h1&gt;&lt;p&gt;select系统调用的的用途是：在一段指定的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>select-poll-epoll的简介和区别</title>
    <link href="http://www.tangyilong.com/2019/04/13/select-poll-epoll%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.tangyilong.com/2019/04/13/select-poll-epoll的简介和区别/</id>
    <published>2019-04-13T06:14:21.000Z</published>
    <updated>2019-04-13T06:14:50.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h1><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><h3 id="select："><a href="#select：" class="headerlink" title="select："></a><strong>select：</strong></h3><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p><p>​    一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p><p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p><p>   当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p><h3 id="poll："><a href="#poll：" class="headerlink" title="poll："></a><strong>poll：</strong></h3><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</p><p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                   </p><p>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll:"></a><strong>epoll:</strong></h3><p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p><strong>epoll为什么要有EPOLLET触发模式？</strong></p><p>如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！<strong>这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符</strong></p><p><strong>epoll的优点：</strong></p><p>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><p>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p><h3 id="select、poll、epoll-区别总结："><a href="#select、poll、epoll-区别总结：" class="headerlink" title="select、poll、epoll 区别总结："></a><strong>select、poll、epoll 区别总结：</strong></h3><p>1、支持一个进程所能打开的最大连接数</p><p>select</p><p>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p><p>poll</p><p>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</p><p>epoll</p><p>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</p><p>2、FD剧增后带来的IO效率问题</p><p>select</p><p>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p><p>poll</p><p>同上</p><p>epoll</p><p>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p><p>3、 消息传递方式</p><p>select</p><p>内核需要将消息传递到用户空间，都需要内核拷贝动作</p><p>poll</p><p>同上</p><p>epoll</p><p>epoll通过内核和用户空间共享一块内存来实现的。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</strong></p><p><strong>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></p><p><strong>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</strong></p><hr><p><a href="https://www.cnblogs.com/zhaodahai/p/6831456.html" target="_blank" rel="noopener">转</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;select、poll、epoll简介&quot;&gt;&lt;a href=&quot;#select、poll、epoll简介&quot; class=&quot;headerlink&quot; title=&quot;select、poll、epoll简介&quot;&gt;&lt;/a&gt;select、poll、epoll简介&lt;/h1&gt;&lt;p&gt;ep
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Struct tm</title>
    <link href="http://www.tangyilong.com/2019/04/13/Struct-tm/"/>
    <id>http://www.tangyilong.com/2019/04/13/Struct-tm/</id>
    <published>2019-04-13T06:13:28.000Z</published>
    <updated>2019-04-13T06:14:00.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间操作（struct-tm、time-t）求指定日期-前n天的日期"><a href="#时间操作（struct-tm、time-t）求指定日期-前n天的日期" class="headerlink" title="时间操作（struct tm、time_t）求指定日期 前n天的日期"></a>时间操作（struct tm、time_t）求指定日期 前n天的日期</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TM_DEFINED</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> tm_sec; <span class="comment">/* 秒–取值区间为[0,59] */</span></span><br><span class="line"><span class="keyword">int</span> tm_min; <span class="comment">/* 分 - 取值区间为[0,59] */</span></span><br><span class="line"><span class="keyword">int</span> tm_hour; <span class="comment">/* 时 - 取值区间为[0,23] */</span></span><br><span class="line"><span class="keyword">int</span> tm_mday; <span class="comment">/* 一个月中的日期 - 取值区间为[1,31] */</span></span><br><span class="line"><span class="keyword">int</span> tm_mon; <span class="comment">/* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */</span></span><br><span class="line"><span class="keyword">int</span> tm_year; <span class="comment">/* 年份，其值从1900开始 */</span></span><br><span class="line"><span class="keyword">int</span> tm_wday; <span class="comment">/* 星期–取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> __int64 <span class="keyword">__time64_t</span>;     <span class="comment">/* 64-bit time value */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__time64_t</span> <span class="keyword">time_t</span>;      <span class="comment">/* time value */</span></span><br><span class="line"><span class="comment">/* time_t 是一种时间类型，一般用来存放格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数 */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNDaysGapDate</span><span class="params">(<span class="keyword">int</span> iNowDate, <span class="keyword">int</span> iNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">ptm</span>;</span></span><br><span class="line">    ptm.tm_year = iNowDate / <span class="number">10000</span> % <span class="number">10000</span> - <span class="number">1900</span>;</span><br><span class="line">    ptm.tm_mon  = iNowDate / <span class="number">100</span> % <span class="number">100</span> - <span class="number">1</span>;</span><br><span class="line">    ptm.tm_mday = iNowDate % <span class="number">100</span>;</span><br><span class="line">    ptm.tm_hour = <span class="number">0</span>;</span><br><span class="line">    ptm.tm_min  = <span class="number">0</span>;</span><br><span class="line">    ptm.tm_sec  = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">time_t</span> timep;</span><br><span class="line">    timep = mktime(&amp;ptm); <span class="comment">//mktime把struct tm类型转换成time_t</span></span><br><span class="line">    timep += iNum * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line"> </span><br><span class="line">    ptm = *localtime(&amp;timep); <span class="comment">//localtime把time_t类型转换成struct tm</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (ptm.tm_year + <span class="number">1900</span>) * <span class="number">10000</span> + (ptm.tm_mon + <span class="number">1</span>) * <span class="number">100</span> + ptm.tm_mday;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iDate = <span class="number">20170120</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> iPre30Date = GetNDaysGapDate(iDate, (<span class="number">-1</span>)*n); <span class="comment">//获取 iDate 30天前的日期</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//距9：30的分钟数可以表示成：</span></span><br><span class="line">    min =  ptm.tm_hour*<span class="number">60</span> + ptm.tm_min - （<span class="number">9</span>*<span class="number">60</span> + <span class="number">30</span>）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// long 型可直接赋值给 time_t 对象</span></span><br><span class="line"><span class="keyword">long</span> lTime = <span class="number">1513318455</span>;</span><br><span class="line"><span class="keyword">time_t</span> timestamp = <span class="number">1513318455</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">ptm</span>;</span></span><br><span class="line">ptm = *localtime(&amp;timestamp);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取当前时间戳</span></span><br><span class="line"><span class="keyword">time_t</span> timep;</span><br><span class="line">time(&amp;timep);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; timep &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/SZxiaochun/p/6377373.html" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间操作（struct-tm、time-t）求指定日期-前n天的日期&quot;&gt;&lt;a href=&quot;#时间操作（struct-tm、time-t）求指定日期-前n天的日期&quot; class=&quot;headerlink&quot; title=&quot;时间操作（struct tm、time_t）求指
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谷歌浏览器安装插件</title>
    <link href="http://www.tangyilong.com/2019/04/13/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
    <id>http://www.tangyilong.com/2019/04/13/谷歌浏览器安装插件/</id>
    <published>2019-04-13T06:09:23.000Z</published>
    <updated>2019-04-13T06:13:06.100Z</updated>
    
    <content type="html"><![CDATA[<p>忘记了是由于什么安全的原因，现在chrome无法直接安装插件了</p><p><img src="/pic/google001.png" alt="img1"></p><p>首先下载浏览器插件crx文件，鼠标右键修改文件名后缀由crx改为rar</p><p>解压成文件夹，打开浏览器，依次点击浏览器的右上角，更多工具，扩展程序，打开右上角的开发者模式开关。</p><p><img src="/pic/google002.png" alt="img2"></p><p>点击加载已解压的扩展程序，选择之前解压的扩展程序目录，点击确认，可以看到对应的扩展程序已经安装好了。</p><p><img src="/pic/google003.png" alt="img3"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;忘记了是由于什么安全的原因，现在chrome无法直接安装插件了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/pic/google001.png&quot; alt=&quot;img1&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先下载浏览器插件crx文件，鼠标右键修改文件名后缀由crx改为rar&lt;/p&gt;
&lt;p&gt;解压成文件夹
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>makefile &#39;@&#39; &#39;$&#39; &#39;1828&#39; &#39;-&#39; &#39;-n &#39; &#39; $^&#39;使用小结</title>
    <link href="http://www.tangyilong.com/2019/04/13/makefile-1828-n-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.tangyilong.com/2019/04/13/makefile-1828-n-使用小结/</id>
    <published>2019-04-13T06:07:04.000Z</published>
    <updated>2019-04-13T06:08:43.085Z</updated>
    
    <content type="html"><![CDATA[<p>编译代码时，会进程接触makefile，会涉及到一些符号，由于不明白有些意思经常出现问题，在此归纳一下。</p><p>‘@’  符号的使用<br>   通常makefile会将其执行的命令行在执行前输出到屏幕上。如果将‘@’添加到命令行前，这个命令将不被make回显出来。<br>   例如：@echo –compiling module—-;  // 屏幕输出 –compiling module—-<br>         echo –compiling module—-;  // 没有@ 屏幕输出echo –compiling module—-    </p><p>‘ - ‘ 符号的使用<br>   通常删除，创建文件如果碰到文件不存在或者已经创建，那么希望忽略掉这个错误，继续执行，就可以在命令前面添加 -，<br>   -rm dir；<br>   -mkdir aaadir；</p><p><code>$</code>  符号的使用<br>   美元符号<code>$</code>，主要扩展打开makefile中定义的变量</p><p><code>$$</code>  符号的使用<br>  <code>$$</code> 符号主要扩展打开makefile中定义的shell变量</p><p>例如：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> $(subdirs); <span class="keyword">do</span> \</span><br><span class="line">    @<span class="built_in">echo</span> compiling $$<span class="built_in">dir</span>; \</span><br><span class="line">    $(MAKE) -C</span><br><span class="line">    <span class="built_in">dir</span>||<span class="keyword">exit</span>"</span><br><span class="line">    <span class="built_in">dir</span>||<span class="keyword">exit</span>"</span><br><span class="line">    ?"; \</span><br><span class="line"> done</span><br></pre></td></tr></table></figure></p><p>以上subdir属于makefile中定义的变量，而dir则属于makefile中定义的shell变量，所有使用是使用 ‘ ​$$ ’ 而不是 ‘ $ ‘。</p><p>如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。 </p><p>而make参数“-s”或“–slient”则是全面禁止命令的显示。</p><p>补充说明自动化变量：<br><code>$@</code> 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”​$@”就是匹配于目标中模式定义的集合。</p><p><code>$%</code> 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p><p><code>$&lt;</code>  依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p><p><code>$?</code>  所有比目标新的依赖目标的集合。以空格分隔。</p><p><code>$^</code>   所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份</p><hr><p>原文：<a href="https://blog.csdn.net/kehyuanyu/article/details/21454789" target="_blank" rel="noopener">https://blog.csdn.net/kehyuanyu/article/details/21454789</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编译代码时，会进程接触makefile，会涉及到一些符号，由于不明白有些意思经常出现问题，在此归纳一下。&lt;/p&gt;
&lt;p&gt;‘@’  符号的使用&lt;br&gt;   通常makefile会将其执行的命令行在执行前输出到屏幕上。如果将‘@’添加到命令行前，这个命令将不被make回显出来。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo不显示图片,不需要插件,超简单</title>
    <link href="http://www.tangyilong.com/2019/02/20/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87-%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8F%92%E4%BB%B6-%E8%B6%85%E7%AE%80%E5%8D%95/"/>
    <id>http://www.tangyilong.com/2019/02/20/Hexo插入图片-不需要插件-超简单/</id>
    <published>2019-02-20T13:02:42.000Z</published>
    <updated>2019-02-20T13:06:34.149Z</updated>
    
    <content type="html"><![CDATA[<p>当使用Hexo创建文件搭建博客的时候，就会遇到图片插图，以及插入的图片无法显示的问题，差不多网上大多数的解决方案就是第一种（但我本人没使用这个方案）</p><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>1.找到<code>Hexo</code>下的<code>_config.yml</code>里的<code>post_asset_folder</code>，把这个选项从<code>false</code>改成<code>true</code></p><p>2.在<code>Hexo</code>目录下打开Git Brsh，执行一个下载上传图片插件的命令<code>npm install hexo-asset-image --save</code>。</p><p>3.继续在Git Brsh下利用<code>hexo n &quot;xxxx&quot;</code>来生成md的文件（” “里的内容填自己的文件名），这时就会在同级的目录下生成一个同名的文件夹。</p><p>4.在<code>.md</code>的文件中要插入图片时，先要把所要插入的图片放在生成的同名文件夹下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">你想输入的替代文字</span>](<span class="link">xxxx/图片名.jpg</span>)</span><br></pre></td></tr></table></figure><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>上面的方案是一种解决方法，那么接下来我自己找到解决方案分享给大家，个人感觉更加简单方便。</p><p>在Hexo的目录source中创建一个图片文件夹，例如pic</p><p><img src="/pic/Hexo-pic001.png" alt="img1"></p><p>把你要插入的图片文件放到该目录下面，在你的文章中正常使用markdown的语法插入图片即可</p><p>例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">/pic/xxx.png</span>)</span><br></pre></td></tr></table></figure><p>到此你就完成了插图，并且图片在你的博客上面也会正常显示！</p><p>记住在pic前面有一个<code>/</code>,表示根目录的意思，因为对于hexo来说它的资源文件的根目录就是source,当然你也可以修改_config.yml改变这个配置</p><p><img src="/pic/Hexo-pic002.png" alt="img2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当使用Hexo创建文件搭建博客的时候，就会遇到图片插图，以及插入的图片无法显示的问题，差不多网上大多数的解决方案就是第一种（但我本人没使用这个方案）&lt;/p&gt;
&lt;h2 id=&quot;第一种&quot;&gt;&lt;a href=&quot;#第一种&quot; class=&quot;headerlink&quot; title=&quot;第一种&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim快速查找</title>
    <link href="http://www.tangyilong.com/2019/02/20/vim%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE/"/>
    <id>http://www.tangyilong.com/2019/02/20/vim快速查找/</id>
    <published>2019-02-20T11:40:46.000Z</published>
    <updated>2019-02-20T11:41:10.304Z</updated>
    
    <content type="html"><![CDATA[<p> vim有强大的字符串查找功能。</p><p>   我们通常在vim下要查找字符串的时候， 都是输入 / 或者 ？  加 需要查找的字符串来进行搜索，比如想搜索 super 这个单词， 可以输入  /super  或者  ？super，  两者的区别是前者是从上往下搜索，后者是从下往上搜索。<br>   那么如果我想搜索本行中某个单词，并且这个单词很长的时候， 手动输入该字符串是非常麻烦的， 当然可以使用模糊匹配(如* 或 ？)来做， 不过这样可能搜得到很多其他的，不完全匹配的字符串。<br>   可以使用如下方式来实现快速查找：</p><p>1， 最快的方式是让光标停留在想要查找的单词的任意一个字母上面， 然后输入<code>Shift + *</code>，即可快速选中该单词，并且可以通过<code>n</code>或<code>N</code>进行上一个或下一个的匹配。</p><p>2， 让光标停留在单词的第一个字母上， 然后输入yw拷贝该单词， 然后输入 / (Ctrl + R) 0 （即 /“0），回车， 就查找到了第一个匹配的单词， 并且可以通过<code>n</code>或<code>N</code>进行上一个或下一个的匹配。</p><p>解释一下：</p><p>Ctrl + r 是指使用寄存器 ， 你会发现先输入/ ， 然后输入 Ctrl + r , 会立刻变为 “ ， 即寄存器的前缀， 然后 “0 就可以理解了吧？ 合起来就是 /“0， 就是查找刚才复制的那个单词，</p><p>3， 还有一种方式， 和第二种方式差不多，不过是将单词拷贝到系统剪贴板， 然后再从系统剪贴板拿出来。 即选中需要查找的单词， 然后输入 “”+y， 然后输入/（Shfit + Ctrl + v）， 就查找到了第一个匹配的单词， 并且可以通过<code>n</code>或<code>N</code>进行上一个或下一个的匹配。</p><p>以上， 最方便的还是第一种， 高效快捷， 值得推荐！！</p><hr><p>原文：<a href="https://blog.csdn.net/ballack_linux/article/details/53187283" target="_blank" rel="noopener">https://blog.csdn.net/ballack_linux/article/details/53187283</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; vim有强大的字符串查找功能。&lt;/p&gt;
&lt;p&gt;   我们通常在vim下要查找字符串的时候， 都是输入 / 或者 ？  加 需要查找的字符串来进行搜索，比如想搜索 super 这个单词， 可以输入  /super  或者  ？super，  两者的区别是前者是从上往下搜索，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>container_of图文分析</title>
    <link href="http://www.tangyilong.com/2019/02/20/container-of%E5%9B%BE%E6%96%87%E5%88%86%E6%9E%90/"/>
    <id>http://www.tangyilong.com/2019/02/20/container-of图文分析/</id>
    <published>2019-02-20T11:39:45.000Z</published>
    <updated>2019-02-20T12:21:16.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="container-of-函数分析"><a href="#container-of-函数分析" class="headerlink" title="container of()函数分析"></a>container of()函数分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Container_of在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲<strong>就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。</strong></p><p>Container_of的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;    \</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);    \</span><br><span class="line">(type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure><p><img src="/pic/container_of.png" alt="img"></p><p> 其实，原理很简单：  已知结构体type的成员member的地址ptr，求解结构体type的起始地址。</p><p>​                  type的起始地址 = ptr - size      (这里需要都转换为char *，因为它为单位字节)。</p><p>具体来说分为两步：</p><p>   第一步，首先定义一个临时的数据类型（通过typeof( ((type *)0)-&gt;member )获得）与ptr相同的指针变量__mptr，然后用它来保存ptr的值。<br>   第二步，用(char *)__mptr减去member在结构体中的偏移量，得到的值就是整个结构体变量的首地址（整个宏的返回值就是这个首地址）。</p><p>==把mptr指针强转成(char *)是因为，char指针减法只移一个字节，如果这样才可能得出准确的地址，否则，改为int类型，在减1就移动4个就乱了。==</p><h2 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h2><p>其中的语法难点就是如何得出成员相对结构体的偏移量？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-2.6.38.8/include/linux/compiler-gcc4.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __compiler_offsetof(a,b) __builtin_offsetof(a,b)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* linux-2.6.38.8/include/linux/stddef.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> offsetof</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __compiler_offsetof</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> fl;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offsetof(struct test_struct, num) = %d\n"</span>, </span><br><span class="line">offsetof(struct test_struct, num));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offsetof(struct test_struct,  ch) = %d\n"</span>, </span><br><span class="line">offsetof(struct test_struct, ch));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offsetof(struct test_struct,  fl) = %d\n"</span>, </span><br><span class="line">offsetof(struct test_struct, fl));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明，__builtin_offsetof(a,b)是GCC的内置函数，可认为它的实现与((size_t) &amp;((TYPE *)0)-&gt;MEMBER)这段代码是一致的。</p><p>​    例子输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">offsetof(struct test_struct, num) = 0</span><br><span class="line">offsetof(struct test_struct,  ch) = 4</span><br><span class="line">offsetof(struct test_struct,  fl) = 8</span><br></pre></td></tr></table></figure><p>其中代码难以理解的地方就是它灵活地运用了0地址。如果觉得&amp;( (struct test_struct <em>)0 )-&gt;ch这样的代码不好理解，那么我们可以假设在0地址分配了一个结构体变量struct test_struct a，然后定义结构体指针变量p并指向a（struct test_struct </em>p = &amp;a），如此我们就可以通过&amp;p-&gt;ch获得成员ch的地址。由于a的首地址为0x0，所以成员ch的首地址为0x4</p><p><img src="/pic/container_of002.gif" alt="img2"></p><p>最后通过强制类型转换（size_t）把一个地址值转换为一个整数</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   container_of（ptr, type,member）函数的实现包括两部分：</p><p>​    1、判断ptr 与 member 是否为同意类型</p><p>​    2、计算size大小，结构体的起始地址 = (type <em>)((char </em>)ptr - size)   (注：强转为该结构体指针)</p><p>   现在我们知道container_of()的作用就是通过一个结构变量中一个成员的地址找到这个结构体变量的首地址。</p><p>   container_of(ptr,type,member),这里面有ptr,type,member分别代表指针、类型、成员。</p><hr><p><a href="https://blog.csdn.net/npy_lp/article/details/7010752" target="_blank" rel="noopener">https://blog.csdn.net/npy_lp/article/details/7010752</a></p><p><a href="https://blog.csdn.net/s2603898260/article/details/79371024" target="_blank" rel="noopener">https://blog.csdn.net/s2603898260/article/details/79371024</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;container-of-函数分析&quot;&gt;&lt;a href=&quot;#container-of-函数分析&quot; class=&quot;headerlink&quot; title=&quot;container of()函数分析&quot;&gt;&lt;/a&gt;container of()函数分析&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>同步内核缓冲区 sync,fsync和fdatasync函数</title>
    <link href="http://www.tangyilong.com/2019/02/20/%E5%90%8C%E6%AD%A5%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2%E5%8C%BA-sync-fsync%E5%92%8Cfdatasync%E5%87%BD%E6%95%B0/"/>
    <id>http://www.tangyilong.com/2019/02/20/同步内核缓冲区-sync-fsync和fdatasync函数/</id>
    <published>2019-02-20T11:37:58.000Z</published>
    <updated>2019-02-20T12:24:01.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步内核缓冲区"><a href="#同步内核缓冲区" class="headerlink" title="同步内核缓冲区"></a>同步内核缓冲区</h2><h3 id="1-缓冲区简单介绍"><a href="#1-缓冲区简单介绍" class="headerlink" title="1.缓冲区简单介绍"></a>1.缓冲区简单介绍</h3><p>   人生三大错觉之中的一个：在调用函数write()时，我们觉得该函数一旦返回，数据便已经写到了文件里.可是这样的概念仅仅是宏观上的.实际上。操作系统实现某些文件I/O时（如磁盘文件）。为了保证I/O的效率，在内核一般会用到一片专门的区域（内存或独立的I/O地址空间）作为I/O数据缓冲区.它用在输入输出设备和CPU之间，用来缓存数据，使得低速的设备和快速的CPU可以协调工作避免低速的输入输出设备长时间占用CPU。降低系统调用，提高了CPU的工作效率.</p><h3 id="2-不同步的write"><a href="#2-不同步的write" class="headerlink" title="2.不同步的write()"></a>2.不同步的write()</h3><p>  传统的UNIX或LINUX系统在设计时使用了内核缓冲区，设有快速缓冲区或页面快速缓冲区，大多数磁盘I/O都通过缓冲区进行.==当将数据写入文件时，内核通常先将该数据拷贝到当中一个缓冲区。假设该缓冲区尚未写满。则并不将其排入输出队列，而是等待其写满或者当内核须要重用该缓冲区以便存放其它磁盘块数据时，再将该缓冲区排入输出队列；然后待其到达队首时。才进行实际的I/O操作.这样的输出方式被称为延迟写.==<br>   当调用write()函数写出数据时，数据一旦写到该缓冲区（关键：仅仅是写到缓冲区），函数便马上返回.此时写出的数据能够用read()读回，也能够被其它进程读到，可是并不意味着它们已经被写到了外部永久存储介质上。即使调用close()关闭文件后也可能如此. 由于缓冲区的数据可能还在等待输出.<br>   因此。从数据被实际写到磁盘的角度来看。用write()写出的文件数据与外部存储设备并非全然同步的.不同步的时间间隔非常短，一般仅仅有几秒或十几秒，详细取决于写出的数据量和I/O数据缓冲区的状态.虽然不同步的时间间隔非常短，可是假设在此期间发生掉电或者系统崩溃，则会导致所写数据来不及写至磁盘而丢失的情况.<br>   ==注意：内核将缓冲区中的数据“写”到标准输入磁盘文件里，这里“写”不是将缓冲区中的数据移动到磁盘文件里，而是复制到磁盘文件里，也就说此时磁盘文件里还保留一份缓冲区内容的备份.==</p><p>  如图1所看到的.做出这一设计也是有其道理的。假设写出到磁盘文件上，磁盘坏了或满了等等，总之就是无法将数据送出，假如没备份。那数据不是丢掉了.也就是说内核会等待写入磁盘动作完毕后，才放心的将备份的数据删除掉.在下文讨论的三个函数中也将涉及到这个过程.</p><p> <img src="/pic/fysnc.png" alt="img"></p><p>​                     图1 数据传入过程示意图</p><p>   为了保证磁盘上实际文件系统与缓冲区快速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数.</p><h3 id="3-sync函数"><a href="#3-sync函数" class="headerlink" title="3.sync函数"></a>3.sync函数</h3><p>头文件：#include&lt;unistd.h&gt;<br>定义函数：void sync(void)；<br>返回值：若成功则返回0，若出错则返回-1。同一时候设置errno以指明错误.<br>函数说明：<br>   sync负责将系统缓冲区的数据“写入”磁盘。以确保数据的一致性和同步性.==注意：sync函数仅仅是将全部改动过的块缓冲区排入写队列，然后就返回。他并不等待实际I/O操作结束.所以不要觉得调用了sync函数，就觉得数据已安全的送到磁盘文件上，有可能会出现故障，可是sync函数是无法得知的.==<br>   系统守候进程一般每隔一段时间调用一次sync函数，确保定期刷新内核的块缓存.UNIX系统中，系统守候进程update会周期性地（一般每一个30秒）调用sync函数.命令sync(1)也调用sync函数.</p><h3 id="4-fsync函数"><a href="#4-fsync函数" class="headerlink" title="4.fsync函数"></a>4.fsync函数</h3><p>头文件：#include&lt;unistd.h&gt;<br>定义函数：int fsync(int filedes)；<br>返回值：若成功则返回0。若出错则返回-1。同一时候设置errno以指明错误.<br>函数说明：<br>   与sync函数不同，fsync函数仅仅对由文件描符filedes指定的单一文件起作用，强制与描写叙述字fildes相连文件的全部改动过的数据（包含核内I/O缓冲区中的数据）传送到外部永久介质。即刷新fildes给出的文件的全部信息。而且等待写磁盘操作结束，然后返回.调用<code>fsync()</code>的进程将堵塞直到设备报告传送已经完毕.这个fsync就安全点了.<br>   一个程序在写出数据之后。假设继续进行兴许处理之前要求确保所写数据已写到磁盘，则应当调用fsync().比如，==<strong>数据库应用一般会在调用write()保存关键交易数据的同一时候也调用<code>fsync()</code>.这样更能保证数据的安全可靠.</strong>==</p><h3 id="5-fdatasync函数"><a href="#5-fdatasync函数" class="headerlink" title="5.fdatasync函数"></a>5.fdatasync函数</h3><p>头文件：#include&lt;unistd.h&gt;<br>定义函数：int fdatasync(int filedes)；<br>返回值：若成功则返回0。若出错则返回-1，同一时候设置errno以指明错误.<br>函数说明：<br>   fdatasync函数类似于fsync函数，<strong>但它仅仅影响文件数据部分。强制传送用户已写出的数据至物理存储设备。不包含文件本身的特征数据.这样能够适当降低文件刷新时的数据传送量</strong>.而除数据外，fdatasync还会同步更新文件的属性.</p><h3 id="6-错误代码"><a href="#6-错误代码" class="headerlink" title="6.错误代码"></a>6.错误代码</h3><p>EBADF：文件描写叙述符无效。或文件已关闭.<br>EIO ： 读写的过程中错误发生 .<br>EROFS， EINVAL：文件所在的文件系统不支持同步.</p><h3 id="7-fflush-与fsync-的联系"><a href="#7-fflush-与fsync-的联系" class="headerlink" title="7.fflush()与fsync()的联系"></a>7.fflush()与fsync()的联系</h3><p>   内核I/O缓冲区是由操作系统管理的空间，而流缓冲区是由标准I/O库管理的用户空间.fflush()仅仅刷新位于用户空间中的流缓冲区.fflush()返回后。仅仅保证数据已不在流缓冲区中，并不保证它们一定被写到了磁盘.此时。从流缓冲区刷新的数据可能已被写至磁盘。也可能还待在内核I/O缓冲区中.要确保流I/O写出的数据已写至磁盘，那么在调用fflush()后还应当调用fsync().</p><h3 id="8-综述"><a href="#8-综述" class="headerlink" title="8.综述"></a>8.综述</h3><p>   尽管延迟写降低了磁盘读写次数，可是却降低了文件内容的更新速度，使得欲写到文件里数据在一段时间内并没有写到磁盘上。当系统发生问题时，这样的延迟可能造成文件更新内容的丢失。</p><hr><p><a href="https://www.cnblogs.com/bhlsheji/p/5222271.html" target="_blank" rel="noopener">https://www.cnblogs.com/bhlsheji/p/5222271.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步内核缓冲区&quot;&gt;&lt;a href=&quot;#同步内核缓冲区&quot; class=&quot;headerlink&quot; title=&quot;同步内核缓冲区&quot;&gt;&lt;/a&gt;同步内核缓冲区&lt;/h2&gt;&lt;h3 id=&quot;1-缓冲区简单介绍&quot;&gt;&lt;a href=&quot;#1-缓冲区简单介绍&quot; class=&quot;header
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算术移位逻辑移位</title>
    <link href="http://www.tangyilong.com/2019/02/20/%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D/"/>
    <id>http://www.tangyilong.com/2019/02/20/算术移位逻辑移位/</id>
    <published>2019-02-20T11:31:46.000Z</published>
    <updated>2019-02-20T12:24:26.714Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     i = i&lt;&lt;<span class="number">3</span>;<span class="comment">//输出结果i = 64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问：上面的变量i是采用逻辑移位还是算术移位呢？</p><p>逻辑移位，简单理解就是物理上按位进行的左右移动，两头用0进行补充，不关心数值的符号问题。</p><p>算术移位，同样也是物理上按位进行的左右移动，两头用0进行补充，但必须确保符号位不改变。</p><ul><li><strong>逻辑移位</strong></li></ul><p>逻辑移位是指逻辑左移和逻辑右移，移出的空位都用0来补。</p><p>此组指令有：逻辑左移SHL(ShiftLogical Left)和逻辑右移SHR(ShiftLogical Right)。它们的指令格式如下：SHL/SHR Reg/Mem, CL/Imm，受影响的标志位：CF、OF、PF、SF和ZF(AF无定义)。逻辑左移/右移指令只有它们的移位方向不同，移位后空出的位都补<strong>0</strong></p><p>（1）逻辑左移SHL<br><img src="/pic/算术移位003.png" alt="img1"><br>（2）逻辑右移SHR<br><img src="/pic/算术移位004.png" alt="img1"></p><ul><li><strong>算术移位</strong></li></ul><p>算术移位 就需要分有符号型值和无符号型值<br>==对于无符号型值，算术移位等同于逻辑移位==<br>==而对于有符号型值 ，算术左移等同于逻辑左移，算术右移补的是符号位，正数补0，负数补1。==</p><p>算术移位指令有：算术左移SAL(ShiftAlgebraic Left)和算术右移SAR(ShiftAlgebraic Right)。它们的指令格式如下：SAL/SAR Reg/Mem, CL/Imm，受影响的标志位：CF、OF、PF、SF和ZF(AF无定义)。算术移位指令的功能描述如下：</p><p>（1）算术左移SAL把目的操作数的低位向高位移，空出的低位补0；<br><img src="/pic/算术移位001.png" alt="img1"><br>（2）算术右移SAR把目的操作数的高位向低位移，空出的高位用最高位(符号位)填补。<br><img src="/pic/算术移位002.png" alt="img1"></p><ul><li><strong>那么C编译器中采用的是那种移位方式呢？</strong></li></ul><p>在汇编指令中，shl和shr表示逻辑左移和逻辑右移，sal和sar表示算术左移和算术右移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">65</span>;  <span class="comment">//有符号整型 0100 0001</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">65</span>; <span class="comment">//无符号整型 0100 0001</span></span><br><span class="line">    a &lt;&lt;= <span class="number">1</span>; <span class="comment">//1000 0010  130</span></span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>; <span class="comment">//0010 0000  32</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="number">127</span>; <span class="comment">//0111 1111</span></span><br><span class="line">    c &lt;&lt;= <span class="number">3</span>; <span class="comment">//1111 1000 -8</span></span><br><span class="line">    <span class="keyword">char</span> d = <span class="number">127</span>; <span class="comment">//0111 1111</span></span><br><span class="line">    d &gt;&gt;= <span class="number">3</span>; <span class="comment">//0000 1111 15</span></span><br><span class="line">    <span class="keyword">char</span> e = <span class="number">-8</span>; <span class="comment">//内存以补码为1111 1000存储  源码为1000 1000 反码为1111 0111</span></span><br><span class="line">    e &gt;&gt;= <span class="number">3</span>; <span class="comment">//-1  补码1111 1111 源码 1000 0001 反码1111 1110</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a,b);<span class="comment">//130 32</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,c,d);<span class="comment">//-8  15</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,e);  <span class="comment">//-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来看一看这一段代码的汇编代码 </p><p><img src="/pic/算术移位005.png" alt="img1"></p><p>只看汇编代码进行分析：</p><p>汇编代码的第四行和第七行以及第十一行是对a，b，c三个变量进行的移位操作，即有符号型变量左移和无符号型右移C编译器都处理为逻辑移位，用的指令是shl和shr，移出的空位用0来补。</p><p>而对于汇编代码的第十五行和第十九行是对d，e两个变量进行的移位操作，即正数和负数的有符号型变量的右移，C编译器处理为算术移位，用的指令是sar，移出的空位，正数补0，负数补1。</p><p>对于C编译器的逻辑移位和算术移位的总结<br>我所使用的C编译器是VS2008，基于该编译器采用对无符号型int，short，char进行移位时，编译器默认生成的汇编指令是逻辑左移和逻辑右移。<br>而对于有符号的int，short，char进行移位时，左移还是逻辑左移，但右移时生成的汇编指令是算术右移。</p><hr><p>参考：</p><p><a href="https://blog.csdn.net/xzg_2017/article/details/80158215" target="_blank" rel="noopener">https://blog.csdn.net/xzg_2017/article/details/80158215</a></p><p><a href="https://www.cnblogs.com/hpcpp/p/6291710.html" target="_blank" rel="noopener">https://www.cnblogs.com/hpcpp/p/6291710.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux memalign,valloc函数</title>
    <link href="http://www.tangyilong.com/2019/02/20/linux-memalign-valloc%E5%87%BD%E6%95%B0/"/>
    <id>http://www.tangyilong.com/2019/02/20/linux-memalign-valloc函数/</id>
    <published>2019-02-20T11:30:53.000Z</published>
    <updated>2019-02-20T11:31:25.222Z</updated>
    
    <content type="html"><![CDATA[<p>  在GNU系统中，malloc或realloc返回的内存块地址都是8的倍数（如果是64位系统，则为16的倍数）。如果你需要更大的粒度，请使用memalign或valloc。这些函数在头文件“stdlib.h”中声明。</p><p>​    在GNU库中，可以使用函数free释放memalign和valloc返回的内存块。但无法在BSD系统中使用，而且BSD系统中并未提供释放这样的内存块的途径。</p><p>​    函数：void * memalign (size_t boundary, size_t size)<br>​    函数memalign将分配一个由size指定大小，地址是boundary的倍数的内存块。参数boundary必须是2的幂！函数memalign可以分配较大的内存块，并且可以为返回的地址指定粒度。</p><p>​    函数：void <em> valloc (size_t size)<br>​    使用函数valloc与使用函数memalign类似，函数valloc的内部实现里，使用页的大小作为对齐长度，使用memalign来分配内存。它的实现如下所示：<br>​    void </em><br>​    valloc (size_t size)<br>​    {<br>​      return memalign (getpagesize (), size);<br>​    }  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  在GNU系统中，malloc或realloc返回的内存块地址都是8的倍数（如果是64位系统，则为16的倍数）。如果你需要更大的粒度，请使用memalign或valloc。这些函数在头文件“stdlib.h”中声明。&lt;/p&gt;
&lt;p&gt;​    在GNU库中，可以使用函数fr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程属性-pthread_attr_init</title>
    <link href="http://www.tangyilong.com/2019/02/20/%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7-pthread-attr-init/"/>
    <id>http://www.tangyilong.com/2019/02/20/线程属性-pthread-attr-init/</id>
    <published>2019-02-20T11:29:40.000Z</published>
    <updated>2019-02-20T11:30:13.598Z</updated>
    
    <content type="html"><![CDATA[<p>我们一般创建线程是这样</p><p>pthread_t tid;</p><p>pthread_create(&amp;tid, NULL, func, NULL);</p><p>第二个参数是线程属性设置，一般设置为了NULL，但是可以通过系统API进一步设置第二个参数，细化创建的线程的属性。</p><p>大致步骤为：</p><p>pthread_attr_t attr;</p><p>pthread_attr_init(&amp;attr);</p><p>pthread_attr_setXXX(&amp;attr, 目标值);</p><p>……//创建线程，其他代码</p><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p><strong>1．线程属性</strong></p><p>​       线程具有属性，用<em>pthread_attr_t</em>表示，在对该结构进行处理之前必须进行初始化，在使用后需要对其去除初始化。我们用<em>pthread_attr_init</em>函数对其初始化，用<em>pthread_attr_destroy</em>对其去除初始化。 </p><p><em>1</em>．</p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_init/pthread_attr_destroy</em></th></tr></thead><tbody><tr><td>功能：</td><td>对线程属性初始化<em>/</em>去除初始化</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_init(pthread_attr_t\</em>attr);<em><br></em>int pthread_attr_destroy(pthread_attr_t*attr);*</td></tr><tr><td>参数：</td><td><em>Attr</em>   线程属性变量</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p>调用<em>pthread_attr_init</em>之后，<em>pthread_t</em>结构所包含的内容就是操作系统实现支持的线程所有属性的默认值。</p><p>   如果要去除对<em>pthread_attr_t</em>结构的初始化，可以调用<em>pthread_attr_destroy</em>函数。如果<em>pthread_attr_init</em>实现时为属性对象分配了动态内存空间，<em>pthread_attr_destroy</em>还会用无效的值初始化属性对象，因此如果经<em>pthread_attr_destroy</em>去除初始化之后的<em>pthread_attr_t</em>结构被<em>pthread_create</em>函数调用，将会导致其返回错误。</p><p>线程属性结构如下：</p><p><em>typedef struct</em></p><p><em>{</em></p><p>​       <em>int                               detachstate;</em>   线程的分离状态</p><p>​       <em>int                               schedpolicy;</em>  线程调度策略</p><p>​       <em>structsched_param              schedparam;</em>  线程的调度参数</p><p>​       <em>int                               inheritsched;</em>  线程的继承性</p><p>​       <em>int                                scope;</em>       线程的作用域</p><p>​       <em>size_t                           guardsize;</em>   线程栈末尾的警戒缓冲区大小</p><p>​       <em>int                                stackaddr_set;</em></p><p>​       <em>void\</em>                          stackaddr;*   线程栈的位置</p><p>​       <em>size_t                           stacksize;</em>    线程栈的大小</p><p><em>}pthread_attr_t;</em></p><p>每个个属性都对应一些函数对其查看或修改。下面我们分别介绍。</p><h3 id="二、线程的分离状态"><a href="#二、线程的分离状态" class="headerlink" title="二、线程的分离状态"></a><strong>二、线程的分离状态</strong></h3><p>​    线程的分离状态决定一个线程以什么样的方式来终止自己。在默认情况下线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。</p><p>而分离线程不是这样子的，它没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。程序员应该根据自己的需要，选择适当的分离状态。所以如果我们在创建线程时就知道不需要了解线程的终止状态，则可以<em>pthread_attr_t</em>结构中的<em>detachstate</em>线程属性，让线程以分离状态启动。</p><p><em>2</em>．</p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_getdetachstate/pthread_attr_setdetachstate</em></th></tr></thead><tbody><tr><td>功能：</td><td>获取<em>/</em>修改线程的分离状态属性</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_getdetachstate(const pthread_attr_t \</em>attr,int *detachstate);<em><br></em>int pthread_attr_setdetachstate(pthread_attr_t *attr,intdetachstate);*</td></tr><tr><td>参数：</td><td><em>Attr</em>   线程属性变量<em>Detachstate</em>  线程的分离状态属性</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p>可以使用<em>pthread_attr_setdetachstate</em>函数把线程属性<em>detachstate</em>设置为下面的两个合法值之一：设置为<em>PTHREAD_CREATE_DETACHED,</em>以分离状态启动线程；或者设置为<em>PTHREAD_CREATE_JOINABLE,</em>正常启动线程。可以使用<em>pthread_attr_getdetachstate</em>函数获取当前的<em>datachstate</em>线程属性。</p><p>以分离状态创建线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">child_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(“child thread run!\n”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[ ])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      pthread_ttid;</span><br><span class="line">      pthread_attr_tattr;</span><br><span class="line">      pthread_attr_init(&amp;attr);</span><br><span class="line">      pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);<span class="comment">//分离</span></span><br><span class="line">      pthread_create(&amp;tid,&amp;attr,fn,arg);</span><br><span class="line">      pthread_attr_destroy(&amp;attr);</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、线程的继承性"><a href="#三、线程的继承性" class="headerlink" title="三、线程的继承性"></a><strong>三、线程的继承性</strong></h3><p>​    函数<em>pthread_attr_setinheritsched</em>和<em>pthread_attr_getinheritsched</em>分别用来设置和得到线程的继承性，这两个函数的定义如下： </p><p><em>3.</em></p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_getinheritsched**pthread_attr_setinheritsched</em></th></tr></thead><tbody><tr><td>功能：</td><td>获得<em>/</em>设置线程的继承性</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_getinheritsched(const pthread_attr_t\</em>attr,int *inheritsched);<em><br></em>int pthread_attr_setinheritsched(pthread_attr_t *attr,intinheritsched);*</td></tr><tr><td>参数：</td><td><em>attr</em>            线程属性变量<em>inheritsched</em>     线程的继承性</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p> 这两个函数具有两个参数，第<em>1</em>个是指向属性对象的指针，第<em>2</em>个是继承性或指向继承性的指针。继承性决定调度的参数是从创建的进程中继承还是使用在<em>schedpolicy</em>和<em>schedparam</em>属性中显式设置的调度信息。<em>Pthreads</em>不为<em>inheritsched</em>指定默认值，因此如果你关心线程的调度策略和参数，必须先设置该属性。</p><p>​    继承性的可能值是<em>PTHREAD_INHERIT_SCHED</em>（表示新现成将继承创建线程的调度策略和参数）和<em>PTHREAD_EXPLICIT_SCHED</em>（表示使用在<em>schedpolicy</em>和<em>schedparam</em>属性中显式设置的调度策略和参数）。</p><p>​    如果你需要显式的设置一个线程的调度策略或参数，那么你必须在设置之前将<em>inheritsched</em>属性设置为<em>PTHREAD_EXPLICIT_SCHED.</em></p><p>​    下面我来讲进程的调度策略和调度参数。我会结合下面的函数给出本函数的程序例子。</p><h3 id="四、线程的调度策略"><a href="#四、线程的调度策略" class="headerlink" title="四、线程的调度策略"></a><strong>四、线程的调度策略</strong></h3><p>   函数<em>pthread_attr_setschedpolicy</em>和<em>pthread_attr_getschedpolicy</em>分别用来设置和得到线程的调度策略。</p><p><em>4.</em></p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_getschedpolicy**pthread_attr_setschedpolicy</em></th></tr></thead><tbody><tr><td>功能：</td><td>获得<em>/</em>设置线程的调度策略</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_getschedpolicy(const pthread_attr_t\</em>attr,int *policy);<em><br></em>int pthread_attr_setschedpolicy(pthread_attr_t *attr,intpolicy);*</td></tr><tr><td>参数：</td><td><em>attr</em>           线程属性变量<em>policy</em>         调度策略</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p>这两个函数具有两个参数，第<em>1</em>个参数是指向属性对象的指针，第<em>2</em>个参数是调度策略或指向调度策略的指针。调度策略可能的值是先进先出（<em>SCHED_FIFO</em>）、轮转法（<em>SCHED_RR</em>）<em>,</em>或其它（<em>SCHED_OTHER</em>）。</p><p>​    <em>SCHED_FIFO</em>策略允许一个线程运行直到有更高优先级的线程准备好，或者直到它自愿阻塞自己。在<em>SCHED_FIFO</em>调度策略下，当有一个线程准备好时，除非有平等或更高优先级的线程已经在运行，否则它会很快开始执行。</p><p>   <em>SCHED_RR(</em>轮循<em>)</em>策略是基本相同的，不同之处在于：如果有一个<em>SCHED_RR</em></p><p>策略的线程执行了超过一个固定的时期<em>(</em>时间片间隔<em>)</em>没有阻塞，而另外的<em>SCHED_RR</em>或<em>SCHBD_FIPO</em>策略的相同优先级的线程准备好时，运行的线程将被抢占以便准备好的线程可以执行。</p><p>​    当有<em>SCHED_FIFO</em>或<em>SCHED_RR</em>策赂的线程在一个条件变量上等持或等持加锁同一个互斥量时，它们将以优先级顺序被唤醒。即，如果一个低优先级的<em>SCHED_FIFO</em>线程和一个高优先织的<em>SCHED_FIFO</em>线程都在等待锁相同的互斥且，则当互斥量被解锁时，高优先级线程将总是被首先解除阻塞。 </p><h3 id="五、线程的调度参数（优先级）"><a href="#五、线程的调度参数（优先级）" class="headerlink" title="五、线程的调度参数（优先级）"></a><strong>五、线程的调度参数（优先级）</strong></h3><p>​    函数<em>pthread_attr_getschedparam</em> 和<em>pthread_attr_setschedparam</em>分别用来设置和得到线程的调度参数。 </p><p><em>5.</em></p><table><thead><tr><th>名称<em>:</em>：</th><th><em>pthread_attr_getschedparam**pthread_attr_setschedparam</em></th></tr></thead><tbody><tr><td>功能：</td><td>获得<em>/</em>设置线程的调度参数</td></tr><tr><td>头文件：</td><td><em>#include&lt;pthread.h&gt;</em></td></tr><tr><td>函数原形：</td><td><em>int pthread_attr_getschedparam(const pthread_attr_t\</em>attr,struct sched_param *param);<em><br></em>int pthread_attr_setschedparam(pthread_attr_t *attr,conststruct sched_param *param);*</td></tr><tr><td>参数：</td><td><em>attr</em>           线程属性变量<em>param          sched_param</em>结构</td></tr><tr><td>返回值：</td><td>若成功返回<em>0</em>，若失败返回<em>-1</em>。</td></tr></tbody></table><p>这两个函数具有两个参数，第<em>1</em>个参数是指向属性对象的指针，第<em>2</em>个参数是<em>sched_param</em>结构或指向该结构的指针。结构<em>sched_param</em>在文件<em>/usr/include/bits/sched.h</em>中定义如下：​     </p><p><em>struct sched_param</em></p><p><em>{</em></p><p>​       <em>intsched_priority;</em></p><p><em>};</em></p><p>结构<em>sched_param</em>的子成员<em>sched_priority</em>控制一个优先权值，大的优先权值对应高的优先权。系统支持的最大和最小优先权值可以用<em>sched_get_priority_max</em>函数和<em>sched_get_priority_min</em>函数分别得到。</p><p>注意：如果不是编写实时程序，不建议修改线程的优先级。因为，调度策略是一件非常复杂的事情，如果不正确使用会导致程序错误，从而导致死锁等问题。如：在多线程应用程序中为线程设置不同的优先级别，有可能因为共享资源而导致优先级倒置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span><span class="title">params</span>;</span></span><br><span class="line"><span class="comment">/* first get the scheduling parameter, then set the new priority */</span></span><br><span class="line"><span class="comment">//设置线程的优先级</span></span><br><span class="line">rval = pthread_attr_getschedparam(attr, &amp;params);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rval = pthreadGetPriorityScope(&amp;minPriority, &amp;maxPriority);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (priority &lt; minPriority)</span><br><span class="line">&#123;</span><br><span class="line">priority = minPriority;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (priority &gt; maxPriority)</span><br><span class="line">&#123;</span><br><span class="line">priority = maxPriority;</span><br><span class="line">&#125;</span><br><span class="line">params.sched_priority = priority;</span><br><span class="line">rval = pthread_attr_setschedparam(attr, &amp;params);</span><br></pre></td></tr></table></figure><h3 id="六、线程的竞争范围"><a href="#六、线程的竞争范围" class="headerlink" title="六、线程的竞争范围"></a>六、线程的竞争范围</h3><p>int pthread_attr_getscope(const pthread_attr_t *restrict attr,</p><p>int *restrict contentionscope);</p><p>int pthread_attr_setscope(pthread_attr_t *attr, int contentionscope);</p><p>定义创建的线程的竞争范围为PTHREAD_SCOPE_SYSTEM、PTHREAD_SCOPE_PROCESS。</p><p>Linux Threads只实现了PTHREAD_SCOPE_SYSTEM，这意味着，它将和机器上运行的所有进程竞争CPU时间。</p><p>标准指定的另外一个值，PTHREAD_SCOPE_PROCESS，表示竞争只存在于运行中的进程的线程之间：即，线程的优先级是相对于其它进程中的线程的优先级的，而不必考虑进程的优先级如何。LinuxThread不支持PTHREAD_SCOPE_PROCESS。</p><p>若成功返回0，若失败返回-1。</p><h3 id="七、线程的栈的地址和大小"><a href="#七、线程的栈的地址和大小" class="headerlink" title="七、线程的栈的地址和大小"></a>七、线程的栈的地址和大小</h3><p>(1)</p><p>int pthread_attr_getstack(pthread_attr_t <em>attr,void **stackaddr,size_t</em>stacksize);</p><p>int pthread_attr_setstack(pthread_attr_t <em>attr, void </em>stackaddr,size_t stacksize);</p><p>设置线程栈的起始地址和栈大小。默认起始地址0，大小0x800000（8M，我的机子……）。</p><p>PS:使用get时往往显示的是addr = 0，size = 0，这可能是系统的BUG，size应给为8M而不是0。</p><p>(2)</p><p>上面的2个函数可以细化成4个：</p><p>int pthread_attr_setstackaddr(pthread_attr_t <em>attr, void </em>stackaddr);</p><p>int pthread_attr_getstackaddr(pthread_attr_t *attr, void**stackaddr);</p><p>int pthread_attr_setstacksize(pthread_attr_t *attr, size_tstacksize);</p><p>int pthread_attr_getstacksize(pthread_attr_t <em>attr, size_t</em>stacksize);</p><p>这里get得到的size为8M，所以pthread_attr_getstack获得的size大小是不能说明栈的大小的。</p><h3 id="八、栈溢出保护区大小"><a href="#八、栈溢出保护区大小" class="headerlink" title="八、栈溢出保护区大小"></a>八、栈溢出保护区大小</h3><p>intpthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);</p><p>intpthread_attr_getguardsize(pthread_attr_t <em>attr, size_t </em>guardsize);</p><p>设置线程的栈溢出保护区大小，默认4096B，即4K。</p><h3 id="九、设置-获取线程属性对象里CPU-姻亲属性"><a href="#九、设置-获取线程属性对象里CPU-姻亲属性" class="headerlink" title="九、设置/获取线程属性对象里CPU 姻亲属性"></a>九、设置/获取线程属性对象里CPU 姻亲属性</h3><p>int pthread_attr_setaffinity_np(pthread_attr_t *attr,size_tcpusetsize,</p><p>const cpu_set_t *cpuset);</p><p>int pthread_attr_getaffinity_np(pthread_attr_t *attr, size_tcpusetsize,</p><p>cpu_set_t *cpuset);</p><p>函数把 attr 引用的线程属性对象中的 CPU 姻亲掩码设置为cpuset 指定的值。这个属性决定了使用线程属性对象 attr 创建的线程的 CPU 姻亲掩码。</p><h3 id="十、获取实时优先级的最大最小值"><a href="#十、获取实时优先级的最大最小值" class="headerlink" title="十、获取实时优先级的最大最小值"></a>十、获取实时优先级的最大最小值</h3><h4 id="Synopsis"><a href="#Synopsis" class="headerlink" title="Synopsis"></a>Synopsis</h4><p><strong>#include &lt;sched.h&gt;</strong></p><p>int sched_get_priority_max(int <em>policy**</em>);<strong>int sched_get_priority_min(int <em>policy</em></strong>);** </p><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><p>The <em>sched_get_priority_max</em>() and <em>sched_get_priority_min</em>() functions shall return the appropriate maximum or minimum, respectively, for the scheduling policy specified by<em>policy</em>.</p><p>The value of <em>policy</em> shall be one of the scheduling policy values defined in <em>&lt;sched.h&gt;</em>.</p><h4 id="Return-Value"><a href="#Return-Value" class="headerlink" title="Return Value"></a>Return Value</h4><p>If successful, the <em>sched_get_priority_max</em>() and <em>sched_get_priority_min</em>() functions shall return the appropriate maximum or minimum values, respectively. If unsuccessful, they shall return a value of -1 and set <em>errno</em> to indicate the error.</p><h4 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h4><p>The <em>sched_get_priority_max</em>() and <em>sched_get_priority_min</em>() functions shall fail if:</p><ul><li><p><strong>EINVAL</strong></p><p>The value of the <em>policy</em> parameter does not represent a defined scheduling policy.</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function: setPthreadAttr</span></span><br><span class="line"><span class="comment"> * Description: set the pthread's attribute: priority and the stack size in details</span></span><br><span class="line"><span class="comment"> * Input:priority - [minPriority, maxPriority] </span></span><br><span class="line"><span class="comment"> *stacksize - the pthread's stack size</span></span><br><span class="line"><span class="comment"> * Output:  attr - the pthread's attribute</span></span><br><span class="line"><span class="comment"> * Return:  0 if successful, otherwise return -1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setPthreadAttr</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> priority, <span class="keyword">size_t</span>* stacksize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span><span class="title">params</span>;</span></span><br><span class="line"><span class="keyword">int</span> maxPriority, minPriority;</span><br><span class="line"></span><br><span class="line">rval = pthread_attr_init(attr);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* normally, need not to set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0 </span></span><br><span class="line">rval = pthread_attr_setinheritsched(attr, PTHREAD_EXPLICIT_SCHED);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rval = pthread_attr_setscope(attr, PTHREAD_SCOPE_SYSTEM);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (rval == ENOTSUP)</span><br><span class="line">&#123;</span><br><span class="line">PRINT(<span class="string">"The system does not support the %s scope, using %s\n"</span>,</span><br><span class="line"><span class="string">"PTHREAD_SCOPE_SYSTEM"</span>, <span class="string">"PTHREAD_SCOPE_PROCESS"</span>);</span><br><span class="line"></span><br><span class="line">rval = pthread_attr_setscope(attr, PTHREAD_SCOPE_PROCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rval)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* use the round robin scheduling algorithm */</span></span><br><span class="line"><span class="comment">//设置线程调度模式，循环</span></span><br><span class="line">rval = pthread_attr_setschedpolicy(attr, SCHED_RR);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set the thread to be detached */</span></span><br><span class="line"><span class="comment">//设置为分离线程，让线程结束的话释放自己的资源</span></span><br><span class="line">rval = pthread_attr_setdetachstate(attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* first get the scheduling parameter, then set the new priority */</span></span><br><span class="line"><span class="comment">//设置线程的优先级</span></span><br><span class="line">rval = pthread_attr_getschedparam(attr, &amp;params);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rval = pthreadGetPriorityScope(&amp;minPriority, &amp;maxPriority);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (priority &lt; minPriority)</span><br><span class="line">&#123;</span><br><span class="line">priority = minPriority;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (priority &gt; maxPriority)</span><br><span class="line">&#123;</span><br><span class="line">priority = maxPriority;</span><br><span class="line">&#125;</span><br><span class="line">params.sched_priority = priority;</span><br><span class="line">rval = pthread_attr_setschedparam(attr, &amp;params);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* when set stack size, we define a minmum value to avoid fail */</span></span><br><span class="line"><span class="comment">//设置栈大小，最小8192</span></span><br><span class="line"><span class="keyword">if</span> (*stacksize &lt; PTHREAD_STACK_MIN)</span><br><span class="line">&#123;</span><br><span class="line">*stacksize = PTHREAD_STACK_MIN;</span><br><span class="line">&#125;</span><br><span class="line">rval = pthread_attr_setstacksize(attr, *stacksize);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pthread_attr_destroy(attr);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function: pthreadSpawn</span></span><br><span class="line"><span class="comment"> * Description: create a pthread, this is a variadic function</span></span><br><span class="line"><span class="comment"> * Input:priority - [minPriority, maxPriority]</span></span><br><span class="line"><span class="comment"> *          stacksize - new thread's stack size(byte)</span></span><br><span class="line"><span class="comment"> *          funcptr - function addr to start the new thread</span></span><br><span class="line"><span class="comment"> *          args - total optional arguments pass to the above function</span></span><br><span class="line"><span class="comment"> *          ... - optional arguments</span></span><br><span class="line"><span class="comment"> * Output:  ptid - pthread id</span></span><br><span class="line"><span class="comment"> * Return:  0 if successful, otherwise an error number returned</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthreadSpawn</span><span class="params">(<span class="keyword">pthread_t</span> *ptid, <span class="keyword">int</span> priority, <span class="keyword">size_t</span> stacksize,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *(*funcptr)(<span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*, <span class="keyword">void</span>*), </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> args, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (funcptr == <span class="literal">NULL</span> || args &gt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> i, rval;</span><br><span class="line"><span class="keyword">void</span> *arg[] = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">START_ROUTINE start;</span><br><span class="line"><span class="keyword">pthread_t</span> tid, *raw;</span><br><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">va_list ap;</span><br><span class="line"><span class="keyword">size_t</span> actStackSize = stacksize;</span><br><span class="line"></span><br><span class="line">va_start(ap, args);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; args; i++)</span><br><span class="line">&#123;</span><br><span class="line">arg[i] = va_arg(ap, <span class="keyword">void</span> *);</span><br><span class="line">PRINTA(<span class="string">"pthreadSpawn: arg[%d] = %d\n"</span>, i, (<span class="keyword">int</span>)arg[i]);</span><br><span class="line">&#125;</span><br><span class="line">va_end(ap);</span><br><span class="line">rval = setPthreadAttr(&amp;attr, priority, &amp;actStackSize);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">PRINTA(<span class="string">"setPthreadAttr failed %d,sys errno %d\n"</span>,rval,errno);</span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptid != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">raw = ptid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">raw = &amp;tid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * If the total optional argumens is 0 or 1, we call the pthread_create directly. </span></span><br><span class="line"><span class="comment"> * Otherwise, we wrap a start routine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (args &lt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">rval = pthread_create(raw, &amp;attr, (START_ROUTINE)funcptr, arg[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">FUNC_WRAPPER2 *func;</span><br><span class="line">func = (FUNC_WRAPPER2 *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FUNC_WRAPPER2));</span><br><span class="line"><span class="keyword">if</span> (func == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="keyword">void</span>) pthread_attr_destroy(&amp;attr);</span><br><span class="line"><span class="keyword">return</span> ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line">start = threadWrapper2;</span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">char</span> *)func, <span class="number">0</span>, <span class="keyword">sizeof</span>(FUNC_WRAPPER2));</span><br><span class="line">func-&gt;entry = funcptr;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; args; i++)</span><br><span class="line">&#123;</span><br><span class="line">func-&gt;arg[i] = arg[i];</span><br><span class="line">&#125;</span><br><span class="line">rval = pthread_create(raw, &amp;attr, start, (<span class="keyword">void</span> *)func);</span><br><span class="line"><span class="keyword">if</span> (rval != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>((<span class="keyword">char</span> *)func);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br><span class="line">PRINTA(<span class="string">"pthread create: tid = %d, priority = %d, stacksize = %d\n"</span>, (<span class="keyword">int</span>)*raw, priority, actStackSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>原文2：<a href="https://blog.csdn.net/Gpengtao/article/details/7792860" target="_blank" rel="noopener">https://blog.csdn.net/Gpengtao/article/details/7792860</a> </p><p>原文1：<a href="https://blog.csdn.net/pbymw8iwm/article/details/6721038" target="_blank" rel="noopener">https://blog.csdn.net/pbymw8iwm/article/details/6721038</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们一般创建线程是这样&lt;/p&gt;
&lt;p&gt;pthread_t tid;&lt;/p&gt;
&lt;p&gt;pthread_create(&amp;amp;tid, NULL, func, NULL);&lt;/p&gt;
&lt;p&gt;第二个参数是线程属性设置，一般设置为了NULL，但是可以通过系统API进一步设置第二个参数
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AF_INET和PE_INET区别</title>
    <link href="http://www.tangyilong.com/2019/02/20/AF-INET%E5%92%8CPE-INET%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.tangyilong.com/2019/02/20/AF-INET和PE-INET区别/</id>
    <published>2019-02-20T11:26:24.000Z</published>
    <updated>2019-02-20T11:26:43.959Z</updated>
    
    <content type="html"><![CDATA[<p>在写网络程序的时候，建立TCP socket：<br>   sock = socket(PF_INET, SOCK_STREAM, 0);<br>然后在绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_INET，即使用IP。</p><p>相关头文件中的定义：AF = Address Family<br>​                 PF = Protocol Family<br>​                 ==AF_INET = PF_INET==</p><p>在windows中的Winsock2.h中，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AF_INET 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_INET AF_INET</span></span><br></pre></td></tr></table></figure><p>所以在windows中AF_INET与PF_INET完全一样. </p><p>  而在Unix/Linux系统中，在不同的版本中这两者有微小差别.对于BSD,是AF,对于POSIX是PF.</p><p>  理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。当然AF_INET和PF_INET的值是相同的，混用也不会有太大的问题。也就是说你socket时候用PF_xxxx，设置的时候用AF_xxxx也是没关系的，这点随便找个TCPIP例子就可以验证出来了。如下，不论是AF_INET还是PF_INET都是可行的，只不过这样子的话，有点不符合规范。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在写网络程序的时候，建立TCP socket：&lt;br&gt;   sock = socket(PF_INET, SOCK_STREAM, 0);&lt;br&gt;然后在绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_I
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>va_list,va_start,va_arg,va_end使用说明</title>
    <link href="http://www.tangyilong.com/2019/02/20/va-list-va-start-va-arg-va-end%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://www.tangyilong.com/2019/02/20/va-list-va-start-va-arg-va-end使用说明/</id>
    <published>2019-02-20T11:22:23.000Z</published>
    <updated>2019-02-20T12:36:15.241Z</updated>
    
    <content type="html"><![CDATA[<p>在ANSI C中，这些宏的定义位于stdarg.h中，典型的实现如下：</p><p><strong>typedef char *va_list;</strong></p><p><strong>va_start宏</strong>，获取可变参数列表的第一个参数的地址（list是类型为va_list的指针，param1是可变参数最左边的参数）：</p><p>#define va_start(list,param1)   ( list = (va_list)&amp;param1+ sizeof(param1) )</p><p><strong>va_arg宏</strong>，获取可变参数的当前参数，返回指定类型并将指针指向下一参数（mode参数描述了当前参数的类型）：</p><p>#define va_arg(list,mode)   ( (mode *) ( list += sizeof(mode) ) )[-1]</p><p><strong>va_end宏</strong>，清空va_list可变参数列表：</p><p>#define va_end(list) ( list = (va_list)0 )</p><p>注：以上sizeof()只是为了说明工作原理，实际实现中，增加的字节数需保证为为int的整数倍</p><p>如：#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1) )</p><p>为了理解这些宏的作用，我们必须先搞清楚：C语言中函数参数的内存布局。首先，函数参数是存储在栈中的，函数参数从右往左依次入栈。</p><p>以下面函数为讨论对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> *para1，<span class="keyword">char</span> *param2，<span class="keyword">char</span> *param3, <span class="keyword">char</span> *param4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      va_list <span class="built_in">list</span>;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在linux中，栈由高地址往低地址生长,调用test函数时，其参数入栈情况如下：</p><p><img src="/pic/va_list1.jpg" alt="img"></p><p> 当调用va_start(list,param1) 时：list指针指向情况对应下图：</p><p><img src="/pic/va_list2.png" alt="img"></p><p>最复杂的宏是va_arg。它必须返回一个由va_list所指向的恰当的类型的数值，同时递增va_list，使它指向参数列表中的一个参数(即递增的大小等于与va_arg宏所返回的数值具有相同类型的对象的长度)。因为类型转换的结果不能作为赋值运算的目标，所以va_arg宏首先使用sizeof来确定需要递增的大小，然后把它直接加到va_list上，这样得到的指针再被转换为要求的类型。因为该指针现在指向的位置”过”了一个类型单位的大小，所以我们使用了下标-1来存取正确的返回参数。</p><p> 下面是实际用例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">var_test</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list <span class="built_in">list</span>;</span><br><span class="line">    va_start(<span class="built_in">list</span>,format);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">         ch = va_arg(<span class="built_in">list</span>, <span class="keyword">char</span> *);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(<span class="built_in">strcmp</span>(ch,<span class="string">""</span>) == <span class="number">0</span>)</span><br><span class="line">         &#123;    </span><br><span class="line">               <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"%s "</span>,ch);</span><br><span class="line">     &#125;</span><br><span class="line">     va_end(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    var_test(<span class="string">"test"</span>,<span class="string">"this"</span>,<span class="string">"is"</span>,<span class="string">"a"</span>,<span class="string">"test"</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附：可变参数应用实例</p><p>1.printf实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">     </span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    n = <span class="built_in">vprintf</span>(format, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> n;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.定制错误打印函数error</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, format);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: "</span>);</span><br><span class="line">    <span class="built_in">vfprintf</span>(<span class="built_in">stderr</span>, format, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="http://www.cnblogs.com/bettercoder/p/3488299.html" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在ANSI C中，这些宏的定义位于stdarg.h中，典型的实现如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;typedef char *va_list;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;va_start宏&lt;/strong&gt;，获取可变参数列表的第一个参数的地址（li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>struct-iovec</title>
    <link href="http://www.tangyilong.com/2019/02/20/struct-iovec/"/>
    <id>http://www.tangyilong.com/2019/02/20/struct-iovec/</id>
    <published>2019-02-20T11:20:45.000Z</published>
    <updated>2019-02-20T11:21:17.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="struct-iovec-结构体定义与使用"><a href="#struct-iovec-结构体定义与使用" class="headerlink" title="struct iovec 结构体定义与使用"></a>struct iovec 结构体定义与使用</h1><p>1 .struct iovec定义了一个向量元素。通常，这个结构用作一个多元素的数组。对于每一个传输的元素，指针成员iov_base指向一个缓冲区，这个缓冲区是存放的是readv所接收的数据或是writev将要发送的数据。成员iov_len在各种情况下分别确定了接收的最大长度以及实际写入的长度。</p><p>2 .在这里，主要介绍readv和writev两个函数；readv(2)与writev(2)函数都使用一个I/O向量的概念；在头文件中定义了struct iovec 结构体，其定义和各成员如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line"> <span class="comment">/* Starting address (内存起始地址）*/</span></span><br><span class="line">   <span class="keyword">void</span>  *iov_base;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of bytes to transfer（这块内存长度） */</span></span><br><span class="line">   <span class="keyword">size_t</span> iov_len;    </span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure><p>linux中使用这样的结构体变量作为参数的函数很多，常见的有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">头文件：</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ssize_t</span> preadv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset);</span><br><span class="line"> <span class="keyword">ssize_t</span> pwritev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt,<span class="keyword">off_t</span> offset);     </span><br><span class="line"> <span class="keyword">ssize_t</span> preadv2(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> flags);</span><br><span class="line"> <span class="keyword">ssize_t</span> pwritev2(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> flags);</span><br></pre></td></tr></table></figure><p>readv和writev作为read与write函数的衍生函数，在一个原子操作中读取或是写入多个缓冲区。readv和writev函数中的各参数的含义如下：<br>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> readv(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> writev(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec *iov, <span class="keyword">int</span> iovcnt);</span><br></pre></td></tr></table></figure><p>这两个函数需要三个参数：<br>   要在其上进行读或是写的文件描述符fd<br>   读或写所用的I/O向量(vector)<br>   要使用的向量元素个数(count)<br>这些函数的返回值是readv所读取的字节数或是writev所写入的字节数。如果有错误发生，就会返回-1，而errno存有错误代码。注意，也其他I/O函数类似，可以返回错误码EINTR来表明他被一个信号所中断。</p><p>3 .示例代码1<br>代码的功能是：向终端（屏幕）打印字符串：i am happy.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment"> * File Name: struct_iovec.c</span></span><br><span class="line"><span class="comment"> * Author:    The answer</span></span><br><span class="line"><span class="comment"> * Function:  Other        </span></span><br><span class="line"><span class="comment"> * Mail:      2412799512@qq.com </span></span><br><span class="line"><span class="comment"> * Created Time: 2017年06月17日 星期六 20时36分21秒</span></span><br><span class="line"><span class="comment">*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(ptr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    <span class="keyword">char</span> *p1 = <span class="string">"i"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p2 = <span class="string">" am"</span>;</span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">" happy.\n"</span>;</span><br><span class="line">    iov[<span class="number">0</span>].iov_base = p1;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(p1);</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">1</span>].iov_base = p2;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(p2);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">2</span>].iov_base = p3;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="built_in">strlen</span>(p3);</span><br><span class="line">    <span class="keyword">ssize_t</span> ret = writev(STDOUT_FILENO,iov,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sys_err(<span class="string">"writev"</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>原文：<a href="https://blog.csdn.net/lixiaogang_theanswer/article/details/73385643" target="_blank" rel="noopener">https://blog.csdn.net/lixiaogang_theanswer/article/details/73385643</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;struct-iovec-结构体定义与使用&quot;&gt;&lt;a href=&quot;#struct-iovec-结构体定义与使用&quot; class=&quot;headerlink&quot; title=&quot;struct iovec 结构体定义与使用&quot;&gt;&lt;/a&gt;struct iovec 结构体定义与使用&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>source_insight的查找功能</title>
    <link href="http://www.tangyilong.com/2019/02/20/source-insight%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.tangyilong.com/2019/02/20/source-insight的查找功能/</id>
    <published>2019-02-20T11:19:01.000Z</published>
    <updated>2019-02-20T11:19:43.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="source-insight的查找功能"><a href="#source-insight的查找功能" class="headerlink" title="source insight的查找功能"></a>source insight的查找功能</h1><p>sourceinsight是一款很好的代码阅读编辑工具，方便对project管理，方便程序的阅读和编辑。查找功能使用十分频繁，选项较多，与其它软件的查找功能也类似，下面对英文版的查找功能，做简单说明：</p><p>查找参数：<br>whole wordsonly :                 全字匹配查找<br>casesensitive  ：                  区分大小写<br>projectwide  :                        项目内查找<br>includesubdirectories :          包含子目录查找<br>skip inactivecode :               跳过无效代码查找<br>skipcomments  :                  跳过注释查找<br>search onlycomments :       仅在注释在查找</p><h3 id="Loopup-References"><a href="#Loopup-References" class="headerlink" title="Loopup References"></a>Loopup References</h3><p>我们最常用的一种查找方式是选择<strong>Search/Lookup References</strong>或按Ctrl+/组合键再或者鼠标点 R按钮，在弹出的Loopup References窗口进行查找操作。 在SearchMethod中有四种可选的查找方式：<strong>Simple String、Regular Expression、 KeywordExpression和Look Up Reference</strong>。其中<strong>SimpleString是最普通的查找方式，可以查找文件中出现的任意字符或字符，甚至可以查找 _upap || u这样的字符串</strong>，但是在工程较大时，查找过程会较慢。<strong>RegularExpression查找方式，正则表达式用来做搜索</strong>。 Keyword Expression和Look UpReference查找的结果基本相同，但是显示方式略有差异。这两种方式都是使用SI预先建立的数据库，查找起来速度相当快。但通常这种速度只对在查找标识符时有明显效果。对于像函数名，变量名等的查找，强烈建议使用这两种方式进行查找。</p><h3 id="SearchFiles"><a href="#SearchFiles" class="headerlink" title="SearchFiles"></a>SearchFiles</h3><p>选择Search/Search Files或按Ctrl+Shift+F组合键，在弹出的Search Files窗口进行查找操作。在File Name框中可以填入文件名或文件夹。注意当要查询的文件夹双包含子文件夹时，可以勾选Options中的IncludeSubdirectiories，实现对各层文件的递归搜索。</p><h3 id="SearchProject"><a href="#SearchProject" class="headerlink" title="SearchProject"></a>SearchProject</h3><p>选择Search/Search Project，在弹出的Search Project窗口进行查找操作。操作与LoopupReferences几乎完全一致，它们各自保存上次搜索的配置。</p><h3 id="几个较常用的快捷键"><a href="#几个较常用的快捷键" class="headerlink" title="几个较常用的快捷键"></a>几个较常用的快捷键</h3><p>默认情况下，SI已经定义了很多非常实用的快捷键：<br>F5<br>指定行号，实现行跳转，在遇到编译错误的时候，能特别方便的找到出错行。<br>Shift+F8<br>高亮显示指定标识，快速浏览标识的使用情况。<br>Ctrl+鼠标点击标识<br>直接跳转至标识定义处。<br>Ctrl+F<br>本文件内查找。<br>F3<br>本文件查找结果的上一个。<br>F4<br>本文件查找结果的下一个。<br>F7<br>打开Browse Project Symbols窗口，快速浏览工程内标识定义。<br>Ctrl+M<br>创建或查找书签，方便下次找回此位置。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;source-insight的查找功能&quot;&gt;&lt;a href=&quot;#source-insight的查找功能&quot; class=&quot;headerlink&quot; title=&quot;source insight的查找功能&quot;&gt;&lt;/a&gt;source insight的查找功能&lt;/h1&gt;&lt;p&gt;so
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大小端和结构体位域</title>
    <link href="http://www.tangyilong.com/2019/01/30/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%8D%E5%9F%9F/"/>
    <id>http://www.tangyilong.com/2019/01/30/大小端和结构体位域/</id>
    <published>2019-01-30T09:07:32.000Z</published>
    <updated>2019-01-30T09:08:02.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大小端和结构体位域"><a href="#大小端和结构体位域" class="headerlink" title="大小端和结构体位域"></a>大小端和结构体位域</h1><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><h3 id="什么是大小端"><a href="#什么是大小端" class="headerlink" title="什么是大小端"></a>什么是大小端</h3><p>Big-Endian和Little-Endian的定义如下：<br>1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：<br><strong>1)大端模式：</strong><br>低地址 —————–&gt; 高地址<br>0x12  |  0x34  |  0x56  |  0x78<br><strong>2)小端模式：</strong><br>低地址 ——————&gt; 高地址<br>0x78  |  0x56  |  0x34  |  0x12<br><strong>可见，大端模式和字符串的存储模式类似。</strong><br><strong>3)下面是两个具体例子：</strong><br>16bit宽的数0x1234在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p><table><thead><tr><th>内存地址</th><th>小端模式存放内容</th><th>大端模式存放内容</th></tr></thead><tbody><tr><td><strong>0x4000</strong></td><td><strong>0x34</strong></td><td><strong>0x12</strong></td></tr><tr><td><strong>0x4001</strong></td><td><strong>0x12</strong></td><td><strong>0x34</strong></td></tr></tbody></table><p><strong>32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</strong></p><table><thead><tr><th><strong>内存地址</strong></th><th><strong>小端模式存放内容</strong></th><th><strong>大端模式存放内容</strong></th></tr></thead><tbody><tr><td><strong>0x4000</strong></td><td><strong>0x78</strong></td><td><strong>0x12</strong></td></tr><tr><td><strong>0x4001</strong></td><td><strong>0x56</strong></td><td><strong>0x34</strong></td></tr><tr><td><strong>0x4002</strong></td><td><strong>0x34</strong></td><td><strong>0x56</strong></td></tr><tr><td><strong>0x4003</strong></td><td><strong>0x12</strong></td><td><strong>0x78</strong></td></tr></tbody></table><p> <strong>4)大端小端没有谁优谁劣，各自优势便是对方劣势：</strong><br>大端：容易判断正负（offset(0)）；<br><strong>ps:通常情况下，ARM是大端模式；X86是小端模式；</strong><br><strong>小端：易于进行数据类型转换，1、2、4字节的存储方式一样。</strong></p><h3 id="判断大小端"><a href="#判断大小端" class="headerlink" title="判断大小端"></a>判断大小端</h3><p> <strong>可以使用程序判断CPU模式是大端还是小端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0x1234</span>;</span><br><span class="line"><span class="keyword">char</span> b=*(<span class="keyword">char</span>*)&amp;a;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0x12</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"big end\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"little end\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。<strong>位段成员必须声明为int、unsigned int或signed int类型（short char long）。</strong></p><p>一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名     </span></span><br><span class="line"><span class="class">&#123;</span> 位域列表 &#125;;</span><br></pre></td></tr></table></figure><p>其中位域列表的形式为： 类型说明符 位域名：位域长度<br>例如：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">int</span> a:<span class="number">8</span>;     </span><br><span class="line"><span class="keyword">int</span> b:<span class="number">2</span>;     </span><br><span class="line"><span class="keyword">int</span> c:<span class="number">6</span>;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。</p><ol><li>如果一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：     </li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">unsigned</span> a:<span class="number">4</span>     </span><br><span class="line"><span class="keyword">unsigned</span> :<span class="number">0</span> <span class="comment">/*空域*/</span>     </span><br><span class="line"><span class="keyword">unsigned</span> b:<span class="number">4</span> <span class="comment">/*从下一单元开始存放*/</span>     </span><br><span class="line"><span class="keyword">unsigned</span> c:<span class="number">4</span>     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。     </p><p>2.位域的长度不能大于数据类型本身的长度，比如int类型就能超过32位二进位。</p><p><em>3.</em> 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">int</span> a:<span class="number">1</span>     </span><br><span class="line"><span class="keyword">int</span> :<span class="number">2</span> <span class="comment">/*该2位不能使用*/</span>     </span><br><span class="line"><span class="keyword">int</span> b:<span class="number">3</span>     </span><br><span class="line"><span class="keyword">int</span> c:<span class="number">2</span>     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。</p><p>二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名.位域名 位域允许用各种格式输出。     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line">    <span class="keyword">unsigned</span> a:<span class="number">1</span>;     </span><br><span class="line">    <span class="keyword">unsigned</span> b:<span class="number">3</span>;     </span><br><span class="line">    <span class="keyword">unsigned</span> c:<span class="number">4</span>;     </span><br><span class="line">&#125; bit,*pbit;     </span><br><span class="line">bit.a=<span class="number">1</span>;     </span><br><span class="line">bit.b=<span class="number">7</span>; <span class="comment">//注意：位域的赋值不能超过该域所能表示的最大值，如b只有3位，能表示的最大数为7，若赋为8，就会出错   </span></span><br><span class="line">bit.c=<span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，<br>允许其它类型类型的存在。<br>使用位域的主要目的是压缩存储，其大致规则为：</p><p>1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止<br>2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；<br>3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++，GCC采取压缩方式；<br>4) 如果位域字段之间穿插着非位域字段，则不进行压缩；<br>5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大小端和结构体位域&quot;&gt;&lt;a href=&quot;#大小端和结构体位域&quot; class=&quot;headerlink&quot; title=&quot;大小端和结构体位域&quot;&gt;&lt;/a&gt;大小端和结构体位域&lt;/h1&gt;&lt;h2 id=&quot;大小端&quot;&gt;&lt;a href=&quot;#大小端&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
</feed>
