<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>as3522</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tangyilong.com/"/>
  <updated>2019-01-30T09:08:02.212Z</updated>
  <id>http://www.tangyilong.com/</id>
  
  <author>
    <name>as3522</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大小端和结构体位域</title>
    <link href="http://www.tangyilong.com/2019/01/30/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%8D%E5%9F%9F/"/>
    <id>http://www.tangyilong.com/2019/01/30/大小端和结构体位域/</id>
    <published>2019-01-30T09:07:32.000Z</published>
    <updated>2019-01-30T09:08:02.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大小端和结构体位域"><a href="#大小端和结构体位域" class="headerlink" title="大小端和结构体位域"></a>大小端和结构体位域</h1><h2 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h2><h3 id="什么是大小端"><a href="#什么是大小端" class="headerlink" title="什么是大小端"></a>什么是大小端</h3><p>Big-Endian和Little-Endian的定义如下：<br>1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>2) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>举一个例子，比如数字0x12 34 56 78在内存中的表示形式为：<br><strong>1)大端模式：</strong><br>低地址 —————–&gt; 高地址<br>0x12  |  0x34  |  0x56  |  0x78<br><strong>2)小端模式：</strong><br>低地址 ——————&gt; 高地址<br>0x78  |  0x56  |  0x34  |  0x12<br><strong>可见，大端模式和字符串的存储模式类似。</strong><br><strong>3)下面是两个具体例子：</strong><br>16bit宽的数0x1234在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p><table><thead><tr><th>内存地址</th><th>小端模式存放内容</th><th>大端模式存放内容</th></tr></thead><tbody><tr><td><strong>0x4000</strong></td><td><strong>0x34</strong></td><td><strong>0x12</strong></td></tr><tr><td><strong>0x4001</strong></td><td><strong>0x12</strong></td><td><strong>0x34</strong></td></tr></tbody></table><p><strong>32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</strong></p><table><thead><tr><th><strong>内存地址</strong></th><th><strong>小端模式存放内容</strong></th><th><strong>大端模式存放内容</strong></th></tr></thead><tbody><tr><td><strong>0x4000</strong></td><td><strong>0x78</strong></td><td><strong>0x12</strong></td></tr><tr><td><strong>0x4001</strong></td><td><strong>0x56</strong></td><td><strong>0x34</strong></td></tr><tr><td><strong>0x4002</strong></td><td><strong>0x34</strong></td><td><strong>0x56</strong></td></tr><tr><td><strong>0x4003</strong></td><td><strong>0x12</strong></td><td><strong>0x78</strong></td></tr></tbody></table><p> <strong>4)大端小端没有谁优谁劣，各自优势便是对方劣势：</strong><br>大端：容易判断正负（offset(0)）；<br><strong>ps:通常情况下，ARM是大端模式；X86是小端模式；</strong><br><strong>小端：易于进行数据类型转换，1、2、4字节的存储方式一样。</strong></p><h3 id="判断大小端"><a href="#判断大小端" class="headerlink" title="判断大小端"></a>判断大小端</h3><p> <strong>可以使用程序判断CPU模式是大端还是小端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">0x1234</span>;</span><br><span class="line"><span class="keyword">char</span> b=*(<span class="keyword">char</span>*)&amp;a;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0x12</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"big end\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"little end\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h2><p>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。<strong>位段成员必须声明为int、unsigned int或signed int类型（short char long）。</strong></p><p>一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 位域结构名     </span></span><br><span class="line"><span class="class">&#123;</span> 位域列表 &#125;;</span><br></pre></td></tr></table></figure><p>其中位域列表的形式为： 类型说明符 位域名：位域长度<br>例如：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">int</span> a:<span class="number">8</span>;     </span><br><span class="line"><span class="keyword">int</span> b:<span class="number">2</span>;     </span><br><span class="line"><span class="keyword">int</span> c:<span class="number">6</span>;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。</p><ol><li>如果一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：     </li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">unsigned</span> a:<span class="number">4</span>     </span><br><span class="line"><span class="keyword">unsigned</span> :<span class="number">0</span> <span class="comment">/*空域*/</span>     </span><br><span class="line"><span class="keyword">unsigned</span> b:<span class="number">4</span> <span class="comment">/*从下一单元开始存放*/</span>     </span><br><span class="line"><span class="keyword">unsigned</span> c:<span class="number">4</span>     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。     </p><p>2.位域的长度不能大于数据类型本身的长度，比如int类型就能超过32位二进位。</p><p><em>3.</em> 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line"><span class="keyword">int</span> a:<span class="number">1</span>     </span><br><span class="line"><span class="keyword">int</span> :<span class="number">2</span> <span class="comment">/*该2位不能使用*/</span>     </span><br><span class="line"><span class="keyword">int</span> b:<span class="number">3</span>     </span><br><span class="line"><span class="keyword">int</span> c:<span class="number">2</span>     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。</p><p>二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名.位域名 位域允许用各种格式输出。     </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>     </span></span><br><span class="line"><span class="class">&#123;</span>     </span><br><span class="line">    <span class="keyword">unsigned</span> a:<span class="number">1</span>;     </span><br><span class="line">    <span class="keyword">unsigned</span> b:<span class="number">3</span>;     </span><br><span class="line">    <span class="keyword">unsigned</span> c:<span class="number">4</span>;     </span><br><span class="line">&#125; bit,*pbit;     </span><br><span class="line">bit.a=<span class="number">1</span>;     </span><br><span class="line">bit.b=<span class="number">7</span>; <span class="comment">//注意：位域的赋值不能超过该域所能表示的最大值，如b只有3位，能表示的最大数为7，若赋为8，就会出错   </span></span><br><span class="line">bit.c=<span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，<br>允许其它类型类型的存在。<br>使用位域的主要目的是压缩存储，其大致规则为：</p><p>1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止<br>2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；<br>3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++，GCC采取压缩方式；<br>4) 如果位域字段之间穿插着非位域字段，则不进行压缩；<br>5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大小端和结构体位域&quot;&gt;&lt;a href=&quot;#大小端和结构体位域&quot; class=&quot;headerlink&quot; title=&quot;大小端和结构体位域&quot;&gt;&lt;/a&gt;大小端和结构体位域&lt;/h1&gt;&lt;h2 id=&quot;大小端&quot;&gt;&lt;a href=&quot;#大小端&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>svn基本操作</title>
    <link href="http://www.tangyilong.com/2019/01/30/svn%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.tangyilong.com/2019/01/30/svn基本操作/</id>
    <published>2019-01-30T09:05:54.000Z</published>
    <updated>2019-01-30T09:06:35.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="svn常用操作命令"><a href="#svn常用操作命令" class="headerlink" title="svn常用操作命令"></a>svn常用操作命令</h1><p><a href="https://www.cnblogs.com/liwanggui/archive/2016/06/28/5624147.html" target="_blank" rel="noopener">原文地址</a></p><h2 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">svn  checkout  http://路径(目录或文件的全路径)　[本地目录全路径] --username　用户名</span><br><span class="line">svn  checkout  svn://路径(目录或文件的全路径)　[本地目录全路径]  --username　用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子：</span></span><br><span class="line">svn co svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">svn co http://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br><span class="line">svn checkout svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">svn checkouthttp://localhost/<span class="built_in">test</span>/testapp --username wzhnsc</span><br></pre></td></tr></table></figure><blockquote><p>注：如果不带–password 参数传输密码的话，会提示输入密码，建议不要用明文的–password 选项。<br>　　 其中 username 与 password前是两个短线，不是一个。<br>　　 不指定本地目录全路径，则检出到当前目录下。</p></blockquote><h2 id="导出-导出一个干净的不带-svn文件夹的目录树"><a href="#导出-导出一个干净的不带-svn文件夹的目录树" class="headerlink" title="导出(导出一个干净的不带.svn文件夹的目录树)"></a>导出(导出一个干净的不带.svn文件夹的目录树)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">svn  export  [-r 版本号]  http://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  [-r 版本号]  svn://路径(目录或文件的全路径) [本地目录全路径]　--username　用户名</span><br><span class="line">svn  export  本地检出的(即带有.svn文件夹的)目录全路径  要导出的本地目录全路径</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">svn export svn://localhost/测试工具 /home/testtools --username wzhnsc</span><br><span class="line">svn export svn://localhost/test/testapp --username wzhnsc</span><br><span class="line">svn export /home/testapp /home/testtools</span><br></pre></td></tr></table></figure><blockquote><p>注：第一种从版本库导出干净工作目录树的形式是指定URL，<br>如果指定了修订版本号，会导出相应的版本，<br>如果没有指定修订版本，则会导出最新的，导出到指定位置。<br>如果省略 本地目录全路径，URL的最后一部分会作为本地目录的名字。<br>第二种形式是指定 本地检出的目录全路径 到 要导出的本地目录全路径，所有的本地修改将会保留，<br>但是不在版本控制下(即没提交的新文件，因为.svn文件夹里没有与之相关的信息记录)的文件不会拷贝。</p></blockquote><h2 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">svn　add　文件名</span><br><span class="line">注：告诉SVN服务器要添加文件了，还要用svn commint -m真实的上传上去！</span><br><span class="line">例子：</span><br><span class="line">svn add test.php ＜－ 添加test.php </span><br><span class="line">svn commit -m <span class="string">"添加我的测试用test.php"</span> test.php</span><br><span class="line">svn add *.php ＜－ 添加当前目录下所有的php文件</span><br><span class="line">svn commit -m <span class="string">"添加我的测试用全部php文件"</span> *.php</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">svn　commit　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line">svn　ci　-m　<span class="string">"提交备注信息文本"</span>　[-N]　[--no-unlock]　文件名</span><br><span class="line">必须带上-m参数，参数可以为空，但是必须写上-m</span><br><span class="line">例子：</span><br><span class="line">svn commit -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> * ＜－ 注意这个*表示全部文件</span><br><span class="line">svn commit -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">svn commit -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php ＜－ 保持锁就用–no-unlock开关</span><br><span class="line">svn ci -m <span class="string">"提交当前目录下的全部在版本控制下的文件"</span> * ＜－ 注意这个*表示全部文件</span><br><span class="line">svn ci -m <span class="string">"提交我的测试用test.php"</span> test.php</span><br><span class="line">svn ci -m <span class="string">"提交我的测试用test.php"</span> -N --no-unlock test.php ＜－ 保持锁就用–no-unlock开关</span><br></pre></td></tr></table></figure><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">svn　update</span><br><span class="line">svn　update　-r　修正版本　文件名</span><br><span class="line">svn　update　文件名</span><br><span class="line">例子：</span><br><span class="line">svn update ＜－ 后面没有目录，默认将当前目录以及子目录下的所有文件都更新到最新版本</span><br><span class="line">svn update -r 200 test.cpp ＜－ 将版本库中的文件 test.cpp 还原到修正版本（revision）200</span><br><span class="line">svn update test.php ＜－ 更新与版本库同步。</span><br><span class="line">　　　　　　　　　　　 提交的时候提示过期冲突，需要先 update 修改文件，</span><br><span class="line">　　　　　　　　　　　 然后清除svn resolved，最后再提交commit。</span><br></pre></td></tr></table></figure><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">svn　delete　svn://路径(目录或文件的全路径) -m <span class="string">"删除备注信息文本"</span></span><br><span class="line">推荐如下操作：</span><br><span class="line">svn　delete　文件名 </span><br><span class="line">svn　ci　-m　<span class="string">"删除备注信息文本"</span></span><br><span class="line">例子：</span><br><span class="line">svn delete svn://localhost/testapp/test.php -m <span class="string">"删除测试文件test.php"</span></span><br><span class="line">推荐如下操作：</span><br><span class="line">svn delete test.php </span><br><span class="line">svn ci -m <span class="string">"删除测试文件test.php"</span></span><br></pre></td></tr></table></figure><h2 id="加锁-解锁"><a href="#加锁-解锁" class="headerlink" title="加锁/解锁"></a>加锁/解锁</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　lock　-m　<span class="string">"加锁备注信息文本"</span>　[--force]　文件名 </span><br><span class="line">svn　unlock　文件名</span><br><span class="line">例子：</span><br><span class="line">svn lock -m <span class="string">"锁信测试用test.php文件"</span> test.php </span><br><span class="line">svn unlock test.php</span><br></pre></td></tr></table></figure><h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　diff　文件名 </span><br><span class="line">svn　diff　-r　修正版本号m:修正版本号n　文件名</span><br><span class="line">例子：</span><br><span class="line">svn diff test.php＜－ 将修改的文件与基础版本比较</span><br><span class="line">svn diff -r 200:201 test.php＜－ 对 修正版本号200 和 修正版本号201 比较差异</span><br></pre></td></tr></table></figure><h2 id="查看文件或者目录状态"><a href="#查看文件或者目录状态" class="headerlink" title="查看文件或者目录状态"></a>查看文件或者目录状态</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">svn st 目录路径/名</span><br><span class="line">svn status 目录路径/名＜－ 目录下的文件和子目录的状态，正常状态不显示 </span><br><span class="line">　　　　　　　　　　　　　【?：不在svn的控制中；  M：内容被修改；C：发生冲突；</span><br><span class="line">　　　　　　　　　　　　　　A：预定加入到版本库；K：被锁定】 </span><br><span class="line">svn  -v 目录路径/名</span><br><span class="line">svn status -v 目录路径/名＜－ 显示文件和子目录状态</span><br><span class="line">　　　　　　　　　　　　　　【第一列保持相同，第二列显示工作版本号，</span><br><span class="line">　　　　　　　　　　　　　　 第三和第四列显示最后一次修改的版本号和修改人】</span><br></pre></td></tr></table></figure><blockquote><p>注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，<br>　　原因是svn在本地的.svn中保留了本地版本的原始拷贝。</p></blockquote><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn　<span class="built_in">log</span>　文件名</span><br><span class="line">例子：</span><br><span class="line">svn <span class="built_in">log</span> test.php＜－ 显示这个文件的所有修改记录，及其版本号的变化</span><br></pre></td></tr></table></figure><h2 id="查看文件详细信息"><a href="#查看文件详细信息" class="headerlink" title="查看文件详细信息"></a>查看文件详细信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn　info　文件名</span><br><span class="line">例子：</span><br><span class="line">svn info test.php</span><br></pre></td></tr></table></figure><h2 id="SVN-帮助"><a href="#SVN-帮助" class="headerlink" title="SVN 帮助"></a>SVN 帮助</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">svn　help ＜－ 全部功能选项</span><br><span class="line">svn　help　ci ＜－ 具体功能的说明</span><br></pre></td></tr></table></figure><h2 id="查看版本库下的文件和目录列表"><a href="#查看版本库下的文件和目录列表" class="headerlink" title="查看版本库下的文件和目录列表"></a>查看版本库下的文件和目录列表</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　list　svn://路径(目录或文件的全路径)</span><br><span class="line">svn　ls　svn://路径(目录或文件的全路径)</span><br><span class="line">例子：</span><br><span class="line">svn list svn://localhost/<span class="built_in">test</span></span><br><span class="line">svn ls svn://localhost/<span class="built_in">test</span> ＜－ 显示svn://localhost/<span class="built_in">test</span>目录下的所有属于版本库的文件和目录</span><br></pre></td></tr></table></figure><h2 id="创建纳入版本控制下的新目录"><a href="#创建纳入版本控制下的新目录" class="headerlink" title="创建纳入版本控制下的新目录"></a>创建纳入版本控制下的新目录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　mkdir　目录名</span><br><span class="line">svn　mkdir　-m　<span class="string">"新增目录备注文本"</span>　http://目录全路径</span><br><span class="line">例子：</span><br><span class="line">svn mkdir newdir</span><br><span class="line">svn mkdir -m <span class="string">"Making a new dir."</span> svn://localhost/<span class="built_in">test</span>/newdir</span><br></pre></td></tr></table></figure><blockquote><p>注：添加完子目录后，一定要回到根目录更新一下，不然在该目录下提交文件会提示“提交失败”</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">svn update</span></span><br></pre></td></tr></table></figure><blockquote><p>注：如果手工在checkout出来的目录里创建了一个新文件夹newsubdir，<br>　　再用svn mkdir newsubdir命令后，SVN会提示：<br>　　svn: 尝试用 “svn add”或 “svn add –non-recursive”代替？<br>　　svn: 无法创建目录“hello”: 文件已经存在<br>　　此时，用如下命令解决：<br>　　svn add –non-recursive newsubdir<br>　　在进入这个newsubdir文件夹，用ls -a查看它下面的全部目录与文件，会发现多了：.svn目录<br>　　再用 svn mkdir -m “添hello功能模块文件” <a href="svn://localhost/test/newdir/newsubdir" target="_blank" rel="noopener">svn://localhost/test/newdir/newsubdir</a> 命令，<br>　　SVN提示：<br>　　svn: File already exists: filesystem ‘/data/svnroot/test/db’, transaction ‘4541-1’,<br>　　path ‘/newdir/newsubdir ‘</p></blockquote><h2 id="恢复本地修改"><a href="#恢复本地修改" class="headerlink" title="恢复本地修改"></a>恢复本地修改</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">svn　revert　[--recursive]　文件名</span><br><span class="line">注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录。</span><br><span class="line">例子：</span><br><span class="line">svn revert foo.c ＜－ 丢弃对一个文件的修改</span><br><span class="line">svn revert --recursive . ＜－恢复一整个目录的文件，. 为当前目录</span><br></pre></td></tr></table></figure><h2 id="把工作拷贝更新到别的URL"><a href="#把工作拷贝更新到别的URL" class="headerlink" title="把工作拷贝更新到别的URL"></a>把工作拷贝更新到别的URL</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svn　switch　http://目录全路径　本地目录全路径</span><br><span class="line">例子：</span><br><span class="line">svn switch http://localhost/<span class="built_in">test</span>/456 . ＜－ (原为123的分支)当前所在目录分支到localhost/<span class="built_in">test</span>/456</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">svn　resolved　[本地目录全路径]</span><br><span class="line">例子：</span><br><span class="line">$ svn update</span><br><span class="line">C foo.c</span><br><span class="line">Updated to revision 31.</span><br><span class="line">如果你在更新时得到冲突，你的工作拷贝会产生三个新的文件：</span><br><span class="line">$ ls</span><br><span class="line">foo.c</span><br><span class="line">foo.c.mine</span><br><span class="line">foo.c.r30</span><br><span class="line">foo.c.r31</span><br><span class="line">当你解决了foo.c的冲突，并且准备提交，运行svn resolved让你的工作拷贝知道你已经完成了所有事情。</span><br><span class="line">你可以仅仅删除冲突的文件并且提交，但是svn resolved除了删除冲突文件，还修正了一些记录在工作拷贝管理区域的记录数据，所以我们推荐你使用这个命令。</span><br></pre></td></tr></table></figure><h2 id="不checkout而查看输出特定文件或URL的内容"><a href="#不checkout而查看输出特定文件或URL的内容" class="headerlink" title="不checkout而查看输出特定文件或URL的内容"></a>不checkout而查看输出特定文件或URL的内容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">svn　cat　http://文件全路径</span><br><span class="line">例子：</span><br><span class="line">svn cat http://localhost/<span class="built_in">test</span>/readme.txt</span><br><span class="line">新建一个分支copy</span><br><span class="line">svn copy branchA branchB  -m <span class="string">"make B branch"</span> // 从branchA拷贝出一个新分支branchB</span><br><span class="line">合并内容到分支merge</span><br><span class="line">svn merge branchA branchB  // 把对branchA的修改合并到分支branchB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;svn常用操作命令&quot;&gt;&lt;a href=&quot;#svn常用操作命令&quot; class=&quot;headerlink&quot; title=&quot;svn常用操作命令&quot;&gt;&lt;/a&gt;svn常用操作命令&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liwanggui
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CoreDump</title>
    <link href="http://www.tangyilong.com/2019/01/30/CoreDump/"/>
    <id>http://www.tangyilong.com/2019/01/30/CoreDump/</id>
    <published>2019-01-30T08:59:10.000Z</published>
    <updated>2019-01-30T09:01:53.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-Core-Dump"><a href="#Linux-Core-Dump" class="headerlink" title="Linux Core Dump"></a>Linux Core Dump</h1><p>​    当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做<strong>Core Dump</strong>（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。</p><p>​    OS在出Core的同时，虽然会终止掉当前进程，但是也会保留下第一手的现场数据，OS仿佛是一架被按下快门的相机，而照片就是产出的Core文件。里面含有当进程被终止时内存、CPU寄存器等信息，可以供后续开发人员进行调试。 </p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>​    在半导体作为电脑内存材料之前，电脑内存使用的是 <a href="http://en.wikipedia.org/wiki/Core_memory" target="_blank" rel="noopener"><strong>磁芯内存</strong></a>（Magnetic Core Memory），Core Dump 中的 Core 沿用了磁芯内存的 <strong>Core</strong> 表达。</p><p>​    <strong>Dump</strong> 指的是拷贝一种存储介质中的部分内容到另一个存储介质，或者将内容打印、显示或者其它输出设备。dump 出来的内容是格式化的，可以使用一些工具来解析它。</p><p>​    现代操作系统中，用 <strong>Core Dump</strong> 表示当程序异常终止或崩溃时，将进程此时的内存中的内容拷贝到磁盘文件中存储，以方便编程人员调试。</p><h2 id="Core-Dump-如何产生"><a href="#Core-Dump-如何产生" class="headerlink" title="Core Dump 如何产生"></a>Core Dump 如何产生</h2><p>上面说当程序运行过程中<strong>异常终止</strong>或<strong>崩溃</strong>时会发生 core dump，但还没说到什么具体的情景程序会发生异常终止或崩溃，例如我们使用 <code>kill -9</code> 命令杀死一个进程会发生 core dump 吗？实验证明是不能的，那么什么情况会产生呢？</p><p>Linux 中信号是一种异步事件处理的机制，每种信号对应有其默认的操作，你可以在 <strong>这里</strong> 查看 Linux 系统提供的信号以及默认处理。默认操作主要包括忽略该信号（Ingore）、暂停进程（Stop）、终止进程（Terminate）、终止并发生core dump（core）等。如果我们信号均是采用默认操作，那么，以下列出几种信号，它们在发生时会产生 core dump:</p><table><thead><tr><th>Signal</th><th>Action</th><th>Comment</th></tr></thead><tbody><tr><td>SIGQUIT</td><td>Core</td><td>Quit from keyboard</td></tr><tr><td>SIGILL</td><td>Core</td><td>Illegal Instruction</td></tr><tr><td>SIGABRT</td><td>Core</td><td>Abort signal from <a href="http://man7.org/linux/man-pages/man3/abort.3.html" target="_blank" rel="noopener">abort</a></td></tr><tr><td>SIGSEGV</td><td>Core</td><td>Invalid memory reference</td></tr><tr><td>SIGTRAP</td><td>Core</td><td>Trace/breakpoint trap</td></tr></tbody></table><p>当然不仅限于上面的几种信号。这就是为什么我们使用 <code>Ctrl+z</code> 来挂起一个进程或者 <code>Ctrl+C</code> 结束一个进程均不会产生 core dump，因为前者会向进程发出 <strong>SIGTSTP</strong> 信号，该信号的默认操作为暂停进程（Stop Process）；后者会向进程发出<strong>SIGINT</strong> 信号，该信号默认操作为终止进程（Terminate Process）。同样上面提到的 <code>kill -9</code> 命令会发出 <strong>SIGKILL</strong> 命令，该命令默认为终止进程。而如果我们使用 <code>Ctrl+\</code> 来终止一个进程，会向进程发出 <strong>SIGQUIT</strong> 信号，默认是会产生 core dump 的。还有其它情景会产生 core dump， 如：程序调用 <code>abort()</code> 函数、访存错误、非法指令等等。</p><p>下面举两个例子来说明：</p><ul><li><p>终端下比较 <code>Ctrl+C</code> 和 <code>Ctrl+\</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">guohailin@guohailin:~$ sleep 10        #使用sleep命令休眠 10 s</span><br><span class="line">^C                           #使用 Ctrl+C 终止该程序,不会产生 core dump</span><br><span class="line">guohailin@guohailin:~$ sleep 10</span><br><span class="line">^\Quit (core dumped)                #使用 Ctrl+\ 退出程序, 会产生 core dump</span><br><span class="line">guohailin@guohailin:~$ ls         #多出下面一个 core 文件</span><br><span class="line">-rw-------  1 guohailin guohailin 335872 10月 22 11:31 sleep.core.21990</span><br></pre></td></tr></table></figure></li><li><p>小程序产生 core dump</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int *null_ptr = NULL;</span><br><span class="line">    *null_ptr = 10;            //对空指针指向的内存区域写,会发生段错误</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#编译执行</span></span><br><span class="line">guohailin@guohailin:~$ ./a.out</span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">guohailin@guohailin:~$ ls      <span class="comment">#多出下面一个 core 文件</span></span><br><span class="line">-rw-------  1 guohailin guohailin 200704 10月 22 11:35 a.out.core.22070</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何打开Core-Dump"><a href="#如何打开Core-Dump" class="headerlink" title="如何打开Core Dump"></a>如何打开Core Dump</h2><ul><li><p><strong>打开 core dump 功能</strong></p><ul><li>在终端中输入命令 <code>ulimit -c</code> ，输出的结果为 0，说明默认是关闭 core dump 的，即当程序异常终止时，也不会生成 core dump 文件。</li><li>我们可以使用命令 <code>ulimit -c unlimited</code> 来开启 core dump 功能，并且不限制 core dump 文件的大小； 如果需要限制文件的大小，将 unlimited 改成你想生成 core 文件最大的大小，注意单位为 blocks（KB）。</li><li>用上面命令只会对当前的终端环境有效，如果想需要永久生效，可以修改文件 <code>/etc/security/limits.conf</code>文件，关于此文件的设置参看 <strong>这里</strong> 。增加一行:</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/security/limits.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#Each line describes a limit for a user in the form:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#&lt;domain&gt;   &lt;type&gt;   &lt;item&gt;   &lt;value&gt;</span></span><br><span class="line">    *          soft     core   unlimited</span><br></pre></td></tr></table></figure></li><li><p><strong>修改 core 文件保存的路径</strong></p><ul><li><p>默认生成的 core 文件保存在可执行文件所在的目录下，文件名就为 <code>core</code>。</p></li><li><p>通过修改 <code>/proc/sys/kernel/core_uses_pid</code> 文件可以让生成 core 文件名是否自动加上 pid 号。<br>例如 <code>echo 1 &gt; /proc/sys/kernel/core_uses_pid</code> ，生成的 core 文件名将会变成 <code>core.pid</code>，其中 pid 表示该进程的 PID。</p></li><li><p>还可以通过修改 <code>/proc/sys/kernel/core_pattern</code> 来控制生成 core 文件保存的位置以及文件名格式。<br>例如可以用 <code>echo &quot;/tmp/corefile-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern</code> 设置生成的 core 文件保存在 “/tmp/corefile” 目录下，文件名格式为 “core-命令名-pid-时间戳”。<strong>这里</strong> 有更多详细的说明！</p></li><li><p>修改/proc/sys/kernel/core_pattern文件，此文件用于控制Core文件产生的文件名，默认情况下，此文件内容只有一行内容：“core”，此文件支持定制，一般使用%配合不同的字符，这里罗列几种：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">p</span></span>  出Core进程的PID</span><br><span class="line"><span class="tag">%<span class="selector-tag">u</span></span>  出Core进程的UID</span><br><span class="line"><span class="tag">%<span class="selector-tag">s</span></span>  造成Core的signal号</span><br><span class="line"><span class="tag">%<span class="selector-tag">t</span></span>  出Core的时间，从1970-01-0100:00:00开始的秒数</span><br><span class="line"><span class="tag">%<span class="selector-tag">e</span></span>  出Core进程对应的可执行文件名</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>程序中开启core dump，通过如下API可以查看和设置RLIMIT_CORE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><p>resource：可能的选择有</p><p>RLIMIT_AS //进程的最大虚内存空间，字节为单位。<br>RLIMIT_CORE //内核转存文件的最大长度。<br>RLIMIT_CPU //最大允许的CPU使用时间，秒为单位。当进程达到软限制，内核将给其发送SIGXCPU信号，这一信号的默认行为是终止进程的执行。然而，可以捕捉信号，处理句柄可将控制返回给主程序。如果进程继续耗费CPU时间，核心会以每秒一次的频率给其发送SIGXCPU信号，直到达到硬限制，那时将给进程发送 SIGKILL信号终止其执行。<br>RLIMIT_DATA //进程数据段的最大值。<br>RLIMIT_FSIZE //进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。<br>RLIMIT_LOCKS //进程可建立的锁和租赁的最大值。<br>RLIMIT_MEMLOCK //进程可锁定在内存中的最大数据量，字节为单位。<br>RLIMIT_MSGQUEUE //进程可为POSIX消息队列分配的最大字节数。<br>RLIMIT_NICE //进程可通过setpriority() 或 nice()调用设置的最大完美值。<br>RLIMIT_NOFILE //指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误。<br>RLIMIT_NPROC //用户可拥有的最大进程数。<br>RLIMIT_RTPRIO //进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。<br>RLIMIT_SIGPENDING //用户可拥有的最大挂起信号数。<br>RLIMIT_STACK //最大的进程堆栈，以字节为单位。</p><p>rlim：描述资源软硬限制的结构体，原型如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回说明：</p><p>成功执行时，返回0。失败返回-1，errno被设为以下的某个值<br>EFAULT：rlim指针指向的空间不可访问<br>EINVAL：参数无效<br>EPERM：增加资源限制值时，权能不允许</p><p>延伸阅读：</p><p>ulimit和setrlimit轻松修改task进程资源上限值</p><p>在linux系统中，Resouce limit指在一个进程的执行过程中，它所能得到的资源的限制，比如进程的core file的最大值，虚拟内存的最大值等。</p><p>Resouce limit的大小可以直接影响进程的执行状况。其有两个最重要的概念：soft limit 和 hard limit。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_cur;　　<span class="comment">//soft limit</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_max;　　<span class="comment">//hard limit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>soft limit是指内核所能支持的资源上限。比如对于RLIMIT_NOFILE(一个进程能打开的最大文件数，内核默认是1024)，soft limit最大也只能达到1024。对于RLIMIT_CORE(core文件的大小，内核不做限制)，soft limit最大能是unlimited。<br>hard limit在资源中只是作为soft limit的上限。当你设置hard limit后，你以后设置的soft limit只能小于hard limit。要说明的是，hard limit只针对非特权进程，也就是进程的有效用户ID(effective user ID)不是0的进程。具有特权级别的进程(具有属性CAP_SYS_RESOURCE)，soft limit则只有内核上限。</p><h2 id="参考程序"><a href="#参考程序" class="headerlink" title="参考程序"></a>参考程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CORE_SIZE   1024 * 1024 * 500</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlmt</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_CORE, &amp;rlmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Before set rlimit CORE dump current is:%d, max is:%d\n"</span>, (<span class="keyword">int</span>)rlmt.rlim_cur, (<span class="keyword">int</span>)rlmt.rlim_max);</span><br><span class="line"></span><br><span class="line">    rlmt.rlim_cur = (<span class="keyword">rlim_t</span>)CORE_SIZE;</span><br><span class="line">    rlmt.rlim_max  = (<span class="keyword">rlim_t</span>)CORE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setrlimit(RLIMIT_CORE, &amp;rlmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_CORE, &amp;rlmt) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"After set rlimit CORE dump current is:%d, max is:%d\n"</span>, (<span class="keyword">int</span>)rlmt.rlim_cur, (<span class="keyword">int</span>)rlmt.rlim_max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*测试非法内存，产生core文件*/</span></span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    *ptr = <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行./main, 生成的core文件如下所示</p><p><img src="/2019/01/30/CoreDump/COreDump1.png" alt="img"></p><h2 id="GDB-调试CORE文件"><a href="#GDB-调试CORE文件" class="headerlink" title="GDB 调试CORE文件"></a>GDB 调试CORE文件</h2><p>产生了 core 文件，我们该如何使用该 Core 文件进行调试呢？Linux 中可以使用 GDB 来调试 core 文件，步骤如下：</p><ul><li>首先，使用 gcc 编译源文件，加上 <code>-g</code> 以增加调试信息；</li><li>按照上面打开 core dump 以使程序异常终止时能生成 core 文件；</li><li>运行程序，当core dump 之后，使用命令 <code>gdb program core</code> 来查看 core 文件，其中 program 为可执行程序名，core 为生成的 core 文件名。<br><img src="/2019/01/30/CoreDump/COreDump2.png" alt="img"></li></ul><h3 id="另一个简单的例子"><a href="#另一个简单的例子" class="headerlink" title="另一个简单的例子"></a>另一个简单的例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = *p;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> func(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译加上调试信息, 运行之后core dump, 使用 gdb 查看 core 文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">guohailin@guohailin:~$ gcc core_demo.c -o core_demo -g</span><br><span class="line">guohailin@guohailin:~$ ./core_demo </span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line"></span><br><span class="line">guohailin@guohailin:~$ gdb core_demo core_demo.core.24816</span><br><span class="line">...</span><br><span class="line">Core was generated by <span class="string">'./core_demo'</span>.</span><br><span class="line">Program terminated with signal 11, Segmentation fault.</span><br><span class="line"><span class="comment">#0  0x080483cd in func (p=0x0) at core_demo.c:5</span></span><br><span class="line">5       int y = *p;</span><br><span class="line">(gdb)  <span class="built_in">where</span></span><br><span class="line"><span class="comment">#0  0x080483cd in func (p=0x0) at core_demo.c:5</span></span><br><span class="line"><span class="comment">#1  0x080483ef in main () at core_demo.c:12</span></span><br><span class="line">(gdb) info frame</span><br><span class="line">Stack level 0, frame at 0xffd590a4:</span><br><span class="line"> eip = 0x80483cd <span class="keyword">in</span> func (core_demo.c:5); saved eip 0x80483ef</span><br><span class="line"> called by frame at 0xffd590c0</span><br><span class="line"> <span class="built_in">source</span> language c.</span><br><span class="line"> Arglist at 0xffd5909c, args: p=0x0</span><br><span class="line"> Locals at 0xffd5909c, Previous frame<span class="string">'s sp is 0xffd590a4</span></span><br><span class="line"><span class="string"> Saved registers:</span></span><br><span class="line"><span class="string">  ebp at 0xffd5909c, eip at 0xffd590a0</span></span><br><span class="line"><span class="string">(gdb)</span></span><br></pre></td></tr></table></figure><p>从上面可以看出,我们可以还原 core_demo 执行时的场景,并使用 <code>where</code> 可以查看当前程序调用函数栈帧, 还可以使用 gdb 中的命令查看寄存器,变量等信息.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-Core-Dump&quot;&gt;&lt;a href=&quot;#Linux-Core-Dump&quot; class=&quot;headerlink&quot; title=&quot;Linux Core Dump&quot;&gt;&lt;/a&gt;Linux Core Dump&lt;/h1&gt;&lt;p&gt;​    当程序运行的过程中异常终止
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Socket编程详解</title>
    <link href="http://www.tangyilong.com/2018/12/25/Socket%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.tangyilong.com/2018/12/25/Socket编程详解/</id>
    <published>2018-12-25T07:18:15.000Z</published>
    <updated>2018-12-25T07:23:37.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket编程详解"><a href="#Socket编程详解" class="headerlink" title="Socket编程详解"></a>Socket编程详解</h1><h2 id="什么是TCP-IP、UDP"><a href="#什么是TCP-IP、UDP" class="headerlink" title="什么是TCP/IP、UDP"></a>什么是TCP/IP、UDP</h2><p>TCP/IP协议族包括运输层、网络层、链路层，而socket所在位置如图，Socket是应用层与TCP/IP协议族通信的中间软件抽象层。</p><p><img src="/2018/12/25/Socket编程详解/1334044170_5136.jpg" alt="1334044170_5136"></p><h2 id="Socket是什么"><a href="#Socket是什么" class="headerlink" title="Socket是什么"></a>Socket是什么</h2><p>socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）.<br>​     说白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，<strong>它是一组接口</strong>。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>​       注意：其实socket也没有层的概念，它只是一个facade设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过socket实现的。</p><p> <strong>基本的SOCKET接口函数</strong></p><p><img src="/2018/12/25/Socket编程详解/1334045011_9586.jpg" alt="1334045011_9586"></p><p> <strong>三次握手</strong></p><p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers)。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>一个完整的三次握手也就是： 请求—应答—再次确认</p><p><img src="/2018/12/25/Socket编程详解/1334045728_5744.png" alt="1334045728_5744"></p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立</p><p><strong>四次握手</strong></p><p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭(half-close)造成的，如图：</p><p><img src="/2018/12/25/Socket编程详解/1334046363_4881.jpg" alt="1334046363_4881"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p><p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p><p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p><p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</p><p>对应函数接口如图：</p><p><img src="/2018/12/25/Socket编程详解/1334046534_7834.png" alt="1334046534_7834"></p><h2 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h2><p>server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File Name: server.c */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_PORT 8000  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>    socket_fd, connect_fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>     <span class="title">servaddr</span>;</span>  </span><br><span class="line">    <span class="keyword">char</span>    buff[<span class="number">4096</span>];  </span><br><span class="line">    <span class="keyword">int</span>     n;  </span><br><span class="line">    <span class="comment">//初始化Socket  </span></span><br><span class="line">    <span class="keyword">if</span>( (socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span> )&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//初始化  </span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//IP地址设置成INADDR_ANY,让系统自动获取本机的IP地址。  </span></span><br><span class="line">    servaddr.sin_port = htons(DEFAULT_PORT);<span class="comment">//设置的端口为DEFAULT_PORT  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将本地地址绑定到所创建的套接字上  </span></span><br><span class="line">    <span class="keyword">if</span>( bind(socket_fd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bind socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//开始监听是否有客户端连接  </span></span><br><span class="line">    <span class="keyword">if</span>( listen(socket_fd, <span class="number">10</span>) == <span class="number">-1</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listen socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"======waiting for client's request======\n"</span>);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line"><span class="comment">//阻塞直到有客户端连接，不然多浪费CPU资源。  </span></span><br><span class="line">        <span class="keyword">if</span>( (connect_fd = accept(socket_fd, (struct sockaddr*)<span class="literal">NULL</span>, <span class="literal">NULL</span>)) == <span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"accept socket error: %s(errno: %d)"</span>,strerror(errno),errno);  </span><br><span class="line">        <span class="keyword">continue</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//接受客户端传过来的数据  </span></span><br><span class="line">    n = recv(connect_fd, buff, MAXLINE, <span class="number">0</span>);  </span><br><span class="line"><span class="comment">//向客户端发送回应数据  </span></span><br><span class="line">    <span class="keyword">if</span>(!fork())&#123; <span class="comment">/*紫禁城*/</span>  </span><br><span class="line">        <span class="keyword">if</span>(send(connect_fd, <span class="string">"Hello,you are connected!\n"</span>, <span class="number">26</span>,<span class="number">0</span>) == <span class="number">-1</span>)  </span><br><span class="line">        perror(<span class="string">"send error"</span>);  </span><br><span class="line">        close(connect_fd);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    buff[n] = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv msg from client: %s\n"</span>, buff);  </span><br><span class="line">    close(connect_fd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(socket_fd);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File Name: client.c */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>    sockfd, n,rec_len;  </span><br><span class="line">    <span class="keyword">char</span>    recvline[<span class="number">4096</span>], sendline[<span class="number">4096</span>];  </span><br><span class="line">    <span class="keyword">char</span>    buf[MAXLINE];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>    <span class="title">servaddr</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usage: ./client &lt;ipaddress&gt;\n"</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_port = htons(<span class="number">8000</span>);  </span><br><span class="line">    <span class="keyword">if</span>( inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"inet_pton error for %s\n"</span>,argv[<span class="number">1</span>]);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>( connect(sockfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send msg to server: \n"</span>);  </span><br><span class="line">    fgets(sendline, <span class="number">4096</span>, <span class="built_in">stdin</span>);  </span><br><span class="line">    <span class="keyword">if</span>( send(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>) &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send msg error: %s(errno: %d)\n"</span>, strerror(errno), errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>((rec_len = recv(sockfd, buf, MAXLINE,<span class="number">0</span>)) == <span class="number">-1</span>) &#123;  </span><br><span class="line">       perror(<span class="string">"recv error"</span>);  </span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    buf[rec_len]  = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Received : %s "</span>,buf);  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inet_pton 是Linux下IP地址转换函数，可以在将IP地址在“点分十进制”和“整数”之间转换 ，是inet_addr的扩展。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;<span class="comment">//转换字符串到网络地址:</span></span><br></pre></td></tr></table></figure><p>第一个参数af是地址族，转换后存在dst中<br>​    af = AF_INET:src为指向字符型的地址，即ASCII的地址的首地址（ddd.ddd.ddd.ddd格式的），函数将该地址转换为in_addr的结构体，并复制在<em>dst中<br>　　af =AF_INET6:src为指向IPV6的地址，函数将该地址转换为in6_addr的结构体，并复制在</em>dst中<br>如果函数出错将返回一个负值，并将errno设置为EAFNOSUPPORT，如果参数af指定的地址族和src格式不对，函数将返回0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Socket编程详解&quot;&gt;&lt;a href=&quot;#Socket编程详解&quot; class=&quot;headerlink&quot; title=&quot;Socket编程详解&quot;&gt;&lt;/a&gt;Socket编程详解&lt;/h1&gt;&lt;h2 id=&quot;什么是TCP-IP、UDP&quot;&gt;&lt;a href=&quot;#什么是TCP-I
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>POSIX消息队列</title>
    <link href="http://www.tangyilong.com/2018/12/25/POSIX%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://www.tangyilong.com/2018/12/25/POSIX消息队列/</id>
    <published>2018-12-25T06:51:03.000Z</published>
    <updated>2018-12-25T06:58:55.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="POSIX消息队列"><a href="#POSIX消息队列" class="headerlink" title="POSIX消息队列"></a>POSIX消息队列</h1><p><a href="https://blog.csdn.net/anonymalias/article/details/9799645" target="_blank" rel="noopener">原文地址</a></p><p>消息队列是Linux IPC中很常用的一种通信方式，它通常用来在不同进程间发送特定格式的消息数据。</p><p>消息队列和之前讨论过的管道和FIFO有很大的区别，主要有以下两点：</p><p>一个进程向消息队列写入消息之前，并不需要某个进程在该队列上等待该消息的到达，而管道和FIFO是相反的，进程向其中写消息时，管道和FIFO必需已经打开来读，那么内核会产生SIGPIPE信号(感谢shanshan_fangfang的指正)。<br> IPC的持续性不同。管道和FIFO是随进程的持续性，当管道和FIFO最后一次关闭发生时，仍在管道和FIFO中的数据会被丢弃。消息队列是随内核的持续性，即一个进程向消息队列写入消息后，然后终止，另外一个进程可以在以后某个时刻打开该队列读取消息。只要内核没有重新自举，消息队列没有被删除。<br>消息队列中的每条消息通常具有以下属性：</p><p>一个表示优先级的整数；<br>消息的数据部分的长度；<br> 消息数据本身；<br>POSIX消息队列的一个可能的设计是一个如下图所示的消息链表，链表头部有消息队列的属性信息。  </p><p><img src="/2018/12/25/POSIX消息队列/20130806231545312.jpg" alt="20130806231545312"></p><h2 id="1-POSIX消息队列的创建和关闭"><a href="#1-POSIX消息队列的创建和关闭" class="headerlink" title="1 POSIX消息队列的创建和关闭"></a>1 POSIX消息队列的创建和关闭</h2><p>POSIX消息队列的创建，关闭和删除用到以下三个函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_open(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, <span class="comment">/* mode_t mode, struct mq_attr *attr */</span>);</span><br><span class="line"><span class="comment">//成功返回消息队列描述符，失败返回-1</span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_close(<span class="keyword">mqd_t</span> mqdes);</span><br><span class="line"><span class="keyword">mqd_t</span> mq_unlink(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>mq_open用于打开或创建一个消息队列。</p><p><strong>name</strong>：表示消息队列的名字，它符合POSIX IPC的名字规则。</p><p><strong>oflag</strong>：表示打开的方式，和open函数的类似。有必须的选项：O_RDONLY，O_WRONLY，O_RDWR，还有可选的选项：O_NONBLOCK，O_CREAT，O_EXCL。</p><p><strong>mode</strong>：是一个可选参数，在oflag中含有O_CREAT标志且消息队列不存在时，才需要提供该参数。表示默认访问权限。可以参考open。</p><p><strong>attr</strong>：也是一个可选参数，在oflag中含有O_CREAT标志且消息队列不存在时才需要。该参数用于给新队列设定某些属性，如果是空指针，那么就采用默认属性。</p><p>mq_open返回值是mqd_t类型的值，被称为消息队列描述符。在Linux 2.6.18中该类型的定义为整型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">mqd_t</span>;</span><br></pre></td></tr></table></figure></p><p>mq_close用于关闭一个消息队列，和文件的close类型，关闭后，消息队列并不从系统中删除。一个进程结束，会自动调用关闭打开着的消息队列。</p><p>mq_unlink用于删除一个消息队列。消息队列创建后只有通过调用该函数或者是内核自举才能进行删除。每个消息队列都有一个保存当前打开着描述符数的引用计数器，和文件一样，因此本函数能够实现类似于unlink函数删除一个文件的机制。</p><p>POSIX消息队列的名字==所创建的真正路径名和具体的系统实现有关==，关于具体POSIX IPC的名字规则可以参考《UNIX 网络编程 卷2：进程间通信》的P14。</p><p>经过测试，在Linux 2.6.18中，所创建的POSIX消息队列不会在文件系统中创建真正的路径名。且POSIX的名字只能以一个’/’开头，名字中不能包含其他的’/’。</p><h2 id="2-POSIX消息队列的属性"><a href="#2-POSIX消息队列的属性" class="headerlink" title="2 POSIX消息队列的属性"></a>2 POSIX消息队列的属性</h2><p>POSIX标准规定消息队列属性mq_attr必须要含有以下四个内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span>    mq_flags <span class="comment">//消息队列的标志：0或O_NONBLOCK,用来表示是否阻塞 </span></span><br><span class="line"><span class="keyword">long</span>    mq_maxmsg  <span class="comment">//消息队列的最大消息数</span></span><br><span class="line"><span class="keyword">long</span>    mq_msgsize  <span class="comment">//消息队列中每个消息的最大字节数</span></span><br><span class="line"><span class="keyword">long</span>    mq_curmsgs  <span class="comment">//消息队列中当前的消息数目</span></span><br></pre></td></tr></table></figure><p>在Linux 2.6.18中mq_attr结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/mqueue.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_flags;      <span class="comment">/* Message queue flags.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_maxmsg;   <span class="comment">/* Maximum number of messages.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_msgsize;   <span class="comment">/* Maximum message size.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_curmsgs;   <span class="comment">/* Number of messages currently queued.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __pad[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>POSIX消息队列的属性设置和获取可以通过下面两个函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_getattr(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *attr);</span><br><span class="line"><span class="keyword">mqd_t</span> mq_setattr(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *newattr, struct mq_attr *oldattr);</span><br><span class="line">                               <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>mq_getattr用于获取当前消息队列的属性，mq_setattr用于设置当前消息队列的属性。其中mq_setattr中的oldattr用于保存修改前的消息队列的属性，可以为空。</p><p>mq_setattr==可以设置的属性只有mq_flags==，用来设置或清除消息队列的非阻塞标志。newattr结构的其他属性被忽略。mq_maxmsg和mq_msgsize属性只能在创建消息队列时通过mq_open来设置。==mq_open只会设置该两个属性，忽略另外两个属性==。mq_curmsgs属性只能被获取而不能被设置。</p><p>下面是测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqID;</span><br><span class="line">    mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (mq_getattr(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"get the message queue attribute error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_flags:"</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_maxmsg:"</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_msgsize:"</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_curmsgs:"</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Linux 2.6.18中执行结果是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure></p><h2 id="3-POSIX消息队列的使用"><a href="#3-POSIX消息队列的使用" class="headerlink" title="3 POSIX消息队列的使用"></a>3 POSIX消息队列的使用</h2><p>POSIX消息队列可以通过以下两个函数来进行发送和接收消息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_send(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> msg_prio);</span><br><span class="line">                     <span class="comment">//成功返回0，出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mqd_t</span> mq_receive(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> *msg_prio);</span><br><span class="line">                     <span class="comment">//成功返回接收到消息的字节数，出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_timedsend(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> msg_prio,</span><br><span class="line">                      <span class="keyword">const</span> struct timespec *abs_timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">mqd_t</span> mq_timedreceive(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> *msg_prio,</span><br><span class="line">                      <span class="keyword">const</span> struct timespec *abs_timeout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>mq_send向消息队列中写入一条消息，mq_receive从消息队列中读取一条消息。</p><p><em>mqdes</em>：消息队列描述符；</p><p><em>msg_ptr</em>：指向消息体缓冲区的指针；</p><p><em>msg_len</em>：消息体的长度，其中==mq_receive的该参数不能小于能写入队列中消息的最大大小，即一定要大于等于该队列的mq_attr结构中mq_msgsize的大小==。如果mq_receive中的msg_len小于该值，就会返回EMSGSIZE错误。POXIS消息队列发送的消息长度可以为0。</p><p><em>msg_prio</em>：消息的优先级；它是一个小于MQ_PRIO_MAX的数，数值越大，优先级越高。POSIX消息队列在调用mq_receive时总是返回队列中最高优先级的最早消息。如果消息不需要设定优先级，那么可以在mq_send是置msg_prio为0，mq_receive的msg_prio置为NULL。</p><p>还有两个XSI定义的扩展接口限时发送和接收消息的函数：mq_timedsend和mq_timedreceive函数。默认情况下mq_send和mq_receive是阻塞进行调用，可以通过mq_setattr来设置为O_NONBLOCK。</p><p>下面是消息队列使用的测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqID;</span><br><span class="line">    mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT | O_EXCL, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">            mq_unlink(<span class="string">"/anonymQueue"</span>);</span><br><span class="line">            mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mq_attr mqAttr;</span><br><span class="line">        mq_getattr(mqID, &amp;mqAttr);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[mqAttr.mq_msgsize];</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mq_receive(mqID, buf, mqAttr.mq_msgsize, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"receive message  failed. "</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"error info:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">     </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"receive message "</span>&lt;&lt;i&lt;&lt;<span class="string">": "</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> msg[] = <span class="string">"yuki"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mq_send(mqID, msg, <span class="keyword">sizeof</span>(msg), i) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"send message "</span>&lt;&lt;i&lt;&lt;<span class="string">" failed. "</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error info:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"send message "</span>&lt;&lt;i&lt;&lt;<span class="string">" success. "</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">     </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Linux 2.6.18下的执行结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">send message 1 success. </span><br><span class="line">receive message 1: yuki</span><br><span class="line">send message 2 success. </span><br><span class="line">receive message 2: yuki</span><br><span class="line">send message 3 success. </span><br><span class="line">receive message 3: yuki</span><br><span class="line">send message 4 success. </span><br><span class="line">receive message 4: yuki</span><br><span class="line">send message 5 success. </span><br><span class="line">receive message 5: yuki</span><br></pre></td></tr></table></figure></p><h2 id="4-POSIX消息队列的限制"><a href="#4-POSIX消息队列的限制" class="headerlink" title="4 POSIX消息队列的限制"></a>4 POSIX消息队列的限制</h2><p>POSIX消息队列本身的限制就是mq_attr中的mq_maxmsg和mq_msgsize，分别用于限定消息队列中的最大消息数和每个消息的最大字节数。在前面已经说过了，这两个参数可以在调用mq_open创建一个消息队列的时候设定。当这个设定是受到系统内核限制的。</p><p>下面是在Linux 2.6.18下shell对启动进程的POSIX消息队列大小的限制：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -a |grep message</span></span><br><span class="line">POSIX <span class="keyword">message</span> queues     (bytes, -q) <span class="number">819200</span></span><br></pre></td></tr></table></figure></p><p>限制大小为800KB，==该大小是整个消息队列的大小，不仅仅是最大消息数*消息的最大大小；还包括消息队列的额外开销==。前面我们知道Linux 2.6.18下POSIX消息队列默认的最大消息数和消息的最大大小分别为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mq_maxmsg</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">mq_msgsize</span> = <span class="number">8192</span></span><br></pre></td></tr></table></figure><p>为了说明上面的限制大小包括消息队列的额外开销，下面是测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqID;</span><br><span class="line">    mq_attr attr;</span><br><span class="line">    attr.mq_maxmsg = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    attr.mq_msgsize = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT | O_EXCL, <span class="number">0666</span>, &amp;attr);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">            mq_unlink(<span class="string">"/anonymQueue"</span>);</span><br><span class="line">            mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, &amp;attr);</span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span>(mqID &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (mq_getattr(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"get the message queue attribute error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_flags:"</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_maxmsg:"</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_msgsize:"</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_curmsgs:"</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面进行创建消息队列时设置最大消息数和消息的最大大小进行测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@idcserver program]<span class="comment"># g++ -g test.cpp -lrt</span></span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 81920</span></span><br><span class="line">open message queue error...Cannot allocate memory</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 80000</span></span><br><span class="line">open message queue error...Cannot allocate memory</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 70000</span></span><br><span class="line">open message queue error...Cannot allocate memory</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 60000</span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:60000</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure></p><p>从上面可以看出消息队列真正存放消息数据的大小是没有819200B的。可以通过修改该限制参数，来改变消息队列的所能容纳消息的数量。可以通过下面方式来修改限制，但这会在shell启动进程结束后失效，可以将设置写入开机启动的脚本中执行，例如.bashrc，rc.local。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@idcserver ~]# ulimit -q 1024000000</span><br><span class="line">[root@idcserver ~]# ulimit -a |grep message</span><br><span class="line">POSIX message queues     (bytes, -q) 1024000000</span><br></pre></td></tr></table></figure><p>下面再次测试可以设置的消息队列的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 81920</span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:81920</span><br><span class="line">mq_curmsgs:0</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 819200</span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:819200</span><br><span class="line">mq_curmsgs:0</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 1000 8192  </span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:1000</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure></p><p>POSIX消息队列在实现上还有另外两个限制：</p><p><strong>MQ_OPEN_MAX</strong>：一个进程能同时打开的消息队列的最大数目，POSIX要求至少为8；</p><p><strong>MQ_PRIO_MAX</strong>：消息的最大优先级，POSIX要求至少为32；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;POSIX消息队列&quot;&gt;&lt;a href=&quot;#POSIX消息队列&quot; class=&quot;headerlink&quot; title=&quot;POSIX消息队列&quot;&gt;&lt;/a&gt;POSIX消息队列&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/anonymalias
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GCC编译过程和动态静态库</title>
    <link href="http://www.tangyilong.com/2018/12/25/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://www.tangyilong.com/2018/12/25/GCC编译过程和动态静态库/</id>
    <published>2018-12-25T06:39:56.000Z</published>
    <updated>2018-12-25T07:14:37.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GCC编译过程和动态静态库"><a href="#GCC编译过程和动态静态库" class="headerlink" title="GCC编译过程和动态静态库"></a>GCC编译过程和动态静态库</h1><p><em>outline</em></p><p>[TOC]</p><p>本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。<strong>库有两种：静态库（.a、.lib）和动态库（.so、.dll）。 windows上对应的是.lib .dll linux上对应的是.a .so</strong></p><p>编译过程：</p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC1.png" alt="img"></p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>之所以成为【静态库】，<strong>是因为在链接阶段，会将汇编生成的目标文件</strong>.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p><p>试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，<strong>那么静态库必定跟</strong>.o文件格式相似<strong>其实一个静态库可以简单看成是</strong>一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：</p><ul><li>静态库对函数库的链接是放在编译时期完成的</li><li>程序在运行时与函数库再无瓜葛，移植方便。</li><li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li></ul><p>Linux静态库命名规范，必须是”lib[your_library_name].a”：lib为前缀，中间是静态库名，扩展名为==.a==</p><p>通过上面的流程可以知道，Linux创建静态库过程如下：</p><p>首先，将代码文件编译成目标文件.o（StaticMath.o）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-c</span> <span class="selector-tag">StaticMath</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">StaticMath</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure><p>注意带参数-c，否则直接编译为可执行文件</p><p>然后，通过ar工具将目标文件打包成.a静态库文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ar</span> <span class="selector-tag">-crv</span> <span class="selector-tag">libstaticmath</span><span class="selector-class">.a</span> <span class="selector-tag">StaticMath</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure><p>生成静态库<strong>libstaticmath.a</strong></p><p><strong>使用</strong></p><p>Linux下使用静态库，只需要在编译的时候，指定静态库的搜索路径（-L选项）、指定静态库名（不需要lib前缀和.a后缀，-l选项）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test<span class="selector-class">.c</span> -L ./ -lstaticmath</span><br></pre></td></tr></table></figure><ul><li><p>-L：表示要连接的库所在目录</p></li><li><p>-I：指定链接时需要的动态库，编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a或.so来确定库的名称。</p></li></ul><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>为什么需要动态库，其实也是静态库的特点导致。</p><p><strong>空间浪费是静态库的一个问题。</strong></p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC2.png" alt="clip_image021[4]"></p><p>另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，<strong>全量更新</strong>）</p><p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。<strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</strong>，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，<strong>增量更新</strong>。</p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC3.png" alt="img"></p><p> <strong>创建动态库</strong> </p><p>动态链接库的名字形式为 libxxx.so，前缀是lib，后缀名为“.so”。</p><ul><li><p>针对于实际库文件，每个共享库都有个特殊的名字“soname”。在程序启动后，程序通过这个名字来告诉动态加载器该载入哪个共享库。</p></li><li><p>在文件系统中，soname仅是一个链接到实际动态库的链接。对于动态库而言，每个库实际上都有另一个名字给编译器来用。它是一个指向实际库镜像文件的链接文件（lib+soname+.so）</p></li></ul><ul><li><p>首先，生成目标文件，此时要加编译器选项-fpic</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-fPIC</span> <span class="selector-tag">-c</span> <span class="selector-tag">DynamicMath</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><p>-fPIC创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</p></li><li><p>然后，生成动态库，此时要加链接器选项-shared</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">g</span>++ <span class="selector-tag">-shared</span> <span class="selector-tag">-o</span> <span class="selector-tag">libdynmath</span><span class="selector-class">.so</span> <span class="selector-tag">DynamicMath</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure><p>-shared指定生成动态链接库。<br>其实上面两个步骤可以合并为一个命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">g</span>++ <span class="selector-tag">-fPIC</span> <span class="selector-tag">-shared</span> <span class="selector-tag">-o</span> <span class="selector-tag">libdynmath</span><span class="selector-class">.so</span> <span class="selector-tag">DynamicMath</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><p><strong>使用动态库</strong></p></li></ul><p>引用动态库编译成可执行文件（跟静态库方式一样）：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ TestDynamicLibrary<span class="selector-class">.cpp</span> -L../DynamicLibrary -ldynmath</span><br></pre></td></tr></table></figure></p><p>然后运行：./a.out，发现竟然报错了！！！</p><p>解决方法：首先使用export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH将当前目录加入LD_LIBRARY_PATH变量中。再次运行</p><p>1) 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader)。<br>2) 对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib 目录找到库文件后将其载入内存。<br>如何让系统能够找到它：<br>如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。<br>如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下：<br>编辑/etc/ld.so.conf文件，加入库文件所在目录的路径<br>运行ldconfig ，该命令会重建/etc/ld.so.cache文件<br>我们将创建的动态库复制到/usr/lib下面，然后运行测试程序。</p><h2 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h2><p>编译过程可以被细分为四个阶段：</p><p><strong>预处理</strong>（ Pre-Processing ）<br><strong>编译</strong>（ Compiling ）<br><strong>汇编</strong>（ Asse mbling ）<br><strong>链接</strong>（ Linking ）</p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC4.png" alt="img"></p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC5.png" alt="img"></p><p><strong>GCC编译过程</strong></p><p>1）gcc 预处理阶段：主要对包含的头文件（＃include ）和宏定义（＃define,#ifdef … ）进行处理。可以使用“gcc -E” 让gcc 在预处理之后停止编译过程，生成 *.i 文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-E</span> <span class="selector-tag">hello</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.i</span></span><br></pre></td></tr></table></figure><p>2）gcc 编译阶段：gcc 首先要检查代码的规范性，是否有语法错误等。以确定代码实际要做的工作，在检查无误后，gcc 把代码翻译成汇编语言。用户可以使用-S 选项进行查看，该选项只进<br>行编译而不进行汇编，生成汇编代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-S</span> <span class="selector-tag">hello</span><span class="selector-class">.i</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.s</span></span><br></pre></td></tr></table></figure><p>3）gcc 汇编阶段：生成目标代码 <em>.o ；有两种方式：使用 gcc 直接从源代码生成目标代码 gcc -c </em>.s -o <em>.o 以及使用汇编器从汇编代码生成目标代码 as </em>.s -o *.o</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello<span class="selector-class">.s</span> -o hello.o</span><br><span class="line">as hello<span class="selector-class">.s</span> -o hello.o</span><br></pre></td></tr></table></figure><p>也可以直接使用as <em>.s, 将<strong>执行汇编、链接过程生成可执行文件a.out</strong>, 可以像上面使用<strong>-o 选项</strong>指定输出文件的格式。<br>4）gcc 链接阶段：生成可执行文件；可以生成的可执行文件格式有： a.out/</em>/,当然可能还有其它格式。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello<span class="selector-class">.o</span>     生成可执行文件 <span class="selector-tag">a</span>.out</span><br><span class="line">gcc hello<span class="selector-class">.o</span> -o hello        生成可执行文件 hello</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GCC编译过程和动态静态库&quot;&gt;&lt;a href=&quot;#GCC编译过程和动态静态库&quot; class=&quot;headerlink&quot; title=&quot;GCC编译过程和动态静态库&quot;&gt;&lt;/a&gt;GCC编译过程和动态静态库&lt;/h1&gt;&lt;p&gt;&lt;em&gt;outline&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;[T
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建Hexo执行 hexo 命令报错:ERROR Local hexo not found in xxx 二种解决方案</title>
    <link href="http://www.tangyilong.com/2018/11/29/ERROR-Local-hexo-not-found-in-Hexo/"/>
    <id>http://www.tangyilong.com/2018/11/29/ERROR-Local-hexo-not-found-in-Hexo/</id>
    <published>2018-11-29T11:57:29.000Z</published>
    <updated>2018-11-29T13:02:01.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案"><a href="#搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案" class="headerlink" title="搭建Hexo执行 hexo 命令报错:ERROR Local hexo not found in xxx 二种解决方案"></a>搭建Hexo执行 hexo 命令报错:ERROR Local hexo not found in xxx 二种解决方案</h1><h2 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h2><p>当输入hexo命令的时候会出现下面这张情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@:hexo_web# hexo -v</span><br><span class="line">ERROR Local hexo not found in ~/share/Hexo/hexo_web</span><br><span class="line">ERROR Try running: 'npm install hexo --save'</span><br></pre></td></tr></table></figure><p>导致这个原因为在自己的博客文件夹中,.gitignore文件中添加了node_modules/,导致更新的时候,这个文件夹被忽略,没有被更新上去。</p><p>解决方案:</p><p>​    1.cmd进入博客当前文件夹路径</p><p>​    2.执行 npm install</p><p>​    3.执行 hexo server</p><p>​    4.执行成功后,再到博客下的git中执行 hexo 命令 发现可以执行成功。</p><h2 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h2><p>首先是我是在网上找到的第一种方案，但是没有效果，所以就自己试着寻找一些蛛丝马迹</p><p>首先你在你的hexo目录下面使用hexo命令是不成功的</p><p>但是呢，当你退到上层目录的时候，hexo命令却是可以正常使用的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@:/home/share/Hexo/hexo_web# hexo -v</span><br><span class="line">ERROR Local hexo not found in ~/share/Hexo/hexo_web</span><br><span class="line">ERROR Try running: 'npm install hexo --save'</span><br><span class="line">root@:/home/share/Hexo/hexo_web# cd ..</span><br><span class="line">root@:/home/share/Hexo# hexo -v</span><br><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Linux 4.15.0-39-generic linux x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 4.2.6                      &lt;================</span><br><span class="line">v8: 6.8.275.32-node.36</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.14.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0i</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure><p>我注意到有一个地方不太对，那就是node的版本是4.2.6，版本太老了。</p><p>所以我就试着更新node的版本，把node的版本更新到最新版10.13.0</p><p>更新之后我们再进入到hexo的博客目录下面去执行命令，查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@:/home/share/Hexo/hexo_web# hexo -v</span><br><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Linux 4.15.0-39-generic linux x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.13.0              &lt;==========================</span><br><span class="line">v8: 6.8.275.32-node.36</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.14.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0i</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure><p>附上手动更新node的方法</p><h2 id="下载nodj二进制源码：xz结尾的压缩文件"><a href="#下载nodj二进制源码：xz结尾的压缩文件" class="headerlink" title="下载nodj二进制源码：xz结尾的压缩文件"></a>下载nodj二进制源码：xz结尾的压缩文件</h2><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node官网</a></p><p>注意：选择合适版本，我使用的是ubuntu,所以选择linux包下载下来就是源码，解压之后就存在node和npm。无需重复编译。</p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf node-v9.5.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在底部添加</span><br><span class="line">export NODE_HOME=/opt/nodejs/node-v11.1.0-linux-x64/bin</span><br><span class="line">export PATH=$NODE_HOME:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>激活修改</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 验证</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果全局安装pm2包，可以验证</span><br><span class="line">pm2 list</span><br></pre></td></tr></table></figure><p>那么我不是这么使用的，我是直接复制粘贴覆盖原来的node文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@:# which node</span><br><span class="line">/usr/bin/node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 到下载的最新node目录下面</span><br><span class="line"><span class="meta">#</span> 将bin里面的node拷贝过去</span><br><span class="line">root@:/opt/node-v10.13.0-linux-x64/bin# cp ./node /usr/bin/node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 验证</span><br><span class="line">root@:# node -v</span><br><span class="line">v10.13.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案&quot;&gt;&lt;a href=&quot;#搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案&quot; 
      
    
    </summary>
    
    
  </entry>
  
</feed>
