<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>as3522</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tangyilong.com/"/>
  <updated>2018-12-25T07:23:37.149Z</updated>
  <id>http://www.tangyilong.com/</id>
  
  <author>
    <name>as3522</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Socket编程详解</title>
    <link href="http://www.tangyilong.com/2018/12/25/Socket%E7%BC%96%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.tangyilong.com/2018/12/25/Socket编程详解/</id>
    <published>2018-12-25T07:18:15.000Z</published>
    <updated>2018-12-25T07:23:37.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socket编程详解"><a href="#Socket编程详解" class="headerlink" title="Socket编程详解"></a>Socket编程详解</h1><h2 id="什么是TCP-IP、UDP"><a href="#什么是TCP-IP、UDP" class="headerlink" title="什么是TCP/IP、UDP"></a>什么是TCP/IP、UDP</h2><p>TCP/IP协议族包括运输层、网络层、链路层，而socket所在位置如图，Socket是应用层与TCP/IP协议族通信的中间软件抽象层。</p><p><img src="/2018/12/25/Socket编程详解/1334044170_5136.jpg" alt="1334044170_5136"></p><h2 id="Socket是什么"><a href="#Socket是什么" class="headerlink" title="Socket是什么"></a>Socket是什么</h2><p>socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）.<br>​     说白了Socket是应用层与TCP/IP协议族通信的中间软件抽象层，<strong>它是一组接口</strong>。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>​       注意：其实socket也没有层的概念，它只是一个facade设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过socket实现的。</p><p> <strong>基本的SOCKET接口函数</strong></p><p><img src="/2018/12/25/Socket编程详解/1334045011_9586.jpg" alt="1334045011_9586"></p><p> <strong>三次握手</strong></p><p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；SYN：同步序列编号(Synchronize Sequence Numbers)。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>一个完整的三次握手也就是： 请求—应答—再次确认</p><p><img src="/2018/12/25/Socket编程详解/1334045728_5744.png" alt="1334045728_5744"></p><p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立</p><p><strong>四次握手</strong></p><p>建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭(half-close)造成的，如图：</p><p><img src="/2018/12/25/Socket编程详解/1334046363_4881.jpg" alt="1334046363_4881"></p><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</p><p>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。</p><p>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</p><p>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</p><p>对应函数接口如图：</p><p><img src="/2018/12/25/Socket编程详解/1334046534_7834.png" alt="1334046534_7834"></p><h2 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h2><p>server</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File Name: server.c */</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_PORT 8000  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>    socket_fd, connect_fd;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>     <span class="title">servaddr</span>;</span>  </span><br><span class="line">    <span class="keyword">char</span>    buff[<span class="number">4096</span>];  </span><br><span class="line">    <span class="keyword">int</span>     n;  </span><br><span class="line">    <span class="comment">//初始化Socket  </span></span><br><span class="line">    <span class="keyword">if</span>( (socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span> )&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//初始化  </span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//IP地址设置成INADDR_ANY,让系统自动获取本机的IP地址。  </span></span><br><span class="line">    servaddr.sin_port = htons(DEFAULT_PORT);<span class="comment">//设置的端口为DEFAULT_PORT  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将本地地址绑定到所创建的套接字上  </span></span><br><span class="line">    <span class="keyword">if</span>( bind(socket_fd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"bind socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//开始监听是否有客户端连接  </span></span><br><span class="line">    <span class="keyword">if</span>( listen(socket_fd, <span class="number">10</span>) == <span class="number">-1</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"listen socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"======waiting for client's request======\n"</span>);  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line"><span class="comment">//阻塞直到有客户端连接，不然多浪费CPU资源。  </span></span><br><span class="line">        <span class="keyword">if</span>( (connect_fd = accept(socket_fd, (struct sockaddr*)<span class="literal">NULL</span>, <span class="literal">NULL</span>)) == <span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"accept socket error: %s(errno: %d)"</span>,strerror(errno),errno);  </span><br><span class="line">        <span class="keyword">continue</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//接受客户端传过来的数据  </span></span><br><span class="line">    n = recv(connect_fd, buff, MAXLINE, <span class="number">0</span>);  </span><br><span class="line"><span class="comment">//向客户端发送回应数据  </span></span><br><span class="line">    <span class="keyword">if</span>(!fork())&#123; <span class="comment">/*紫禁城*/</span>  </span><br><span class="line">        <span class="keyword">if</span>(send(connect_fd, <span class="string">"Hello,you are connected!\n"</span>, <span class="number">26</span>,<span class="number">0</span>) == <span class="number">-1</span>)  </span><br><span class="line">        perror(<span class="string">"send error"</span>);  </span><br><span class="line">        close(connect_fd);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    buff[n] = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"recv msg from client: %s\n"</span>, buff);  </span><br><span class="line">    close(connect_fd);  </span><br><span class="line">    &#125;  </span><br><span class="line">    close(socket_fd);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File Name: client.c */</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>    sockfd, n,rec_len;  </span><br><span class="line">    <span class="keyword">char</span>    recvline[<span class="number">4096</span>], sendline[<span class="number">4096</span>];  </span><br><span class="line">    <span class="keyword">char</span>    buf[MAXLINE];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>    <span class="title">servaddr</span>;</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>( argc != <span class="number">2</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usage: ./client &lt;ipaddress&gt;\n"</span>);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));  </span><br><span class="line">    servaddr.sin_family = AF_INET;  </span><br><span class="line">    servaddr.sin_port = htons(<span class="number">8000</span>);  </span><br><span class="line">    <span class="keyword">if</span>( inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"inet_pton error for %s\n"</span>,argv[<span class="number">1</span>]);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>( connect(sockfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"connect error: %s(errno: %d)\n"</span>,strerror(errno),errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send msg to server: \n"</span>);  </span><br><span class="line">    fgets(sendline, <span class="number">4096</span>, <span class="built_in">stdin</span>);  </span><br><span class="line">    <span class="keyword">if</span>( send(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>) &lt; <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"send msg error: %s(errno: %d)\n"</span>, strerror(errno), errno);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>((rec_len = recv(sockfd, buf, MAXLINE,<span class="number">0</span>)) == <span class="number">-1</span>) &#123;  </span><br><span class="line">       perror(<span class="string">"recv error"</span>);  </span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    buf[rec_len]  = <span class="string">'\0'</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Received : %s "</span>,buf);  </span><br><span class="line">    close(sockfd);  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inet_pton 是Linux下IP地址转换函数，可以在将IP地址在“点分十进制”和“整数”之间转换 ，是inet_addr的扩展。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;<span class="comment">//转换字符串到网络地址:</span></span><br></pre></td></tr></table></figure><p>第一个参数af是地址族，转换后存在dst中<br>​    af = AF_INET:src为指向字符型的地址，即ASCII的地址的首地址（ddd.ddd.ddd.ddd格式的），函数将该地址转换为in_addr的结构体，并复制在<em>dst中<br>　　af =AF_INET6:src为指向IPV6的地址，函数将该地址转换为in6_addr的结构体，并复制在</em>dst中<br>如果函数出错将返回一个负值，并将errno设置为EAFNOSUPPORT，如果参数af指定的地址族和src格式不对，函数将返回0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Socket编程详解&quot;&gt;&lt;a href=&quot;#Socket编程详解&quot; class=&quot;headerlink&quot; title=&quot;Socket编程详解&quot;&gt;&lt;/a&gt;Socket编程详解&lt;/h1&gt;&lt;h2 id=&quot;什么是TCP-IP、UDP&quot;&gt;&lt;a href=&quot;#什么是TCP-I
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>POSIX消息队列</title>
    <link href="http://www.tangyilong.com/2018/12/25/POSIX%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://www.tangyilong.com/2018/12/25/POSIX消息队列/</id>
    <published>2018-12-25T06:51:03.000Z</published>
    <updated>2018-12-25T06:58:55.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="POSIX消息队列"><a href="#POSIX消息队列" class="headerlink" title="POSIX消息队列"></a>POSIX消息队列</h1><p><a href="https://blog.csdn.net/anonymalias/article/details/9799645" target="_blank" rel="noopener">原文地址</a></p><p>消息队列是Linux IPC中很常用的一种通信方式，它通常用来在不同进程间发送特定格式的消息数据。</p><p>消息队列和之前讨论过的管道和FIFO有很大的区别，主要有以下两点：</p><p>一个进程向消息队列写入消息之前，并不需要某个进程在该队列上等待该消息的到达，而管道和FIFO是相反的，进程向其中写消息时，管道和FIFO必需已经打开来读，那么内核会产生SIGPIPE信号(感谢shanshan_fangfang的指正)。<br> IPC的持续性不同。管道和FIFO是随进程的持续性，当管道和FIFO最后一次关闭发生时，仍在管道和FIFO中的数据会被丢弃。消息队列是随内核的持续性，即一个进程向消息队列写入消息后，然后终止，另外一个进程可以在以后某个时刻打开该队列读取消息。只要内核没有重新自举，消息队列没有被删除。<br>消息队列中的每条消息通常具有以下属性：</p><p>一个表示优先级的整数；<br>消息的数据部分的长度；<br> 消息数据本身；<br>POSIX消息队列的一个可能的设计是一个如下图所示的消息链表，链表头部有消息队列的属性信息。  </p><p><img src="/2018/12/25/POSIX消息队列/20130806231545312.jpg" alt="20130806231545312"></p><h2 id="1-POSIX消息队列的创建和关闭"><a href="#1-POSIX消息队列的创建和关闭" class="headerlink" title="1 POSIX消息队列的创建和关闭"></a>1 POSIX消息队列的创建和关闭</h2><p>POSIX消息队列的创建，关闭和删除用到以下三个函数接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_open(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag, <span class="comment">/* mode_t mode, struct mq_attr *attr */</span>);</span><br><span class="line"><span class="comment">//成功返回消息队列描述符，失败返回-1</span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_close(<span class="keyword">mqd_t</span> mqdes);</span><br><span class="line"><span class="keyword">mqd_t</span> mq_unlink(<span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>mq_open用于打开或创建一个消息队列。</p><p><strong>name</strong>：表示消息队列的名字，它符合POSIX IPC的名字规则。</p><p><strong>oflag</strong>：表示打开的方式，和open函数的类似。有必须的选项：O_RDONLY，O_WRONLY，O_RDWR，还有可选的选项：O_NONBLOCK，O_CREAT，O_EXCL。</p><p><strong>mode</strong>：是一个可选参数，在oflag中含有O_CREAT标志且消息队列不存在时，才需要提供该参数。表示默认访问权限。可以参考open。</p><p><strong>attr</strong>：也是一个可选参数，在oflag中含有O_CREAT标志且消息队列不存在时才需要。该参数用于给新队列设定某些属性，如果是空指针，那么就采用默认属性。</p><p>mq_open返回值是mqd_t类型的值，被称为消息队列描述符。在Linux 2.6.18中该类型的定义为整型：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">mqd_t</span>;</span><br></pre></td></tr></table></figure></p><p>mq_close用于关闭一个消息队列，和文件的close类型，关闭后，消息队列并不从系统中删除。一个进程结束，会自动调用关闭打开着的消息队列。</p><p>mq_unlink用于删除一个消息队列。消息队列创建后只有通过调用该函数或者是内核自举才能进行删除。每个消息队列都有一个保存当前打开着描述符数的引用计数器，和文件一样，因此本函数能够实现类似于unlink函数删除一个文件的机制。</p><p>POSIX消息队列的名字==所创建的真正路径名和具体的系统实现有关==，关于具体POSIX IPC的名字规则可以参考《UNIX 网络编程 卷2：进程间通信》的P14。</p><p>经过测试，在Linux 2.6.18中，所创建的POSIX消息队列不会在文件系统中创建真正的路径名。且POSIX的名字只能以一个’/’开头，名字中不能包含其他的’/’。</p><h2 id="2-POSIX消息队列的属性"><a href="#2-POSIX消息队列的属性" class="headerlink" title="2 POSIX消息队列的属性"></a>2 POSIX消息队列的属性</h2><p>POSIX标准规定消息队列属性mq_attr必须要含有以下四个内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span>    mq_flags <span class="comment">//消息队列的标志：0或O_NONBLOCK,用来表示是否阻塞 </span></span><br><span class="line"><span class="keyword">long</span>    mq_maxmsg  <span class="comment">//消息队列的最大消息数</span></span><br><span class="line"><span class="keyword">long</span>    mq_msgsize  <span class="comment">//消息队列中每个消息的最大字节数</span></span><br><span class="line"><span class="keyword">long</span>    mq_curmsgs  <span class="comment">//消息队列中当前的消息数目</span></span><br></pre></td></tr></table></figure><p>在Linux 2.6.18中mq_attr结构的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/mqueue.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_flags;      <span class="comment">/* Message queue flags.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_maxmsg;   <span class="comment">/* Maximum number of messages.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_msgsize;   <span class="comment">/* Maximum message size.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> mq_curmsgs;   <span class="comment">/* Number of messages currently queued.  */</span></span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __pad[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>POSIX消息队列的属性设置和获取可以通过下面两个函数实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_getattr(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *attr);</span><br><span class="line"><span class="keyword">mqd_t</span> mq_setattr(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *newattr, struct mq_attr *oldattr);</span><br><span class="line">                               <span class="comment">//成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure><p>mq_getattr用于获取当前消息队列的属性，mq_setattr用于设置当前消息队列的属性。其中mq_setattr中的oldattr用于保存修改前的消息队列的属性，可以为空。</p><p>mq_setattr==可以设置的属性只有mq_flags==，用来设置或清除消息队列的非阻塞标志。newattr结构的其他属性被忽略。mq_maxmsg和mq_msgsize属性只能在创建消息队列时通过mq_open来设置。==mq_open只会设置该两个属性，忽略另外两个属性==。mq_curmsgs属性只能被获取而不能被设置。</p><p>下面是测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqID;</span><br><span class="line">    mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (mq_getattr(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"get the message queue attribute error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_flags:"</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_maxmsg:"</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_msgsize:"</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_curmsgs:"</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Linux 2.6.18中执行结果是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure></p><h2 id="3-POSIX消息队列的使用"><a href="#3-POSIX消息队列的使用" class="headerlink" title="3 POSIX消息队列的使用"></a>3 POSIX消息队列的使用</h2><p>POSIX消息队列可以通过以下两个函数来进行发送和接收消息：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_send(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> msg_prio);</span><br><span class="line">                     <span class="comment">//成功返回0，出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mqd_t</span> mq_receive(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> *msg_prio);</span><br><span class="line">                     <span class="comment">//成功返回接收到消息的字节数，出错返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="keyword">mqd_t</span> mq_timedsend(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> msg_prio,</span><br><span class="line">                      <span class="keyword">const</span> struct timespec *abs_timeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">mqd_t</span> mq_timedreceive(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">char</span> *msg_ptr,</span><br><span class="line">                      <span class="keyword">size_t</span> msg_len, <span class="keyword">unsigned</span> *msg_prio,</span><br><span class="line">                      <span class="keyword">const</span> struct timespec *abs_timeout);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>mq_send向消息队列中写入一条消息，mq_receive从消息队列中读取一条消息。</p><p><em>mqdes</em>：消息队列描述符；</p><p><em>msg_ptr</em>：指向消息体缓冲区的指针；</p><p><em>msg_len</em>：消息体的长度，其中==mq_receive的该参数不能小于能写入队列中消息的最大大小，即一定要大于等于该队列的mq_attr结构中mq_msgsize的大小==。如果mq_receive中的msg_len小于该值，就会返回EMSGSIZE错误。POXIS消息队列发送的消息长度可以为0。</p><p><em>msg_prio</em>：消息的优先级；它是一个小于MQ_PRIO_MAX的数，数值越大，优先级越高。POSIX消息队列在调用mq_receive时总是返回队列中最高优先级的最早消息。如果消息不需要设定优先级，那么可以在mq_send是置msg_prio为0，mq_receive的msg_prio置为NULL。</p><p>还有两个XSI定义的扩展接口限时发送和接收消息的函数：mq_timedsend和mq_timedreceive函数。默认情况下mq_send和mq_receive是阻塞进行调用，可以通过mq_setattr来设置为O_NONBLOCK。</p><p>下面是消息队列使用的测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqID;</span><br><span class="line">    mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT | O_EXCL, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">            mq_unlink(<span class="string">"/anonymQueue"</span>);</span><br><span class="line">            mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mq_attr mqAttr;</span><br><span class="line">        mq_getattr(mqID, &amp;mqAttr);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">char</span> *buf = <span class="keyword">new</span> <span class="keyword">char</span>[mqAttr.mq_msgsize];</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mq_receive(mqID, buf, mqAttr.mq_msgsize, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"receive message  failed. "</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"error info:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">     </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"receive message "</span>&lt;&lt;i&lt;&lt;<span class="string">": "</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">char</span> msg[] = <span class="string">"yuki"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mq_send(mqID, msg, <span class="keyword">sizeof</span>(msg), i) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"send message "</span>&lt;&lt;i&lt;&lt;<span class="string">" failed. "</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error info:"</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"send message "</span>&lt;&lt;i&lt;&lt;<span class="string">" success. "</span>&lt;&lt;<span class="built_in">endl</span>;   </span><br><span class="line">     </span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Linux 2.6.18下的执行结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">send message 1 success. </span><br><span class="line">receive message 1: yuki</span><br><span class="line">send message 2 success. </span><br><span class="line">receive message 2: yuki</span><br><span class="line">send message 3 success. </span><br><span class="line">receive message 3: yuki</span><br><span class="line">send message 4 success. </span><br><span class="line">receive message 4: yuki</span><br><span class="line">send message 5 success. </span><br><span class="line">receive message 5: yuki</span><br></pre></td></tr></table></figure></p><h2 id="4-POSIX消息队列的限制"><a href="#4-POSIX消息队列的限制" class="headerlink" title="4 POSIX消息队列的限制"></a>4 POSIX消息队列的限制</h2><p>POSIX消息队列本身的限制就是mq_attr中的mq_maxmsg和mq_msgsize，分别用于限定消息队列中的最大消息数和每个消息的最大字节数。在前面已经说过了，这两个参数可以在调用mq_open创建一个消息队列的时候设定。当这个设定是受到系统内核限制的。</p><p>下面是在Linux 2.6.18下shell对启动进程的POSIX消息队列大小的限制：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ulimit -a |grep message</span></span><br><span class="line">POSIX <span class="keyword">message</span> queues     (bytes, -q) <span class="number">819200</span></span><br></pre></td></tr></table></figure></p><p>限制大小为800KB，==该大小是整个消息队列的大小，不仅仅是最大消息数*消息的最大大小；还包括消息队列的额外开销==。前面我们知道Linux 2.6.18下POSIX消息队列默认的最大消息数和消息的最大大小分别为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mq_maxmsg</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">mq_msgsize</span> = <span class="number">8192</span></span><br></pre></td></tr></table></figure><p>为了说明上面的限制大小包括消息队列的额外开销，下面是测试代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">mqd_t</span> mqID;</span><br><span class="line">    mq_attr attr;</span><br><span class="line">    attr.mq_maxmsg = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    attr.mq_msgsize = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT | O_EXCL, <span class="number">0666</span>, &amp;attr);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (mqID &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EEXIST)</span><br><span class="line">        &#123;</span><br><span class="line">            mq_unlink(<span class="string">"/anonymQueue"</span>);</span><br><span class="line">            mqID = mq_open(<span class="string">"/anonymQueue"</span>, O_RDWR | O_CREAT, <span class="number">0666</span>, &amp;attr);</span><br><span class="line">     </span><br><span class="line">            <span class="keyword">if</span>(mqID &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"open message queue error..."</span>&lt;&lt;strerror(errno)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    mq_attr mqAttr;</span><br><span class="line">    <span class="keyword">if</span> (mq_getattr(mqID, &amp;mqAttr) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"get the message queue attribute error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_flags:"</span>&lt;&lt;mqAttr.mq_flags&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_maxmsg:"</span>&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_msgsize:"</span>&lt;&lt;mqAttr.mq_msgsize&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"mq_curmsgs:"</span>&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面进行创建消息队列时设置最大消息数和消息的最大大小进行测试：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@idcserver program]<span class="comment"># g++ -g test.cpp -lrt</span></span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 81920</span></span><br><span class="line">open message queue error...Cannot allocate memory</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 80000</span></span><br><span class="line">open message queue error...Cannot allocate memory</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 70000</span></span><br><span class="line">open message queue error...Cannot allocate memory</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 60000</span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:60000</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure></p><p>从上面可以看出消息队列真正存放消息数据的大小是没有819200B的。可以通过修改该限制参数，来改变消息队列的所能容纳消息的数量。可以通过下面方式来修改限制，但这会在shell启动进程结束后失效，可以将设置写入开机启动的脚本中执行，例如.bashrc，rc.local。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@idcserver ~]# ulimit -q 1024000000</span><br><span class="line">[root@idcserver ~]# ulimit -a |grep message</span><br><span class="line">POSIX message queues     (bytes, -q) 1024000000</span><br></pre></td></tr></table></figure><p>下面再次测试可以设置的消息队列的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 81920</span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:81920</span><br><span class="line">mq_curmsgs:0</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 10 819200</span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:10</span><br><span class="line">mq_msgsize:819200</span><br><span class="line">mq_curmsgs:0</span><br><span class="line">[root@idcserver program]<span class="comment"># ./a.out 1000 8192  </span></span><br><span class="line">mq_flags:0</span><br><span class="line">mq_maxmsg:1000</span><br><span class="line">mq_msgsize:8192</span><br><span class="line">mq_curmsgs:0</span><br></pre></td></tr></table></figure></p><p>POSIX消息队列在实现上还有另外两个限制：</p><p><strong>MQ_OPEN_MAX</strong>：一个进程能同时打开的消息队列的最大数目，POSIX要求至少为8；</p><p><strong>MQ_PRIO_MAX</strong>：消息的最大优先级，POSIX要求至少为32；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;POSIX消息队列&quot;&gt;&lt;a href=&quot;#POSIX消息队列&quot; class=&quot;headerlink&quot; title=&quot;POSIX消息队列&quot;&gt;&lt;/a&gt;POSIX消息队列&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/anonymalias
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GCC编译过程和动态静态库</title>
    <link href="http://www.tangyilong.com/2018/12/25/GCC%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://www.tangyilong.com/2018/12/25/GCC编译过程和动态静态库/</id>
    <published>2018-12-25T06:39:56.000Z</published>
    <updated>2018-12-25T07:14:37.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GCC编译过程和动态静态库"><a href="#GCC编译过程和动态静态库" class="headerlink" title="GCC编译过程和动态静态库"></a>GCC编译过程和动态静态库</h1><p><em>outline</em></p><p>[TOC]</p><p>本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。<strong>库有两种：静态库（.a、.lib）和动态库（.so、.dll）。 windows上对应的是.lib .dll linux上对应的是.a .so</strong></p><p>编译过程：</p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC1.png" alt="img"></p><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>之所以成为【静态库】，<strong>是因为在链接阶段，会将汇编生成的目标文件</strong>.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p><p>试想一下，静态库与汇编生成的目标文件一起链接为可执行文件，<strong>那么静态库必定跟</strong>.o文件格式相似<strong>其实一个静态库可以简单看成是</strong>一组目标文件（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。静态库特点总结：</p><ul><li>静态库对函数库的链接是放在编译时期完成的</li><li>程序在运行时与函数库再无瓜葛，移植方便。</li><li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li></ul><p>Linux静态库命名规范，必须是”lib[your_library_name].a”：lib为前缀，中间是静态库名，扩展名为==.a==</p><p>通过上面的流程可以知道，Linux创建静态库过程如下：</p><p>首先，将代码文件编译成目标文件.o（StaticMath.o）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-c</span> <span class="selector-tag">StaticMath</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">StaticMath</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure><p>注意带参数-c，否则直接编译为可执行文件</p><p>然后，通过ar工具将目标文件打包成.a静态库文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ar</span> <span class="selector-tag">-crv</span> <span class="selector-tag">libstaticmath</span><span class="selector-class">.a</span> <span class="selector-tag">StaticMath</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure><p>生成静态库<strong>libstaticmath.a</strong></p><p><strong>使用</strong></p><p>Linux下使用静态库，只需要在编译的时候，指定静态库的搜索路径（-L选项）、指定静态库名（不需要lib前缀和.a后缀，-l选项）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test<span class="selector-class">.c</span> -L ./ -lstaticmath</span><br></pre></td></tr></table></figure><ul><li><p>-L：表示要连接的库所在目录</p></li><li><p>-I：指定链接时需要的动态库，编译器查找动态连接库时有隐含的命名规则，即在给出的名字前面加上lib，后面加上.a或.so来确定库的名称。</p></li></ul><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>为什么需要动态库，其实也是静态库的特点导致。</p><p><strong>空间浪费是静态库的一个问题。</strong></p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC2.png" alt="clip_image021[4]"></p><p>另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，<strong>全量更新</strong>）</p><p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。<strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</strong>，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，<strong>增量更新</strong>。</p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC3.png" alt="img"></p><p> <strong>创建动态库</strong> </p><p>动态链接库的名字形式为 libxxx.so，前缀是lib，后缀名为“.so”。</p><ul><li><p>针对于实际库文件，每个共享库都有个特殊的名字“soname”。在程序启动后，程序通过这个名字来告诉动态加载器该载入哪个共享库。</p></li><li><p>在文件系统中，soname仅是一个链接到实际动态库的链接。对于动态库而言，每个库实际上都有另一个名字给编译器来用。它是一个指向实际库镜像文件的链接文件（lib+soname+.so）</p></li></ul><ul><li><p>首先，生成目标文件，此时要加编译器选项-fpic</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-fPIC</span> <span class="selector-tag">-c</span> <span class="selector-tag">DynamicMath</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><p>-fPIC创建与地址无关的编译程序（pic，position independent code），是为了能够在多个应用程序间共享。</p></li><li><p>然后，生成动态库，此时要加链接器选项-shared</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">g</span>++ <span class="selector-tag">-shared</span> <span class="selector-tag">-o</span> <span class="selector-tag">libdynmath</span><span class="selector-class">.so</span> <span class="selector-tag">DynamicMath</span><span class="selector-class">.o</span></span><br></pre></td></tr></table></figure><p>-shared指定生成动态链接库。<br>其实上面两个步骤可以合并为一个命令：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">g</span>++ <span class="selector-tag">-fPIC</span> <span class="selector-tag">-shared</span> <span class="selector-tag">-o</span> <span class="selector-tag">libdynmath</span><span class="selector-class">.so</span> <span class="selector-tag">DynamicMath</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure><p><strong>使用动态库</strong></p></li></ul><p>引用动态库编译成可执行文件（跟静态库方式一样）：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ TestDynamicLibrary<span class="selector-class">.cpp</span> -L../DynamicLibrary -ldynmath</span><br></pre></td></tr></table></figure></p><p>然后运行：./a.out，发现竟然报错了！！！</p><p>解决方法：首先使用export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH将当前目录加入LD_LIBRARY_PATH变量中。再次运行</p><p>1) 当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统动态载入器(dynamic linker/loader)。<br>2) 对于elf格式的可执行程序，是由ld-linux.so*来完成的，它先后搜索elf文件的DT_RPATH段—环境变量LD_LIBRARY_PATH—/etc/ld.so.cache文件列表—/lib/,/usr/lib 目录找到库文件后将其载入内存。<br>如何让系统能够找到它：<br>如果安装在/lib或者/usr/lib下，那么ld默认能够找到，无需其他操作。<br>如果安装在其他目录，需要将其添加到/etc/ld.so.cache文件中，步骤如下：<br>编辑/etc/ld.so.conf文件，加入库文件所在目录的路径<br>运行ldconfig ，该命令会重建/etc/ld.so.cache文件<br>我们将创建的动态库复制到/usr/lib下面，然后运行测试程序。</p><h2 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h2><p>编译过程可以被细分为四个阶段：</p><p><strong>预处理</strong>（ Pre-Processing ）<br><strong>编译</strong>（ Compiling ）<br><strong>汇编</strong>（ Asse mbling ）<br><strong>链接</strong>（ Linking ）</p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC4.png" alt="img"></p><p><img src="/2018/12/25/GCC编译过程和动态静态库/GCC5.png" alt="img"></p><p><strong>GCC编译过程</strong></p><p>1）gcc 预处理阶段：主要对包含的头文件（＃include ）和宏定义（＃define,#ifdef … ）进行处理。可以使用“gcc -E” 让gcc 在预处理之后停止编译过程，生成 *.i 文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-E</span> <span class="selector-tag">hello</span><span class="selector-class">.c</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.i</span></span><br></pre></td></tr></table></figure><p>2）gcc 编译阶段：gcc 首先要检查代码的规范性，是否有语法错误等。以确定代码实际要做的工作，在检查无误后，gcc 把代码翻译成汇编语言。用户可以使用-S 选项进行查看，该选项只进<br>行编译而不进行汇编，生成汇编代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">gcc</span> <span class="selector-tag">-S</span> <span class="selector-tag">hello</span><span class="selector-class">.i</span> <span class="selector-tag">-o</span> <span class="selector-tag">hello</span><span class="selector-class">.s</span></span><br></pre></td></tr></table></figure><p>3）gcc 汇编阶段：生成目标代码 <em>.o ；有两种方式：使用 gcc 直接从源代码生成目标代码 gcc -c </em>.s -o <em>.o 以及使用汇编器从汇编代码生成目标代码 as </em>.s -o *.o</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello<span class="selector-class">.s</span> -o hello.o</span><br><span class="line">as hello<span class="selector-class">.s</span> -o hello.o</span><br></pre></td></tr></table></figure><p>也可以直接使用as <em>.s, 将<strong>执行汇编、链接过程生成可执行文件a.out</strong>, 可以像上面使用<strong>-o 选项</strong>指定输出文件的格式。<br>4）gcc 链接阶段：生成可执行文件；可以生成的可执行文件格式有： a.out/</em>/,当然可能还有其它格式。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc hello<span class="selector-class">.o</span>     生成可执行文件 <span class="selector-tag">a</span>.out</span><br><span class="line">gcc hello<span class="selector-class">.o</span> -o hello        生成可执行文件 hello</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GCC编译过程和动态静态库&quot;&gt;&lt;a href=&quot;#GCC编译过程和动态静态库&quot; class=&quot;headerlink&quot; title=&quot;GCC编译过程和动态静态库&quot;&gt;&lt;/a&gt;GCC编译过程和动态静态库&lt;/h1&gt;&lt;p&gt;&lt;em&gt;outline&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;[T
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>搭建Hexo执行 hexo 命令报错:ERROR Local hexo not found in xxx 二种解决方案</title>
    <link href="http://www.tangyilong.com/2018/11/29/ERROR-Local-hexo-not-found-in-Hexo/"/>
    <id>http://www.tangyilong.com/2018/11/29/ERROR-Local-hexo-not-found-in-Hexo/</id>
    <published>2018-11-29T11:57:29.000Z</published>
    <updated>2018-11-29T13:02:01.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案"><a href="#搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案" class="headerlink" title="搭建Hexo执行 hexo 命令报错:ERROR Local hexo not found in xxx 二种解决方案"></a>搭建Hexo执行 hexo 命令报错:ERROR Local hexo not found in xxx 二种解决方案</h1><h2 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h2><p>当输入hexo命令的时候会出现下面这张情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@:hexo_web# hexo -v</span><br><span class="line">ERROR Local hexo not found in ~/share/Hexo/hexo_web</span><br><span class="line">ERROR Try running: 'npm install hexo --save'</span><br></pre></td></tr></table></figure><p>导致这个原因为在自己的博客文件夹中,.gitignore文件中添加了node_modules/,导致更新的时候,这个文件夹被忽略,没有被更新上去。</p><p>解决方案:</p><p>​    1.cmd进入博客当前文件夹路径</p><p>​    2.执行 npm install</p><p>​    3.执行 hexo server</p><p>​    4.执行成功后,再到博客下的git中执行 hexo 命令 发现可以执行成功。</p><h2 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h2><p>首先是我是在网上找到的第一种方案，但是没有效果，所以就自己试着寻找一些蛛丝马迹</p><p>首先你在你的hexo目录下面使用hexo命令是不成功的</p><p>但是呢，当你退到上层目录的时候，hexo命令却是可以正常使用的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@:/home/share/Hexo/hexo_web# hexo -v</span><br><span class="line">ERROR Local hexo not found in ~/share/Hexo/hexo_web</span><br><span class="line">ERROR Try running: 'npm install hexo --save'</span><br><span class="line">root@:/home/share/Hexo/hexo_web# cd ..</span><br><span class="line">root@:/home/share/Hexo# hexo -v</span><br><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Linux 4.15.0-39-generic linux x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 4.2.6                      &lt;================</span><br><span class="line">v8: 6.8.275.32-node.36</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.14.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0i</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure><p>我注意到有一个地方不太对，那就是node的版本是4.2.6，版本太老了。</p><p>所以我就试着更新node的版本，把node的版本更新到最新版10.13.0</p><p>更新之后我们再进入到hexo的博客目录下面去执行命令，查看结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root@:/home/share/Hexo/hexo_web# hexo -v</span><br><span class="line">hexo: 3.8.0</span><br><span class="line">hexo-cli: 1.1.0</span><br><span class="line">os: Linux 4.15.0-39-generic linux x64</span><br><span class="line">http_parser: 2.8.0</span><br><span class="line">node: 10.13.0              &lt;==========================</span><br><span class="line">v8: 6.8.275.32-node.36</span><br><span class="line">uv: 1.23.2</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.14.0</span><br><span class="line">modules: 64</span><br><span class="line">nghttp2: 1.34.0</span><br><span class="line">napi: 3</span><br><span class="line">openssl: 1.1.0i</span><br><span class="line">icu: 62.1</span><br><span class="line">unicode: 11.0</span><br><span class="line">cldr: 33.1</span><br><span class="line">tz: 2018e</span><br></pre></td></tr></table></figure><p>附上手动更新node的方法</p><h2 id="下载nodj二进制源码：xz结尾的压缩文件"><a href="#下载nodj二进制源码：xz结尾的压缩文件" class="headerlink" title="下载nodj二进制源码：xz结尾的压缩文件"></a>下载nodj二进制源码：xz结尾的压缩文件</h2><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node官网</a></p><p>注意：选择合适版本，我使用的是ubuntu,所以选择linux包下载下来就是源码，解压之后就存在node和npm。无需重复编译。</p><h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf node-v9.5.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 在底部添加</span><br><span class="line">export NODE_HOME=/opt/nodejs/node-v11.1.0-linux-x64/bin</span><br><span class="line">export PATH=$NODE_HOME:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>激活修改</span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 验证</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 如果全局安装pm2包，可以验证</span><br><span class="line">pm2 list</span><br></pre></td></tr></table></figure><p>那么我不是这么使用的，我是直接复制粘贴覆盖原来的node文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@:# which node</span><br><span class="line">/usr/bin/node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 到下载的最新node目录下面</span><br><span class="line"><span class="meta">#</span> 将bin里面的node拷贝过去</span><br><span class="line">root@:/opt/node-v10.13.0-linux-x64/bin# cp ./node /usr/bin/node</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 验证</span><br><span class="line">root@:# node -v</span><br><span class="line">v10.13.0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案&quot;&gt;&lt;a href=&quot;#搭建Hexo执行-hexo-命令报错-ERROR-Local-hexo-not-found-in-xxx-二种解决方案&quot; 
      
    
    </summary>
    
    
  </entry>
  
</feed>
