<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>as3522</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tangyilong.com/"/>
  <updated>2019-05-15T07:13:40.922Z</updated>
  <id>http://www.tangyilong.com/</id>
  
  <author>
    <name>as3522</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>popen</title>
    <link href="http://www.tangyilong.com/2019/05/15/popen/"/>
    <id>http://www.tangyilong.com/2019/05/15/popen/</id>
    <published>2019-05-15T07:13:14.000Z</published>
    <updated>2019-05-15T07:13:40.922Z</updated>
    
    <content type="html"><![CDATA[<p> popen()可以执行shell命令，并读取此命令的返回值；　　</p><p>   popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。可以通过这个管道执行标准输入输出操作。<strong>这个管道<font color="#ff0000">必须由pclose()函数关闭，必须由pclose()函数关闭，必须由pclose()函数关闭</font>，而不是fclose()函数（若使用fclose则会产生僵尸进程）。</strong>pclose()函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose()返回的终止状态与shell已执行exit一样。</p><p>　type参数只能是读或者写中的一种，得到的返回值（标准I/O流）也具有和type相应的只读或只写类型。如果type是”r”则文件指针连接到command的标准输出；如果type是”w”则文件指针连接到command的标准输入。</p><p>　　command参数是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。</p><p>　　popen()的返回值是个标准I/O流，必须由pclose来终止。前面提到这个流是单向的（只能用于读或写）。向这个流写内容相当于写入该命令的标准输入，命令的标准输出和调用popen()的进程相同；与之相反的，从流中读数据相当于读取命令的标准输出，命令的标准输入和调用popen()的进程相同。</p><p><strong>返回值</strong><br>　　如果调用fork()或pipe()失败，或者不能分配内存将返回NULL，否则返回标准I/O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL。</p><p>函数原型</p><p>FILE <em>popen(const char </em>command, const char <em>type);<br>int pclose(FILE </em>stream);</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_result(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n&gt;&gt;&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)), fgets(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, fp) != <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n&lt;&lt;&lt;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                fp = <span class="literal">NULL</span>;</span><br><span class="line">                fp = popen(<span class="string">"ls"</span>, <span class="string">"r"</span>);</span><br><span class="line">                <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">                        perror(<span class="string">"popen"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                print_result(fp);</span><br><span class="line">                pclose(fp);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; popen()可以执行shell命令，并读取此命令的返回值；　　&lt;/p&gt;
&lt;p&gt;   popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。可以通过这个管道执行标准输入输出操作。&lt;strong&gt;这个管道&lt;font 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sqlite3 pragma</title>
    <link href="http://www.tangyilong.com/2019/05/15/pragma/"/>
    <id>http://www.tangyilong.com/2019/05/15/pragma/</id>
    <published>2019-05-15T07:11:39.000Z</published>
    <updated>2019-05-15T07:15:16.661Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://iihero.iteye.com/blog/1189633" target="_blank" rel="noopener">原文</a></p><p>PRAGMA语句是SQLITE数据的SQL扩展，是它独有的特性，主要用于修改SQLITE库或者内数据查询的操作。它采用与SELECT、INSERT等语句一样的形式来发出请求，但也有几个重要的不同： </p><ol><li>特定的PRAGMA语句可能被移走，新的PRAGMA语句可能在新的版本中添加。因此，后向兼容无法保证。 </li><li>未知的PRAGMA命令不会有错误消息出现，它只是简单的忽略。 </li><li>有些PRAGMA只在SQL的编译阶段起作用，而不是执行阶段。　这意味着如果使用C语言，sqlite3_prepare(), sqlite3_step(), sqlite3_finalize()这几个API，pragma命令可能只在prepare()的调用里运行，而不是在后两个API当中执行。或者，pragma可能在sqlite3_step()执行的时候运行。到底在哪个阶段执行，取决于pragma从本身，以及是哪个sqlite的release版本。 </li><li>pragma命令是sqlite特有的，基本上不可能与其它数据库保持兼容。 </li></ol><p>PRAGMA命令的语法格式如下图： </p><p><img src="/pic/sqlite1.jpg" alt="img1"></p><p>它可以不带参数，或者只带一个参数。这个参数可以是等号赋值，也可以用括号括起来。两者效果一样。很多情况下，参数值是布尔型，值为(1,yes,true 或on)或者(0, no, false, off)<br>关键字参数，可以使用引号括起来，e.g. ‘yes’ [FALSE]。有些pragma命令会使用字符串作为参数，”0”和”no”表示相同的含义。当查询某设置的值时，很多情况下返回的是数值，而不是关键字。 </p><p>pragma名之前，可以选带数据库的名字。数据库名是被”attach”（关联）上的数据库名字，或者是”main”, “temp”来表示主数据库和临时数据库。如果可选的数据库名被略去，则默认为”main”数据库。在有些pragma命令里，数据库名没有意义，则简单的忽略掉。 </p><p>下面我们看看sqlite到底有些有用的pragma命令：<br>auto_vacuum<br>automatic_index<br>cache_size<br>case_sensitive_like<br>checkpoint_fullfsync<br>collation_list<br>compile_options<br>count_changes¹<br>database_list<br>default_cache_size¹<br>empty_result_callbacks¹<br>encoding<br>foreign_key_list<br>foreign_keys<br>freelist_count<br>full_column_names¹<br>fullfsync<br>ignore_check_constraints<br>incremental_vacuum<br>index_info<br>index_list<br>integrity_check<br>journal_mode<br>journal_size_limit<br>legacy_file_format<br>locking_mode<br>max_page_count<br>page_count<br>page_size<br>parser_trace²<br>quick_check<br>read_uncommitted<br>recursive_triggers<br>reverse_unordered_selects<br>schema_version<br>secure_delete<br>short_column_names¹<br>synchronous<br>table_info<br>temp_store<br>temp_store_directory¹<br>user_version<br>vdbe_listing²<br>vdbe_trace²<br>wal_autocheckpoint<br>wal_checkpoint<br>writable_schema<br>这里边有几个标了右上标为1的，似乎已经被obsoleted掉了。标为2的，只被用于debug,仅当sqlite在预编译宏SQLITE_DEBUG下build出来，才有用。 </p><p>下面看看这些命令的具体用法： </p><ol><li><p>PRAGMA auto_vacuum;<br>PRAGMA auto_vacuum = 0 或 NONE | 1 或 FULL | 2 或 INCREMENTAL;<br>这里，0和NONE表示的含义相同。<br>缺省值为0, 表示禁用auto vacuum. 除非SQLITE_DEFAULT_AUTOVACUUM宏在编译的时候定义了。数据删除的时候，数据库大小不会改变。没用的数据库文件页面会被添加到freelist里头，用于将来重用。这时，使用VACUUM命令，可以重建整个数据库，以回收无用的磁盘空间。<br>值为1时，所有的freelist页会被移动到文件末尾，每次事务提交的时候文件会被截短。注意，自动vacuum只是从文件是截断freelist页，并没有进行碎片重整等操作，也就是说，它没有VACUUM命令来得彻底。事实上，自动vacuum会让碎片更多。<br>只有在数据库存储某些附加信息的时候，它允许每个数据库页来跟踪它的引用页，自动vacuum才用得上。它必须在没有创建任何表的情况下启用。在一个表已经创建了之后，是不能启用和停用auto-vacuum的。<br>值为2时，表示增量vacuum，意味着并不是在每次提交事务的时候自动vacuum，需要调用一个独立的incremental_vacuum语句来触发auto-vacuum。<br>数据库可以在1和2两种vacuum模式下进行切换。但是不能从none到full或incremental间切换。要想切换，要么数据库是全新的数据库（没有任何表），　或者单独运行vacuum命令以后。改变自动vacuum模式，首先执行auto_vacuum语句设置新的模式，然后调用VACUUM来重整数据库。<br>不带参数的auto_vacuum语句返回当前的auto_vacuum模式值。 </p></li><li><p>PRAGMA automatic_index;<br>PRAGMA automatic_index = boolean;<br>查询，设置或者清除自动索引的功能。缺省值为true (1). </p></li><li><p>PRAGMA cache_size;<br>PRAGMA cache_size = <number of="" pages="">;<br>查询或者修改打开的数据库内存里头能容纳的最多的数据库页数。缺省值是2000.　这样设定只会改变当前会话中的cache size，当数据库重新打开，又会恢复默认值。你可以使用default_cache_size来设定所有会话中的cache size </number></p></li><li><p>PRAGMA case_sensitive_like=boolean;<br>默认行为是忽略ascii字符的大小写。’a’ LIKE ‘A’会是true. 当禁用case_sensitive_like时，会用默认的like行为。当启用它时，就会区分大小写。 </p></li><li><p>PRAGMA checkpoint_fullfsync<br>PRAGMA checkpoint_fullfsync=boolean;<br>查询或设置fullfsync的标志值。如果设置了该值，则F_FULLFSYNC同步方法会在checkpoint操作时调用，默认值是off。只有Mac OS-X操作系统支持F_FULLFSYNC。另外，如果设定了fullfsync值，那么F_FULLFSYNC同步方法会在所有sync操作里使用，也checkpoint_fullfsync标志完全无关。 </p></li><li><p>PRAGMA collation_list;<br>返回当前数据库连接定义的所有排序顺序。 </p></li><li><p>PRAGMA compile_options;<br>这个要赞，返回编译SQLITE时使用的所有预编译宏。当然，以”SQLITE_”打头的前缀会被忽略。实际上它是通过调用sqlite3_compileoption_get()方法返回的。 </p></li><li><p>PRAGMA count_changes;<br>PRAGMA count_changes=boolean;<br>该命令已经停用. 只是为了保持后向兼容. 如果不设置此值，INSERT, UPDATE, DELETE语句不会返回多少行改变的数据。<br>事实上，sqlite3_changes()可以获取改变的行数。 </p></li><li><p>PRAGMA database_list;<br>返回当前数据库连接关联的数据库列表. </p></li><li><p>PRAGMA default_cache_size;<br>PRAGMA default_cache_size = Number-of-pages;<br>设置缺省的cache sie, 是以页为单位。不幸的是，该命令也将被废弃。 </p></li><li><p>PRAGMA empty_result_callbacks;<br>PRAGMA empty_result_callbacks = boolean;<br>仅作后向兼容用。如果将该标志值清除，sqlite3_exec()提供的回调函数（返回0或多行数据）将不被触发。 </p></li><li><p>PRAGMA encoding;<br>PRAGMA encoding = “UTF-8”;<br>PRAGMA encoding = “UTF-16”;<br>PRAGMA encoding = “UTF-16le”;<br>PRAGMA encoding = “UTF-16be”;<br>缺省值是utf-8。如果使用attach命令，则会要求使用与main数据库相同的字符集编码，如果新的数据库编码与main不同，则会失败。 </p></li><li><p>PRAGMA foreign_key_list(table-name);<br>返回外键列表 </p></li><li><p>PRAGMA foreign_keys;<br>PRAGMA foreign_keys = boolean;<br>查询设置或者清除关于外键的限制, 外键限制只有在BEGIN或者SAVEPOINT不在PENDING状态时设置才有效。<br>　　改变该设置会影响所有已经准备好的SQL语句的执行。<br>从3.6.19开始，默认的FK强制限制是OFF。也就是说，不会强制外键依赖。 </p></li><li><p>PRAGMA freelist_count;<br>返回数据库文件中未使用页的数目 </p></li><li><p>PRAGMA full_column_names;<br>PRAGMA full_column_names = boolean;<br>deprecated. </p><ol><li>如果有AS子句，列名就会用AS后的别名 </li><li>如果结果只是普通的表达式，而不是源表的列名，则采用表达式的文本 </li><li>如果使用了short_column_names开关为ON，则采用源表列名，并且不带表名前缀 </li><li>如果两个开关都设为OFF，则采用第2个规则。 </li><li>结果列是学有源表源列的组合：TABLE.COLUMN </li></ol></li><li><p>PRAGMA fullfsync;<br>PRAGMA fullfsync = boolean;<br>缺省值为OFF，也只有MAC os支持F_FULLFSYNC </p></li><li><p>PRAGMA ignore_check_constraints = boolean;<br>是否强制check约束，缺省值为off </p></li><li><p>PRAGMA incremental_vacuum(N);<br>N页从freelist中移除。用于设定此参数。每次截短相同的页数。该命令必须是在auto_vacuum=incremental模式下才有效。如果freelist中的页数少于N，或者N小于1，或者N被完全忽略，那么整个freelist会被清除。 </p></li><li><p>PRAGMA index_info(index-name);<br>获取具名的index信息。 </p></li><li><p>PRAGMA index_list(table-name);<br>获取与目标表关联的索引的的相关信息 </p></li><li><p>PRAGMA integrity_check;<br>PRAGMA integrity_check(integer);<br>执行整个库的完全性检查，会查看错序的记录、丢失的页，毁坏的索引等。 </p></li><li><p>PRAGMA journal_mode;<br>PRAGMA database.journal_mode;<br>PRAGMA journal_mode = DELETE | TRUNCATE | PERSIST | MEMORY | WAL | OFF<br>PRAGMA database.journal_mode = DELETE | TRUNCATE | PERSIST | MEMORY | WAL | OFF<br>用于设置数据库的journal_mode. DELETE是缺省的行为。在此模式下，每次事务终止的时候，journal文件会被删除，它会导致事务提交。<br>TRUNCATE模式，通过将回滚journal截短成0，而不是删除它。大多数情情况下，它要比DELETE模式速度快(因为不用删除文件）<br>PERSIST模式，每次事务结束时，并不删除rollback journal，而只是在journal的头部填充0，这样会阻止别的数据库连接来rollback. 该模式在某些平台下，是一种优化，特别是删除或者truncate一个文件比覆盖文件的第一块代价高的时候。<br>MEMORY模式，只将rollback日志存储到RAM中，节省了磁盘I/O，但带来的代价是稳定性和完整性上的损失。如果中间crash掉了，数据库有可能损坏。<br>WAL模式，也就是write-ahead　log取代rollback journal。该模式是持久化的，跨多个数据为连接，在重新打开数据库以后，仍然有效。该模式只在3.7.0以后才有效。<br>(经过实验，发现，它会生成两个文件：.shm和.wal)<br>OFF模式，这样就没有事务支持了。　<br>另外要注意的是，对于memory数据库，只有两种模式: MEMORY或者OFF。并且，当前如果有活跃的事务，则不允许改变事务模式。 </p></li><li><p>PRAGMA journal_size_limit<br>PRAGMA journal_size_limit = N ;<br>如果连接时，用了”exclusive mode(PRAGMA locking_mode=exclusive)或者(PRAGMA journal_mode=persist), 提交事务以后，journal文件会仍然在文件系系统当中。这可能会提高了效率，但是也损耗了空间。一个大的事务（如VACUUM)，会耗费大量的磁盘空间。<br>该设置会限制journal文件的大小。默认值是－1。 </p></li><li><p>PRAGMA legacy_file_format;<br>PRAGMA legacy_file_format = boolean;<br>如果该值为ON，则会采用3.0.0文件格式，如果为off, 则会采用最新的文件格式，可能导致旧版本的sqlite无法打开该文件。<br>第一次新文件格式的sqlite3数据库打开时，该值为off.但是默认值会是on. </p></li><li><p>PRAGMA locking_mode;<br>PRAGMA locking_mode = NORMAL | EXCLUSIVE<br>缺省值是NORMAL. 数据库连接在每一个读或写事务终点的时候放掉文件锁。如果是EXCLUSIVE模式，连接永远不会释放文件锁。在此模式下，第一次执行读操作时，会获取并持有共享锁，第一次写，会获取并持有排它锁。<br>释放排它锁，仅当关闭数据库连接，或者将锁模式改回为NORMAL时，再次访问数据库文件（读或写）才会放掉。简单的设置为NORMAL是不够的，只有当下次再访问时才会释放排它锁。<br>有下述三个理由，去设置锁模式为EXCLUSIVE </p><ol><li>应用程序需要阻止其它进程访问数据库文件 </li><li>文件系统的系统调用数量减少了，导致些许性能下降 </li><li>WAL日志模式可以在EXCLUSIVE模式下使用，而不需要用到共享内存<br>当指定数据库名时，只能目标数据库生效。如：<br>PRAGMA main.locking_mode=EXCLUSIVE;  不指定数据库名时，则对所有打开的数据库生效。temp或者memory数据库总是使用exclusive锁模式。<br>　　第一次进入WAL日志模式时，锁模式使用的是exclusive，这以后，锁模式也不能改变，直到退出WAL日志模式，如果锁模式开始时使用的是NORMAL，第一次进入WAL，这时锁模式可以改变，并且不需要退出WAL模式。 </li></ol></li><li><p>PRAGMA max_page_count;<br>PRAGMA max_page_count = N;<br>查询或者设置数据库文件的最大页数 </p></li><li><p>PRAGMA page_count;<br>返回数据库文件的页数 </p></li><li><p>PRAGMA page_size;<br>PRAGMA page_size = bytes;<br>查询或者设置数据库文件的页大小, 必须是2的乘方，并且介于512和65536之间。<br>创建数据库时，会给定一个缺省的大小。page_size命令会立即改变页大小（如果数据库是空的话，就是说在没有创建任何表的情况下）。如果指定了新大小，是在运行VACUUM命令之间，同时数据库不是在WAL日志模式下，那么VACUUM命令会将页大小调整到新的大小（这时应该没有是事创建表的限制）<br>SQLITE_DEFAULT_PAGE_SIZE 缺省值是1024，最大的缺省页大小是8192. windows下，有时候可能缺省页大小大于1024，取决于GetDiskFreeSpace()来获取真实的设置扇区大小。 </p></li><li><p>PRAGMA parser_trace = boolean;<br>用在DEBUG的时候。 </p></li><li><p>PRAGMA quick_check;<br>PRAGMA quick_check(integer)<br>与integrity_check相像，但是略去了对索引内容与表内容匹配的校验。 </p></li><li><p>PRAGMA read_uncommitted;<br>PRAGMA read_uncommitted = boolean;<br>读未提交开关。缺省的事务隔离级是：可串行化。任何进程或线程都可以设置读未提交隔离级，但是，SERIALIZABLE仍被使用，除了共享某页和表模式的缓存的那些连接。 </p></li><li><p>PRAGMA recursive_triggers;<br>PRAGMA recursive_triggers = boolean;<br>会影响所有的语句执行。3.6.18以前，这个开关是不支持的。缺省值是off. </p></li><li><p>PRAGMA reverse_unordered_selects;<br>PRAGMA reverse_unordered_selects = boolean;<br>当开启此开关时，不带order by的select语句，会输出相反顺序的结果。 </p></li><li><p>PRAGMA schema_version;<br>PRAGMA schema_version = integer ;<br>PRAGMA user_version;<br>PRAGMA user_version = integer ;<br>schema和user version是在数据库文件头40，60字节处的32位整数（大端表示）。<br>schema版本由sqlite内部维护，当schema改变时，就会增加该值。显式改变该值非常危险。<br>user版本可以被应用程序使用。 </p></li><li><p>PRAGMA secure_delete;<br>PRAGMA database.secure_delete;<br>PRAGMA secure_delete = boolean<br>PRAGMA database.secure_delete = boolean<br>设为ON时，删除的内容会用0来覆盖。缺省值由宏SQLITE_SECURE_DELETE 决定。那就是OFF了。 </p></li><li><p>PRAGMA short_column_names;<br>PRAGMA short_column_names = boolean;<br>deprecated. </p></li><li><p>PRAGMA synchronous;<br>PRAGMA synchronous = 0 | OFF | 1 | NORMAL | 2 | FULL;<br>查询设置sync标志值。缺省值是FULL. </p></li><li><p>PRAGMA table_info(table-name);<br>返回表的基本信息 </p></li><li><p>PRAGMA temp_store;<br>PRAGMA temp_store = 0 | DEFAULT | 1 | FILE | 2 | MEMORY;<br>查询或设置temp_store参数值。<br>SQLITE_TEMP_STORE PRAGMA temp_store Storage used forTEMP tables<br>0    any    file<br>1    0    file<br>1    1    file<br>1    2    memory<br>2    0    memory<br>2    1    file<br>2    2    memory<br>3    any    memory </p></li><li><p>PRAGMA temp_store_directory;<br>PRAGMA temp_store_directory = ‘directory-name’;<br>设置或改变temp_store的目录位置. deprecated. </p></li><li><p>PRAGMA vdbe_listing = boolean;<br>用于DEBUG </p></li><li><p>PRAGMA vdbe_trace = boolean;<br>用于DEBUG </p></li><li><p>PRAGMA wal_autocheckpoint;<br>PRAGMA wal_autocheckpoint=N;<br>设置WAL自动检查点的间隔（以页为单位）, 缺省值是1000。 </p></li><li><p>PRAGMA database.wal_checkpoint;<br>PRAGMA database.wal_checkpoint(PASSIVE);<br>PRAGMA database.wal_checkpoint(FULL);<br>PRAGMA database.wal_checkpoint(RESTART); </p></li><li><p>PRAGMA writable_schema = boolean;<br>当设为ON时，SQLITE_MASTER表可以执行CUD操作。这样做很危险!! </p></li></ol><p>(finished!!!) </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://iihero.iteye.com/blog/1189633&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PRAGMA语句是SQLITE数据的SQL扩展，是它独有的特性，主要用于修改SQLITE
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>哈佛和冯诺依曼架构</title>
    <link href="http://www.tangyilong.com/2019/05/15/%E5%93%88%E4%BD%9B%E5%92%8C%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.tangyilong.com/2019/05/15/哈佛和冯诺依曼架构/</id>
    <published>2019-05-15T07:09:19.000Z</published>
    <updated>2019-05-15T07:17:27.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a><strong>哈佛结构</strong></h2><p><img src="/pic/哈佛.png" alt="img1"></p><p>(英语：<strong><em>Harvard architecture</em></strong>)是一种将程序指令储存和数据储存分开的存储器结构。中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作（通常是执行）。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度，如Microchip公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。</p><font color="#FF0000">与冯.诺曼结构处理器比较，哈佛结构处理器有两个明显的特点：</font><p>1、使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</p><p>2、使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。</p><p><font color="#FF0000">改进的哈佛结构，其结构特点为：</font><br>1、使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存，以便实现并行处理；<br>2、具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；</p><p>   哈佛结构的微处理器通常具有较高的执行效率。其程序指令和数据指令分开组织和储存的，执行时可以预先读取下一条指令。目前使用哈佛结构的中央处理器和微控制器有很多，除了上面提到的Microchip公司的PIC系列芯片，还有摩托罗拉公司的MC68系列、Zilog公司的Z8系列、ATMEL公司的AVR系列和安谋公司的ARM9、ARM10和ARM11。</p><h2 id="冯·诺伊曼结构"><a href="#冯·诺伊曼结构" class="headerlink" title="冯·诺伊曼结构"></a><strong>冯·诺伊曼结构</strong></h2><p><img src="/pic/哈佛2.png" alt="img1"></p><p>（<strong>von Neumann architecture</strong>），也称<strong>普林斯顿结构</strong>，是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。本词描述的是一种实作通用图灵机的计算装置，以及一种相对于平行计算的序列式结构参考模型（referential model）。</p><p>本结构隐约指导了将储存装置与中央处理器分开的概念，因此依本结构设计出的计算机又称<strong>储存程式型</strong>电脑。</p><p>   冯.诺曼结构处理器具有以下几个特点：</p><p>必须有一个存储器；</p><p>必须有一个控制器；</p><p>必须有一个运算器，用于完成算术运算和逻辑运算；</p><p>必须有输入和输出设备，用于进行人机通信。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>随着半导体工业的发展，很多东西可以集成到芯片内部。在芯片内部走线比在PCB外部走线成本要低出很多。</p><p>也就是说，哈佛结构很适合被设计到芯片内部。而冯诺依曼结构仍然存在于芯片外部。</p><p>于是乎，便出现了现在的冯诺依曼和哈佛结构并存的混合式结构：</p><p><img src="/pic/哈佛3.jpg" alt="img1"></p><p>这种结构就是目前ARM的结构，将两种结构扬其长，避其短。其中，芯片内部的cache，表示高速缓存（cache一词据说来自法语，难道cache是法国人发明的？哈哈。）Dcache用来缓存部分代码，icache用来缓存部分数据。只有需要改变时，cache才会到RAM中加载新的数据。所以大部分时间CPU都是通过哈佛结构和cache（高速缓存）通讯，这个速度是非常快的～～</p><p>这样在芯片外部，利用冯诺依曼结构，节省了外部的PCB走线资源。</p><p>在芯片内部，利用哈佛结构提高了CPU访问数据的速度。可谓是两全其美～～</p><hr><p><a href="http://www.cnblogs.com/douzi2/" target="_blank" rel="noopener">出处1</a></p><p><a href="https://blog.csdn.net/zhaoguanghua0407/article/details/78534281" target="_blank" rel="noopener">出处2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;哈佛结构&quot;&gt;&lt;a href=&quot;#哈佛结构&quot; class=&quot;headerlink&quot; title=&quot;哈佛结构&quot;&gt;&lt;/a&gt;&lt;strong&gt;哈佛结构&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/pic/哈佛.png&quot; alt=&quot;img1&quot;&gt;&lt;/p&gt;
&lt;p&gt;(英语
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="http://www.tangyilong.com/2019/05/15/MarkDown%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.tangyilong.com/2019/05/15/MarkDown语法/</id>
    <published>2019-05-15T06:31:02.000Z</published>
    <updated>2019-05-15T07:08:17.817Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qcx321/article/details/53780672" target="_blank" rel="noopener">https://blog.csdn.net/qcx321/article/details/53780672</a></p><p>markdown语法实例<br>[TOC]</p><h3 id="1-强调"><a href="#1-强调" class="headerlink" title="1 强调"></a>1 强调</h3><p>星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**一个人来到田纳西**</span><br><span class="line"><span class="symbol">__</span>毫无疑问<span class="symbol">__</span></span><br><span class="line"></span><br><span class="line">*我做的馅饼</span><br><span class="line">是全天下*</span><br><span class="line"></span><br><span class="line"><span class="symbol">_</span>最好吃的<span class="symbol">_</span></span><br></pre></td></tr></table></figure></p><p><strong>一个人来到田纳西</strong><br><strong>毫无疑问</strong></p><p><em>我做的馅饼<br>是全天下</em></p><p><em>最好吃的</em></p><h3 id="2-分割线"><a href="#2-分割线" class="headerlink" title="2 分割线"></a>2 分割线</h3><p>三个或更多-_*，必须单独一行，可含空格<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">___</span></span><br></pre></td></tr></table></figure></p><hr><hr><hr><h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a>3 引用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用</span></span><br></pre></td></tr></table></figure><blockquote><p>引用</p></blockquote><p>内层符号前的空格必须要<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用</span><br><span class="line"><span class="meta">&gt;&gt;</span>引用中的引用</span><br></pre></td></tr></table></figure></p><blockquote><p>引用</p><blockquote><p>引用中的引用</p></blockquote></blockquote><h3 id="4-标题：Setext方式"><a href="#4-标题：Setext方式" class="headerlink" title="4 标题：Setext方式"></a>4 标题：Setext方式</h3><p>三个或更多<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大标题</span><br><span class="line">===</span><br><span class="line">小标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><h3 id="5-标题：Atx方式"><a href="#5-标题：Atx方式" class="headerlink" title="5 标题：Atx方式"></a>5 标题：Atx方式</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h3 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6 无序列表"></a>6 无序列表</h3><p>符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>无序列表</span><br><span class="line"><span class="bullet">- </span>无序列表</span><br><span class="line"><span class="bullet">- </span>无序列表</span><br><span class="line"><span class="bullet">- </span>无序列表：我很长。我也很长！那比一比啊</span><br></pre></td></tr></table></figure></p><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li><li>无序列表：我很长。我也很长！那比一比啊</li></ul><p>符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>无序列表</span><br><span class="line"><span class="bullet">* </span>无序列表</span><br><span class="line"><span class="bullet">* </span>无序列表</span><br><span class="line"><span class="bullet">* </span>无序列表：我很长。我也很长！那比一比啊</span><br></pre></td></tr></table></figure></p><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li><li>无序列表：我很长。我也很长！那比一比啊<h3 id="7-有序列表"><a href="#7-有序列表" class="headerlink" title="7 有序列表"></a>7 有序列表</h3><font color="#ff0000">数字不能省略但可无序，点号之后的空格不能少</font></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>有序列表</span><br><span class="line"><span class="bullet">2. </span>有序列表</span><br><span class="line"><span class="bullet">3. </span>有序列表</span><br><span class="line"><span class="bullet">8. </span>有序列表</span><br></pre></td></tr></table></figure><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表<br>嵌套列表<br>-+*可循环使用，但符号之后的空格不能少，符号之前的空格也不能少<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 嵌套列表<span class="number">1</span></span><br><span class="line"> + 嵌套列表<span class="number">2</span></span><br><span class="line"> + 嵌套列表<span class="number">3</span></span><br><span class="line">  - 嵌套列表<span class="number">4</span></span><br><span class="line">   * 嵌套列表<span class="number">5</span></span><br><span class="line">- 嵌套列表<span class="number">6</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>嵌套列表1<ul><li>嵌套列表2</li><li>嵌套列表3</li></ul><ul><li>嵌套列表4<ul><li>嵌套列表5</li></ul></li></ul></li><li>嵌套列表6<br>8 文字超链：Inline方式<br>Tooltips可省略<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">as3522</span>](<span class="link">http://www.as3522.com "博客"</span>)</span><br></pre></td></tr></table></figure></li></ul><p><a href="http://www.as3522.com" title="博客" target="_blank" rel="noopener">as3522</a></p><h3 id="8-图片超链"><a href="#8-图片超链" class="headerlink" title="8 图片超链"></a>8 图片超链</h3><p>多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">GitHub Mark</span>](<span class="link">http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png "GitHub Mark"</span>)</span><br></pre></td></tr></table></figure></p><p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png&quot;GitHub Mark&quot;" alt="GitHub Mark"></p><h3 id="9-索引超链：Reference方式"><a href="#9-索引超链：Reference方式" class="headerlink" title="9 索引超链：Reference方式"></a>9 索引超链：Reference方式</h3><p>索引，1 可以是任意字符<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">as3522</span>][<span class="symbol">1</span>]</span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">http://www.as3522.com</span></span><br></pre></td></tr></table></figure></p><p><a href="http://www.as3522.com" target="_blank" rel="noopener">as3522</a></p><h3 id="10-自动链接"><a href="#10-自动链接" class="headerlink" title="10 自动链接"></a>10 自动链接</h3><p>尖括号<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">http:</span><span class="comment">//ibruce.info&gt;</span></span><br><span class="line">&lt;bu.ru<span class="meta">@qq</span>.com&gt;</span><br></pre></td></tr></table></figure></p><p><a href="http://ibruce.info" target="_blank" rel="noopener">http://ibruce.info</a></p><p><a href="mailto:&#98;&#117;&#x2e;&#x72;&#117;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#98;&#117;&#x2e;&#x72;&#117;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a></p><h3 id="11-代码：行内代码"><a href="#11-代码：行内代码" class="headerlink" title="11 代码：行内代码"></a>11 代码：行内代码</h3><p>在第一行后指定编程语言，也可以不指定<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">​``` python</span><br><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可代码高亮</span><br><span class="line">​``` python</span><br><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><h3 id="12-代码：段落代码"><a href="#12-代码：段落代码" class="headerlink" title="12 代码：段落代码"></a>12 代码：段落代码</h3><p>每行文字前加4个空格或者1个Tab</p><pre><code>    val s = &quot;hello Markdown&quot;    println( s )    val s = &quot;hello Markdown&quot;    println( s )val s = &quot;hello Markdown&quot;println( s )val s = &quot;hello Markdown&quot;println( s )</code></pre><h3 id="13-注释"><a href="#13-注释" class="headerlink" title="13 注释"></a>13 注释</h3><p>用html的注释，好像只有这样？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="14-转义字符"><a href="#14-转义字符" class="headerlink" title="14 转义字符"></a>14 转义字符</h3><p>Markdown中的转义字符为\，转义的有：<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\\</span> 反斜杠</span><br><span class="line"></span><br><span class="line"><span class="symbol">\`</span> 反引号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\*</span> 星号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\_</span> 下划线</span><br><span class="line"></span><br><span class="line"><span class="symbol">\&#123;</span><span class="symbol">\&#125;</span> 大括号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\[</span><span class="symbol">\]</span> 中括号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\(</span><span class="symbol">\)</span> 小括号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\#</span> 井号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\+</span> 加号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\-</span> 减号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\.</span> 英文句号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\!</span> 感叹号</span><br></pre></td></tr></table></figure></p><p>\ 反斜杠</p><p>` 反引号</p><p>* 星号</p><p>_ 下划线</p><p>{} 大括号</p><p>[] 中括号</p><p>() 小括号</p><p># 井号</p><p>+ 加号</p><p>- 减号</p><p>. 英文句号</p><p>! 感叹号</p><h3 id="15-表格"><a href="#15-表格" class="headerlink" title="15 表格"></a>15 表格</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">| Tables        |</span>      Are      <span class="params">|  Cool |</span></span><br><span class="line"><span class="params">| ------------- |</span> <span class="symbol">:-----------</span>: <span class="params">| ----: |</span></span><br><span class="line"><span class="params">| col 3 is      |</span> right-aligned <span class="params">| $1600 |</span></span><br><span class="line"><span class="params">| col 2 is      |</span>   centered    <span class="params">|   $12 |</span></span><br><span class="line"><span class="params">| zebra stripes |</span>   are neat    <span class="params">|    $1 |</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><p>或者<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> 项目     </span>|<span class="string"> 价格  </span>|</span><br><span class="line">|<span class="string"> -------- </span>|<span class="string"> ----- </span>|</span><br><span class="line">|<span class="string"> Computer </span>|<span class="string"> $1600 </span>|</span><br><span class="line">|<span class="string"> Phone    </span>|<span class="string"> $12   </span>|</span><br><span class="line">|<span class="string"> Pipe     </span>|<span class="string"> $1    </span>|</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><h3 id="16-其他"><a href="#16-其他" class="headerlink" title="16 其他"></a>16 其他</h3><p>段落缩进（空格）<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">半方大的空白<span class="variable">&amp;ensp</span>;或&amp;<span class="meta">#8194;看，飞碟</span></span><br><span class="line">全方大的空白<span class="variable">&amp;emsp</span>;或&amp;<span class="meta">#8195;看，飞碟</span></span><br><span class="line">不断行的空白格<span class="variable">&amp;nbsp</span>;或&amp;<span class="meta">#160;看，飞碟</span></span><br><span class="line"><span class="variable">&amp;emsp</span>;<span class="variable">&amp;emsp</span>;段落从此开始。</span><br></pre></td></tr></table></figure></p><p>半方大的空白&ensp;或&#8194;看，飞碟<br>全方大的空白&emsp;或&#8195;看，飞碟<br>不断行的空白格&nbsp;或&#160;看，飞碟<br>&emsp;&emsp;段落从此开始。</p><h3 id="17-字体、字号、颜色"><a href="#17-字体、字号、颜色" class="headerlink" title="17 字体、字号、颜色"></a>17 字体、字号、颜色</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;font <span class="attribute">face</span>=<span class="string">"黑体"</span>&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">face</span>=<span class="string">"微软雅黑"</span>&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">face</span>=<span class="string">"STCAIYUN"</span>&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">color</span>=#0099ff <span class="attribute">size</span>=12 <span class="attribute">face</span>=<span class="string">"黑体"</span>&gt;黑体&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">color</span>=#00ffff <span class="attribute">size</span>=3&gt;null&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">color</span>=gray <span class="attribute">size</span>=5&gt;gray&lt;/font&gt;</span><br></pre></td></tr></table></figure><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#0099ff" size="12" face="黑体">黑体</font><br><font color="#00ffff" size="3">null</font><br><font color="gray" size="5">gray</font><h3 id="18-标签"><a href="#18-标签" class="headerlink" title="18 标签"></a>18 标签</h3><p>行内标签`<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快捷键 `Ctrl + D` 来收藏本页</span><br></pre></td></tr></table></figure></p><p>快捷键 <code>Ctrl + D</code> 来收藏本页</p><p>原文：<a href="https://blog.csdn.net/qcx321/article/details/53780672" target="_blank" rel="noopener">https://blog.csdn.net/qcx321/article/details/53780672</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qcx321/article/details/53780672&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qcx321/article/detai
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux_strace</title>
    <link href="http://www.tangyilong.com/2019/05/15/Linux-strace/"/>
    <id>http://www.tangyilong.com/2019/05/15/Linux-strace/</id>
    <published>2019-05-15T06:30:04.000Z</published>
    <updated>2019-05-15T07:19:18.735Z</updated>
    
    <content type="html"><![CDATA[<p> strace是个功能强大的Linux调试分析诊断工具，可用于跟踪程序执行时进程系统调用(system call)和所接收的信号，尤其是针对源码不可读或源码无法再编译的程序。</p><p>   在Linux系统中，用户程序运行在一个沙箱(sandbox)里，用户进程不能直接访问计算机硬件设备。当进程需要访问硬件设备(如读取磁盘文件或接收网络数据等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可跟踪进程产生的系统调用，包括参数、返回值和执行所消耗的时间。若strace没有任何输出，并不代表此时进程发生阻塞；也可能程序进程正在自己的沙箱里执行某些不需要与系统其它部分发生通信的事情。strace从内核接收信息，且无需以任何特殊方式来构建内核。</p><p> strace命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strace [-dffhiqrtttTvVxx] [-a column] [-e expr] [-o file] [-p pid] [-s strsize] [-u username] [-E var=val] [<span class="built_in">command</span> [arg ...]] 或</span><br><span class="line"></span><br><span class="line">strace -c [-e expr] [-O overhead] [-S sortby] [-E var=val] [<span class="built_in">command</span> [arg ...]]</span><br></pre></td></tr></table></figure><p>   通过不同的选项开关，strace提供非常丰富的跟踪功能。最简单的应用是，跟踪可执行程序运行时的整个生命周期，将所调用的系统调用的名称、参数和返回值输出到标准错误输出stderr(即屏幕)或-o选项所指定的文件。<font color="#0099FF">注意，命令(command)必须位于选项列表之后。</font></p><p>   详细的strace命令选项列举如下：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-c</td><td>统计和报告每个系统调用所执行的时间、调用次数和出错次数等</td></tr><tr><td>-d</td><td>输出strace关于标准错误的调试信息</td></tr><tr><td>-f</td><td>跟踪当前进程及其通过fork系统调用所创建的子进程</td></tr><tr><td>-ff</td><td>常与-o选项联合使用，不同进程(子进程)的跟踪结果分别输出到相应的filename. pid文件中，pid是各个进程号</td></tr><tr><td>-F</td><td>尝试跟踪vfork系统调用。否则即使打开-f选项，vfork也不会被跟踪</td></tr><tr><td>-h</td><td>显示帮助信息</td></tr><tr><td>-i</td><td>显示发生系统调用时的指令指针(IP)寄存器值</td></tr><tr><td>-q</td><td>抑制(禁止输出)关于结合(attaching)、脱离(detaching)的消息。当输出重定向到一个文件时，自动抑制此类消息</td></tr><tr><td>-r</td><td>显示每个系统调用发生时的相对时间戳，即连续的系统调用起点之间的时间差</td></tr><tr><td>-t-tt-ttt</td><td>-t在每行输出前添加绝对时间戳(当前时钟)信息，精确到秒级-tt在每行输出前添加绝对时间戳信息，精确到微秒级-ttt在每行输出前添加相对时间信息，格式为”自纪元时间起经历的秒数.微秒数”</td></tr><tr><td>-T</td><td>显示每个系统调用所耗费的时间，其时间开销在输出行最右侧的尖括号内</td></tr><tr><td>-V</td><td>显示strace的版本信息</td></tr><tr><td>-v</td><td>冗余显示模式：显示系统调用中argv[]、envp[]、stat、termio(s)等数组/结构体参数所有的元素/成员内容。这些数组/结构体因使用频繁，默认仅显示其元素/成员的合理子集</td></tr><tr><td>-x</td><td>以16进制形式显示非标准(non-ascii)字符串，如”/x08”。默认为8进制，如”/10”</td></tr><tr><td>-xx</td><td>以16进制形式显示所有字符串</td></tr><tr><td>-a column</td><td>设置显示系统调用返回值的列位置，默认为40(从0开始)，即”=”出现在第40列</td></tr><tr><td>-e expr</td><td>指定一个表达式，用于限定跟踪哪些事件及如何跟踪。其格式为[qualifier=][!]all或[qualifier=][!]value1[,value2]…。qualifier取值为trace(默认)、abbrev、verbose、raw、signal、read或write。value是用于限定的符号(包括all和none)或数字。感叹号为否定符号，如-eopen等价于-e trace=open，表示只跟踪open系统调用；而-e trace=!open表示跟踪除open外的其他系统调用。注意某些shell用!表示执行历史记录里的命令，此时可能借助引号、转义符号(/)。-e trace=set：跟踪指定的系统调用列表，如-e trace=open,close,read,write表示只跟踪这四种系统调用。默认为set=all。-e trace=file：跟踪以指定文件名做参数的所有系统调用。-e trace=process：跟踪涉及进程管理的所有系统调用，可用于观察进程的fork、wait和exec阶段。-e trace=network：跟踪网络相关的所有系统调用。-e strace=signal：跟踪所有与系统信号相关的系统调用。-e trace=ipc：跟踪所有与进程间通信有关的系统调用。-e abbrev=set：指定哪些系统调用中的大型数组或结构体内容缩减显示，如strace -e abbrev=execve ./test仅显示execve调用中argv[]和envp[]的部分内容。默认为abbrev=all， abbrev=none等价于-v选项。-e verbose=set：指定哪些系统调用中的大型数组或结构体内容完整显示，集合外的调用其数组或结构体显示为地址。默认为verbose=all。-e raw=set：指定哪些系统调用中的参数以原始未解码的形式(即16进制)显示。当用户不信任strace解码或需要了解参数实际数值时有用。-e signal=set：跟踪指定的信号列表，默认为signal=all。如signal=!SIGIO(或signal=!io)表示不跟踪SIGIO信号。-e read=set：以16进制和ASCII码对照形式显示从指定文件描述符中读出的所有数据，如-e read=3,5可观察文件描述符3和5上的输入动作。该选项独立于系统调用read的常规跟踪(由-e trace=read选项控制)。-e write=set：以16进制和ASCII码对照形式显示写入指定文件描述符的所有数据。</td></tr><tr><td>-o file</td><td>strace输出信息默认显示到标准错误输出，该选项将输出信息写入文件file中。以下两条命令等效：strace -c -o test.txt ./teststrace -c ./test 2&gt;test.txt</td></tr><tr><td>-O overhead</td><td>Set the overhead for tracing system calls to overhead microseconds. This is useful for overriding the default heuristic for guessing how much time is spent in mere measuring when timing system calls using the -c option. The acuracy of the heuristic can be gauged by timing a given program run without tracing (使用time命令) and comparing the accumulated system call time to the total produced using -c.</td></tr><tr><td>-p pid</td><td>指定待跟踪的进程号(pid)，可用Ctrl-C终止跟踪而被跟踪进程继续运行。可指定多达32个(-p pid)选项以同时跟踪多个进程。该选项常用于调试后台进程</td></tr><tr><td>-s strsize</td><td>限制每行输出中字符串(如read参数)的最大显示长度，默认32字节。但文件名总是完整显示</td></tr><tr><td>-S sortby</td><td>按指定规则对-c选项的输出直方图进行排序。sortby取值可为time、calls、name和nothing(默认time)</td></tr><tr><td>-u username</td><td>用指定用户的UID和/或GID身份运行待跟踪程序</td></tr><tr><td>-E var=val</td><td>将var=val放入命令的环境变量列表</td></tr><tr><td>-E var</td><td>从命令的环境变量列表中移除var</td></tr></tbody></table><p>   例如，命令strace -o out.txt -T -tt -e trace=all -p 2899表示跟踪2899进程的所有系统调用，并统计系统调用的时间开销，以及调用起始时间(以可视化的时分秒格式显示)，最后将记录结果存入out.txt文件。</p><hr><p><a href="https://www.cnblogs.com/clover-toeic/p/3738156.html" target="_blank" rel="noopener">参(抄)考(袭)资料</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; strace是个功能强大的Linux调试分析诊断工具，可用于跟踪程序执行时进程系统调用(system call)和所接收的信号，尤其是针对源码不可读或源码无法再编译的程序。&lt;/p&gt;
&lt;p&gt;   在Linux系统中，用户程序运行在一个沙箱(sandbox)里，用户进程不能直
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lsof命令</title>
    <link href="http://www.tangyilong.com/2019/05/14/lsof%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.tangyilong.com/2019/05/14/lsof命令/</id>
    <published>2019-05-14T13:25:22.000Z</published>
    <updated>2019-05-15T03:11:50.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-lsof命令详解"><a href="#Linux-lsof命令详解" class="headerlink" title="Linux lsof命令详解"></a>Linux lsof命令详解</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如TC和UDP等，系统在后台都为该应用程序分配了一个<strong>文件描述符</strong>，无论这个文件的本质如何，<strong>该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口</strong>。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的</p><p>在终端下输入lsof即可显示系统打开的文件，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。</p><h2 id="lsof命令输出说明"><a href="#lsof命令输出说明" class="headerlink" title="lsof命令输出说明"></a>lsof命令输出说明</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof [参数][文件]</span><br></pre></td></tr></table></figure><p><strong>lsof输出各列信息的意义如下：</strong></p><p>COMMAND：进程的名称</p><p>PID：进程标识符</p><p>PPID：父进程标识符（需要指定-R参数）</p><p>USER：进程所有者</p><p>FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等</p><p>DEVICE：指定磁盘的名称</p><p>SIZE：文件的大小</p><p>NODE：索引节点（文件在磁盘上的标识）</p><p>NAME：打开文件的确切名称</p><p>FD 列中的文件描述符cwd 值表示应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改,txt 类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序。</p><p>其次数值表示应用程序的文件描述符，这是打开该文件时返回的一个整数。如上的最后一行文件/dev/initctl，其文件描述符为 10。u 表示该文件被打开并处于读取/写入模式，而不是只读(r)或只写 (w) 模式。同时还有大写 的W 表示该应用程序具有对整个文件的写锁。该文件描述符用于确保每次只能打开一个应用程序实例。初始打开每个应用程序时，都具有三个文件描述符，从 0 到 2，分别表示标准输入、输出和错误流。所以大多数应用程序所打开的文件的 FD 都是从 3 开始。</p><p>与 FD 列相比，Type 列则比较直观。文件和目录分别称为 REG 和 DIR。而CHR 和 BLK，分别表示字符和块设备；或者 UNIX、FIFO 和 IPv4，分别表示 UNIX 域套接字、先进先出 (FIFO) 队列和网际协议 (IP) 套接字。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lsof abc.txt 显示开启文件abc.txt的进程</span><br><span class="line">      lsof -c abc 显示abc进程现在打开的文件</span><br><span class="line">      lsof -c -p 1234 列出进程号为1234的进程所打开的文件</span><br><span class="line">      lsof -g gid 显示归属gid的进程情况</span><br><span class="line">      lsof +d /usr/local/ 显示目录下被进程开启的文件</span><br><span class="line">      lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长</span><br><span class="line">      lsof -d 4 显示使用fd为4的进程</span><br><span class="line">      lsof -i 用以显示符合条件的进程情况</span><br><span class="line">      lsof -i[46] [protocol][@hostname|hostaddr][:service|port]</span><br><span class="line">                 --&gt; IPv4 <span class="keyword">or</span> IPv6</span><br><span class="line">                protocol --&gt; TCP <span class="keyword">or</span> UDP</span><br><span class="line">                hostname --&gt; Internet host name</span><br><span class="line">                hostaddr --&gt; IPv4地址</span><br><span class="line">               <span class="built_in"> service </span>--&gt; /etc/service中的<span class="built_in"> service </span>name (可以不止一个)</span><br></pre></td></tr></table></figure><h2 id="怎样使用lsof"><a href="#怎样使用lsof" class="headerlink" title="怎样使用lsof"></a><strong>怎样使用lsof</strong></h2><p>这里主要用案例的形式来介绍lsof 命令的<a href="javascript:;" target="_blank" rel="noopener"><strong>使用</strong></a></p><p><strong>1.列出所有打开的文件:</strong></p><p>lsof</p><p>备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位</p><p><strong>2. 查看谁正在使用某个文件</strong></p><p>lsof   /filepath/file</p><p><strong>3.递归查看某个目录的文件信息</strong></p><p>lsof +D /filepath/filepath2/</p><p>备注: 使用了+D，对应目录下的所有子目录和文件都会被列出</p><p><strong>4. 比使用+D选项，遍历查看某个目录的所有文件信息 的方法</strong></p><p>lsof | grep ‘/filepath/filepath2/’</p><p><strong>5. 列出某个用户打开的文件信息</strong></p><p>lsof  -u username</p><p>备注: -u 选项，u其实是user的缩写</p><p><strong>6. 列出某个程序所打开的文件信息</strong></p><p><strong>lsof -c mysql</strong></p><p>备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成<strong>lsof | grep mysql,</strong>但是第一种方法明显比第二种方法要少打几个字符了</p><p><strong>7. 列出多个程序多打开的文件信息</strong></p><p>lsof -c mysql -c apache</p><p><strong>8. 列出某个用户以及某个程序所打开的文件信息</strong></p><p>lsof -u <a href="javascript:;" target="_blank" rel="noopener"><strong>test</strong></a> -c mysql</p><p><strong>9. 列出除了某个用户外的被打开的文件信息</strong></p><p>lsof   -u ^root</p><p>备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示</p><p><strong>10. 通过某个进程号显示该进行打开的文件</strong></p><p>lsof -p 1</p><p><strong>11. 列出多个进程号对应的文件信息</strong></p><p>lsof -p 123,456,789</p><p><strong>12. 列出除了某个进程号，其他进程号所打开的文件信息</strong></p><p>lsof -p ^1</p><p><strong>13 . 列出所有的网络连接</strong></p><p><strong>lsof -i</strong></p><p><strong>14. 列出所有tcp 网络连接信息</strong></p><p>lsof  -i tcp</p><p><strong>15. 列出所有udp网络连接信息</strong></p><p>lsof  -i udp</p><p><strong>16. 列出谁在使用某个端口</strong></p><p>lsof -i :3306</p><p><strong>17. 列出谁在使用某个特定的udp端口</strong></p><p>lsof -i udp:55</p><p><strong>特定的tcp端口</strong></p><p>lsof -i tcp:80</p><p><strong>18. 列出某个用户的所有活跃的网络端口</strong></p><p>lsof  -a -u test -i</p><p><strong>19. 列出所有网络文件系统</strong></p><p>lsof -N</p><p><strong>20.域名socket文件</strong></p><p>lsof -u</p><p><strong>21.某个用户组所打开的文件信息</strong></p><p>lsof -g 5555</p><p><strong>22. 根据文件描述列出对应的文件信息</strong></p><p>lsof -d description(like 2)</p><p><strong>23. 根据文件描述范围列出文件信息</strong></p><p>lsof -d 2-3</p><hr><p><a href="https://www.cnblogs.com/sparkbj/p/7161669.html" target="_blank" rel="noopener">转</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-lsof命令详解&quot;&gt;&lt;a href=&quot;#Linux-lsof命令详解&quot; class=&quot;headerlink&quot; title=&quot;Linux lsof命令详解&quot;&gt;&lt;/a&gt;Linux lsof命令详解&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows7上开启ftp服务器功能</title>
    <link href="http://www.tangyilong.com/2019/04/13/Windows7%E4%B8%8A%E5%BC%80%E5%90%AFftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.tangyilong.com/2019/04/13/Windows7上开启ftp服务器功能/</id>
    <published>2019-04-13T06:43:10.000Z</published>
    <updated>2019-04-13T06:44:07.178Z</updated>
    
    <content type="html"><![CDATA[<p>Windows7上开启ftp服务器功能</p><p><a href="https://www.cnblogs.com/liangxuru/p/6148212.html" target="_blank" rel="noopener">https://www.cnblogs.com/liangxuru/p/6148212.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Windows7上开启ftp服务器功能&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liangxuru/p/6148212.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解strncpy这个函数</title>
    <link href="http://www.tangyilong.com/2019/04/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3strncpy%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0/"/>
    <id>http://www.tangyilong.com/2019/04/13/深入理解strncpy这个函数/</id>
    <published>2019-04-13T06:42:11.000Z</published>
    <updated>2019-04-13T06:42:39.423Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weibo1230123/article/details/80382614" target="_blank" rel="noopener">https://blog.csdn.net/weibo1230123/article/details/80382614</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weibo1230123/article/details/80382614&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weibo1230123/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ioctl()分析——从用户空间到设备驱动</title>
    <link href="http://www.tangyilong.com/2019/04/13/ioctl-%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E4%BB%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%88%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <id>http://www.tangyilong.com/2019/04/13/ioctl-分析——从用户空间到设备驱动/</id>
    <published>2019-04-13T06:40:52.000Z</published>
    <updated>2019-04-13T06:41:28.687Z</updated>
    
    <content type="html"><![CDATA[<p>ioctl()分析——从用户空间到设备驱动</p><p><a href="https://blog.csdn.net/zifehng/article/details/59576539" target="_blank" rel="noopener">https://blog.csdn.net/zifehng/article/details/59576539</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ioctl()分析——从用户空间到设备驱动&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zifehng/article/details/59576539&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字母对应的ASCII码和CTRL加字母的</title>
    <link href="http://www.tangyilong.com/2019/04/13/%E5%AD%97%E6%AF%8D%E5%AF%B9%E5%BA%94%E7%9A%84ASCII%E7%A0%81%E5%92%8CCTRL%E5%8A%A0%E5%AD%97%E6%AF%8D%E7%9A%84/"/>
    <id>http://www.tangyilong.com/2019/04/13/字母对应的ASCII码和CTRL加字母的/</id>
    <published>2019-04-13T06:22:22.000Z</published>
    <updated>2019-04-13T06:22:45.864Z</updated>
    
    <content type="html"><![CDATA[<p>对于字母的ASCII码来说。网上已经罗列出来了，这是很容易就获取的，然后对于ctrl+字母的以及shift+字母的却有点小难了。</p><p>最近在写脚本的时候，需要用到一些组合键，但是苦于不知道这些组合键对应的键盘码，就很尴尬</p><h2 id="CTRL-字母"><a href="#CTRL-字母" class="headerlink" title="CTRL+字母"></a>CTRL+字母</h2><p>  ASCII码1，2，3…分别依次对应键盘按键的Ctrl+A键，Ctrl+B键，Ctrl+C键，…Ctrl+Z键的ASCII为26.参考大写字母后的编码，按键Ctrl+[键产生ASCII码27，Ctrl+\键产生ASCII码28，Ctrl+]键产生ASCII码29，Ctrl+^键产生ASCII码30。常用的控制字符有退格（8），制表符（9），换行（10）.流量控制字符Xoff（17）和Xon（19），对应的按键分别是Ctrl+S，Ctrl+Q。 </p><p>  按照控制字符ASCII码于键盘按键的对应关系，在一个字符终端输入数据时，按下Ctrl+M与按下回车键的效果相同，应为回车的ASCII是13，M在字母表中排在第13位。同样按下Ctrl+J实际上是一个换行符，没有响应键盘按键对应。按下Ctrl+I与按下Tab键的效果相同，Ctrl+[与ESC相同。可以用Ctrl+H代替BackSpace键，在没有BackSpace的终端上，就是直接按Ctrl+H键。</p><p>ctrl+字母的ASCII码=字母的ASCII码&amp;0x1f</p><p>最后分享一个小软件可以查看对应的按键码，</p><p><a href="https://download.csdn.net/download/softimite_zifeng/9688867" target="_blank" rel="noopener">KeyCode</a></p><h2 id="键盘各键对应的编码值（key-code）"><a href="#键盘各键对应的编码值（key-code）" class="headerlink" title="键盘各键对应的编码值（key code）"></a>键盘各键对应的编码值（key code）</h2><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody><tr><td>backspace</td><td>8</td></tr><tr><td>tab</td><td>9</td></tr><tr><td>enter</td><td>13</td></tr><tr><td>shift</td><td>16</td></tr><tr><td>ctrl</td><td>17</td></tr><tr><td>alt</td><td>18</td></tr><tr><td>pause/break</td><td>19</td></tr><tr><td>caps lock</td><td>20</td></tr><tr><td>escape</td><td>27</td></tr><tr><td>page up</td><td>33</td></tr><tr><td>page down</td><td>34</td></tr><tr><td>end</td><td>35</td></tr><tr><td>home</td><td>36</td></tr><tr><td>left arrow</td><td>37</td></tr><tr><td>up arrow</td><td>38</td></tr><tr><td>right arrow</td><td>39</td></tr><tr><td>down arrow</td><td>40</td></tr><tr><td>insert</td><td>45</td></tr><tr><td>delete</td><td>46</td></tr><tr><td>0</td><td>48</td></tr><tr><td>1</td><td>49</td></tr><tr><td>2</td><td>50</td></tr><tr><td>3</td><td>51</td></tr><tr><td>4</td><td>52</td></tr><tr><td>5</td><td>53</td></tr><tr><td>6</td><td>54</td></tr><tr><td>7</td><td>55</td></tr><tr><td>8</td><td>56</td></tr><tr><td>9</td><td>57</td></tr><tr><td>a</td><td>65</td></tr><tr><td>b</td><td>66</td></tr><tr><td>c</td><td>67</td></tr><tr><td>d</td><td>68</td></tr></tbody></table><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody><tr><td>e</td><td>69</td></tr><tr><td>f</td><td>70</td></tr><tr><td>g</td><td>71</td></tr><tr><td>h</td><td>72</td></tr><tr><td>i</td><td>73</td></tr><tr><td>j</td><td>74</td></tr><tr><td>k</td><td>75</td></tr><tr><td>l</td><td>76</td></tr><tr><td>m</td><td>77</td></tr><tr><td>n</td><td>78</td></tr><tr><td>o</td><td>79</td></tr><tr><td>p</td><td>80</td></tr><tr><td>q</td><td>81</td></tr><tr><td>r</td><td>82</td></tr><tr><td>s</td><td>83</td></tr><tr><td>t</td><td>84</td></tr><tr><td>u</td><td>85</td></tr><tr><td>v</td><td>86</td></tr><tr><td>w</td><td>87</td></tr><tr><td>x</td><td>88</td></tr><tr><td>y</td><td>89</td></tr><tr><td>z</td><td>90</td></tr><tr><td>left window key</td><td>91</td></tr><tr><td>right window key</td><td>92</td></tr><tr><td>select key</td><td>93</td></tr><tr><td>numpad 0</td><td>96</td></tr><tr><td>numpad 1</td><td>97</td></tr><tr><td>numpad 2</td><td>98</td></tr><tr><td>numpad 3</td><td>99</td></tr><tr><td>numpad 4</td><td>100</td></tr><tr><td>numpad 5</td><td>101</td></tr><tr><td>numpad 6</td><td>102</td></tr><tr><td>numpad 7</td><td>103</td></tr></tbody></table><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody><tr><td>numpad 8</td><td>104</td></tr><tr><td>numpad 9</td><td>105</td></tr><tr><td>multiply</td><td>106</td></tr><tr><td>add</td><td>107</td></tr><tr><td>subtract</td><td>109</td></tr><tr><td>decimal point</td><td>110</td></tr><tr><td>divide</td><td>111</td></tr><tr><td>f1</td><td>112</td></tr><tr><td>f2</td><td>113</td></tr><tr><td>f3</td><td>114</td></tr><tr><td>f4</td><td>115</td></tr><tr><td>f5</td><td>116</td></tr><tr><td>f6</td><td>117</td></tr><tr><td>f7</td><td>118</td></tr><tr><td>f8</td><td>119</td></tr><tr><td>f9</td><td>120</td></tr><tr><td>f10</td><td>121</td></tr><tr><td>f11</td><td>122</td></tr><tr><td>f12</td><td>123</td></tr><tr><td>num lock</td><td>144</td></tr><tr><td>scroll lock</td><td>145</td></tr><tr><td>semi-colon</td><td>186</td></tr><tr><td>equal sign</td><td>187</td></tr><tr><td>comma</td><td>188</td></tr><tr><td>dash</td><td>189</td></tr><tr><td>period</td><td>190</td></tr><tr><td>forward slash</td><td>191</td></tr><tr><td>grave accent</td><td>192</td></tr><tr><td>open bracket</td><td>219</td></tr><tr><td>back slash</td><td>220</td></tr><tr><td>close braket</td><td>221</td></tr><tr><td>single quote</td><td>222</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于字母的ASCII码来说。网上已经罗列出来了，这是很容易就获取的，然后对于ctrl+字母的以及shift+字母的却有点小难了。&lt;/p&gt;
&lt;p&gt;最近在写脚本的时候，需要用到一些组合键，但是苦于不知道这些组合键对应的键盘码，就很尴尬&lt;/p&gt;
&lt;h2 id=&quot;CTRL-字母&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>select一直返回0的问题解决和总结</title>
    <link href="http://www.tangyilong.com/2019/04/13/select%E4%B8%80%E7%9B%B4%E8%BF%94%E5%9B%9E0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://www.tangyilong.com/2019/04/13/select一直返回0的问题解决和总结/</id>
    <published>2019-04-13T06:21:29.000Z</published>
    <updated>2019-04-13T06:23:31.902Z</updated>
    
    <content type="html"><![CDATA[<p>select是Linux/Unix环境下的高级网络I/O编程接口，它使我们能够进行基于I/O多路转接。I/0多路转接（multiplexing）的核心思想是：先构造一张有关描述符的列表，然后调用一个函数，直到这些描述符中的一个已经准备好进行I/O时，该函数才返回。在返回时，它告诉进程哪些描述符已准备好可以进行I/O操作。</p><p>在Linux中，我们可以使用select函数实现I/O端口的复用（多路转接），传递给select函数的参数会告诉内核：</p><ul><li><p>我们所关心的描述符，可能为文件描述符或网络套接字描述符。</p></li><li><p>对每个描述符，我们所关心的状态。(我们是要想从一个文件描述符中读或者写，还是关注一个描述符中是否出现异常)</p></li><li><p>我们愿意等待多长时间。(可以无限等待，等待固定的一段时间，或者完全不等待)</p></li></ul><p>从 select函数返回后，内核告诉我们一下信息：</p><ul><li><p>对我们的要求已经做好准备的描述符的个数</p></li><li><p>对于三种状态（读，写或异常）中的每一个，哪些描述符已经做好准备.</p><p>有了这些返回信息，我们可以调用合适的I/O函数(通常是 read 或 write)，并且这些函数不会再阻塞.</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout)</span></span>;</span><br><span class="line">返回值：做好准备的文件描述符的个数，超时为<span class="number">0</span>，错误为 <span class="number">-1.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span>      </span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">/*秒 */</span>  </span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">/*微秒 */</span>     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   首先我们先看一下最后一个参数。它指明我们要等待的时间，有如下三种情况：</p><ul><li><p>timeout == NULL  等待无限长的时间。等待可以被一个信号中断。当有一个描述符做好准备或者是捕获到一个信号时函数会返回。如果捕获到一个信号， select函数将返回 -1,并将变量 erro设为 EINTR。</p></li><li><p>timeout-&gt;tv_sec == 0 &amp;&amp;timeout-&gt;tv_usec == 0不等待，直接返回。加入描述符集的描述符都会被测试，并且返回满足要求的描述符的个数。这种方法通过轮询，无阻塞地获得了多个文件描述符状态。</p></li><li><p>timeout-&gt;tv_sec !=0 ||timeout-&gt;tv_usec!= 0 等待指定的时间。当有描述符符合条件或者超过超时时间的话，函数返回。在超时时间即将用完但又没有描述符合条件的话，返回 0。对于第一种情况，等待也会被信号所中断。</p><p>接着，我们看看中间的三个参数 readset, writset, exceptset,指向描述符集。这些参数指明了我们关心哪些描述符，和需要满足什么条件(可写，可读，异常)。一个文件描述集保存在 fd_set 类型中。fd_set类型变量每一位代表了一个描述符。我们也可以认为它只是一个由很多二进制位构成的数组。</p><p>理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。<br>（1）执行fd_set set;<br>(2) FD_ZERO(&amp;set);则set用位表示是0000,0000。<br>（3）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)<br>（4）若再加入fd＝2，fd=1,则set变为0001,0011<br>（5）执行select(6,&amp;set,0,0,0)阻塞等待<br>（6）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。</p><p>由于我是服务器端主程序，只关心是否收到对端发来的消息或通知事件，因此我只需要监听某个端口，采用select检查相应的套接字描述符是否有数据可读。调用FD_ZERO(&amp;readfds)将一个指定的fd_set变量（read_fds）所有位设置为0，调用FD_SET(m_server_sock, &amp;readfds)将read_fds变量的第m_server_sock个位置1。</p></li><li><p>如果select返回-1，说明有错误；如果为0， 说明超时了；否者说明我们关心的描述符准备好了。对于本文，我关心的是只有一个读文件描述符，当有数据可读时，内核(I/O)根据状态修改文件描述符集，select返回一个大于0的数,该数值表示已经准备好的描述符个数（本文是1，由于我只关心一个描述符）。准备好是什么意思呢？意思是，我关心的读集readfds中的其中一个描述符m_sock_fd描述符，有数据可读了，对其read操作不会阻塞。</p></li></ul><p>select调用是在while 循环loop里，而FD的设置却在while loop之外，即：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds<span class="comment">;</span></span><br><span class="line">FD_ZERO(&amp;readfds)<span class="comment">;</span></span><br><span class="line">FD_SET(m_server_sock, &amp;readfds)<span class="comment">;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> sockfd = <span class="number">-1</span><span class="comment">;</span></span><br><span class="line">  <span class="built_in">int</span> ret = <span class="keyword">select</span>(m_server_sock +<span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)<span class="comment">;</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是这个逻辑有问题呢？于是想到试试看：把FD_SET操作都放到select之前，即统一放到while Loop循环里。没想到，这么一改问题直接就解决了。</p><p>初步分析认为：</p><p>select返回后, 会把以前加入的但并无事件发生的fd从fd_set清除，因此需要重新调用select 前再次把关心的fd添加到FD_SET。否则就会出现本文的现象。</p><p>问题解决：每次调用select之前，调用FD_ZERO清空可读文件句柄集，并调用FD_SET把TCP套接字添加到该fd_set类型的集合中。<br>代码对比：</p><p><img src="/pic/select001.png" alt="img"></p><hr><p><a href="https://blog.csdn.net/acs713/article/details/17531827" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;select是Linux/Unix环境下的高级网络I/O编程接口，它使我们能够进行基于I/O多路转接。I/0多路转接（multiplexing）的核心思想是：先构造一张有关描述符的列表，然后调用一个函数，直到这些描述符中的一个已经准备好进行I/O时，该函数才返回。在返回时，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>串口清空输入输出缓存</title>
    <link href="http://www.tangyilong.com/2019/04/13/%E4%B8%B2%E5%8F%A3%E6%B8%85%E7%A9%BA%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%BC%93%E5%AD%98/"/>
    <id>http://www.tangyilong.com/2019/04/13/串口清空输入输出缓存/</id>
    <published>2019-04-13T06:20:29.000Z</published>
    <updated>2019-04-13T06:21:00.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux串口编程——清空输入输出缓存"><a href="#Linux串口编程——清空输入输出缓存" class="headerlink" title="Linux串口编程——清空输入输出缓存"></a>Linux串口编程——清空输入输出缓存</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我们的工作中，串口是一种比较常用的数据传输方式。在某些应用场景下，当程序启动并打开串口后，我们不希望读出串口打开之前的输入缓存数据（即内核驱动已接收但是并未被应用层读出的数据），因此需要对输入缓存数据进行清空（刷清、丢弃）操作。下面以Linux系统上串口编程为例进行说明：</p><p>测试环境<br>硬件环境：PC<br>操作系统：Ubuntu 14.04虚拟机</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>方法一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"devpath"</span>, O_RDWR|O_NOCTTY);</span><br><span class="line">usleep(<span class="number">200000</span>);</span><br><span class="line">tcflush(fd, TCIFLUSH);    <span class="comment">//清空输入缓存</span></span><br><span class="line">tcflush(fd, TCOFLUSH);    <span class="comment">//清空输出缓存</span></span><br><span class="line">tcflush(fd, TCIOFLUSH);   <span class="comment">//清空输入输出缓存</span></span><br><span class="line">tcsetattr(m_ifd, TCSANOW, &amp;strctNewTermios)；</span><br></pre></td></tr></table></figure><p>方法二<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"devpath"</span>, O_RDWR|O_NOCTTY);</span><br><span class="line">usleep(<span class="number">200000</span>);</span><br><span class="line">ioctl(fd, TCFLSH, <span class="number">0</span>);    <span class="comment">//清空输入缓存</span></span><br><span class="line">ioctl(fd, TCFLSH, <span class="number">1</span>);    <span class="comment">//清空输出缓存</span></span><br><span class="line">ioctl(fd, TCFLSH, <span class="number">2</span>);    <span class="comment">//清空输入输出缓存</span></span><br><span class="line">tcsetattr(fd, TCSANOW, &amp;strctNewTermios)；</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>必须在open和tcflush（或ioctl）操作间进行延时操作（具体时间未做验证），否则没有清空效果，原因未知，可能跟Linux内核版本有关<br>可自由选择只清空输入或只清空输出或两者都清空<br>tcflush和ioctl两种方法均有效，注意ioctl的第二个参数是TCFLSH</p><hr><p><a href="https://blog.csdn.net/zuoao123/article/details/81329875" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux串口编程——清空输入输出缓存&quot;&gt;&lt;a href=&quot;#Linux串口编程——清空输入输出缓存&quot; class=&quot;headerlink&quot; title=&quot;Linux串口编程——清空输入输出缓存&quot;&gt;&lt;/a&gt;Linux串口编程——清空输入输出缓存&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux编程之select</title>
    <link href="http://www.tangyilong.com/2019/04/13/linux%E7%BC%96%E7%A8%8B%E4%B9%8Bselect/"/>
    <id>http://www.tangyilong.com/2019/04/13/linux编程之select/</id>
    <published>2019-04-13T06:15:11.000Z</published>
    <updated>2019-04-13T06:16:27.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux编程之select"><a href="#Linux编程之select" class="headerlink" title="Linux编程之select"></a>Linux编程之select</h1><p>select系统调用的的用途是：在一段指定的时间内，监听用户感兴趣的文件描述符上可读、可写和异常等事件。</p><h2 id="select-机制的优势"><a href="#select-机制的优势" class="headerlink" title="select 机制的优势"></a>select 机制的优势</h2><p>为什么会出现select模型？</p><p>先看一下下面的这句代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iResult = recv(s, <span class="built_in">buffer</span>,<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>这是用来接收数据的，在默认的阻塞模式下的套接字里，recv会阻塞在那里，直到套接字连接上有数据可读，把数据读到buffer里后recv函数才会返回，不然就会一直阻塞在那里。在单线程的程序里出现这种情况会导致主线程（单线程程序里只有一个默认的主线程）被阻塞,这样整个程序被锁死在这里，如果永 远没数据发送过来，那么程序就会被永远锁死。这个问题可以用多线程解决，但是在有多个套接字连接的情况下，这不是一个好的选择，扩展性很差。</p><p>再看代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iResult = ioctlsocket(s, FIOBIO, (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ul);</span><br><span class="line">iResult = recv(s, <span class="built_in">buffer</span>,<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>这一次recv的调用不管套接字连接上有没有数据可以接收都会马上返回。原因就在于我们用ioctlsocket把套接字设置为非阻塞模式了。不过你跟踪一下就会发现，在没有数据的情况下，recv确实是马上返回了，但是也返回了一个错误：WSAEWOULDBLOCK，意思就是请求的操作没有成功完成。</p><p>看到这里很多人可能会说，那么就重复调用recv并检查返回值，直到成功为止，但是这样做效率很成问题，开销太大。</p><p>select模型的出现就是为了解决上述问题。<br>select模型的关键是使用一种有序的方式，对多个套接字进行统一管理与调度 。</p><p><img src="/pic/linux-select001.png" alt="img"></p><p>如上所示，用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。</p><p>从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><p>select流程伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    select(socket);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sockets = select();</span><br><span class="line">        <span class="keyword">for</span>(socket in sockets) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(can_read(socket)) </span><br><span class="line">            &#123;</span><br><span class="line">                read(socket, buffer);</span><br><span class="line">                process(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select相关API介绍与使用"><a href="#select相关API介绍与使用" class="headerlink" title="select相关API介绍与使用"></a>select相关API介绍与使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>maxfdp：被监听的文件描述符的总数，它比所有文件描述符集合中的文件描述符的最大值大1，因为文件描述符是从0开始计数的；</p><p>readfds、writefds、exceptset：分别指向可读、可写和异常等事件对应的描述符集合。</p><p>timeout:用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。timeout == NULL 表示等待无限长的时间</p><p>timeval结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span>      </span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">/*秒 */</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">/*微秒 */</span>   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>返回值：超时返回0;失败返回-1；成功返回大于0的整数，这个整数表示就绪描述符的数目。</p><p>以下介绍与select函数相关的常见的几个宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">//一个 fd_set类型变量的所有位都设为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">//清除某个位时可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fd_set)</span></span>;   <span class="comment">//设置变量的某个位置位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">//测试某个位是否被置位</span></span><br></pre></td></tr></table></figure><p>select使用范例：<br>当声明了一个文件描述符集后，必须用FD_ZERO将所有位置零。之后将我们所感兴趣的描述符所对应的位置位，操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd_set rset;   </span><br><span class="line"><span class="keyword">int</span> fd;   </span><br><span class="line">FD_ZERO(&amp;rset);   </span><br><span class="line">FD_SET(fd, &amp;rset);   </span><br><span class="line">FD_SET(<span class="built_in">stdin</span>, &amp;rset);</span><br></pre></td></tr></table></figure><p>然后调用select函数，拥塞等待文件描述符事件的到来；如果超过设定的时间，则不再等待，继续往下执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(fd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>select返回后，用FD_ISSET测试给定位是否置位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(FD_ISSET(fd, &amp;rset)   </span><br><span class="line">&#123; </span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个最简单的select的使用例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set rd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rd);</span><br><span class="line">    FD_SET(<span class="number">0</span>,&amp;rd);</span><br><span class="line">    </span><br><span class="line">    tv.tv_sec = <span class="number">5</span>;</span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    err = select(<span class="number">1</span>,&amp;rd,<span class="literal">NULL</span>,<span class="literal">NULL</span>,&amp;tv);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(err == <span class="number">0</span>) <span class="comment">//超时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"select time out!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(err == <span class="number">-1</span>)  <span class="comment">//失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail to select!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"data is available!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行该程序并且随便输入一些数据，程序就提示收到数据了。<br><img src="/pic/linux-select002.png" alt="img"></p><h2 id="深入理解select模型："><a href="#深入理解select模型：" class="headerlink" title="深入理解select模型："></a>深入理解select模型：</h2><p>理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。</p><p>（1）执行fd_set set; FD_ZERO(&amp;set); 则set用位表示是0000,0000。</p><p>（2）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)</p><p>（3）若再加入fd＝2，fd=1,则set变为0001,0011</p><p>（4）执行select(6,&amp;set,0,0,0)阻塞等待</p><p>（5）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。</p><p>基于上面的讨论，可以轻松得出select模型的特点：</p><p>（1）可监控的文件描述符个数取决与sizeof(fd_set)的值。我这边服务器上sizeof(fd_set)＝512，每bit表示一个文件描述符，则我服务器上支持的最大文件描述符是512*8=4096。据说可调，另有说虽然可调，但调整上限受于编译内核时的变量值。</p><p>（2）将fd加入select监控集的同时，还要再使用一个数据结构array保存放到select监控集中的fd，一是用于再select返回后，array作为源数据和fd_set进行FD_ISSET判断。二是select返回后会把以前加入的但并无事件发生的fd清空，则每次开始select前都要重新从array取得fd逐一加入（FD_ZERO最先），扫描array的同时取得fd最大值maxfd，用于select的第一个参数。</p><p>（3）可见select模型必须在select前循环加fd，取maxfd，select返回后利用FD_ISSET判断是否有事件发生。</p><h2 id="用select处理带外数据"><a href="#用select处理带外数据" class="headerlink" title="用select处理带外数据"></a>用select处理带外数据</h2><p>网络程序中，select能处理的异常情况只有一种：socket上接收到带外数据。</p><p>什么是带外数据？</p><p>带外数据(out—of—band data)，有时也称为加速数据(expedited data)，<br>是指连接双方中的一方发生重要事情，想要迅速地通知对方。<br>这种通知在已经排队等待发送的任何“普通”(有时称为“带内”)数据之前发送。<br>带外数据设计为比普通数据有更高的优先级。<br>带外数据是映射到现有的连接中的，而不是在客户机和服务器间再用一个连接。</p><p>我们写的select程序经常都是用于接收普通数据的，当我们的服务器需要同时接收普通数据和带外数据，我们如何使用select进行处理二者呢？</p><p>下面给出一个小demo：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage: ip address + port numbers\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"ip: %s\n"</span>,ip);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"port: %d\n"</span>,port);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    bzero(&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET,ip,&amp;address.sin_addr);</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(listenfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail to create listen socket!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = bind(listenfd,(struct sockaddr*)&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail to bind socket!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret = listen(listenfd,<span class="number">5</span>); <span class="comment">//监听队列最大排队数设置为5</span></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail to listen socket!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span>  <span class="comment">//记录进行连接的客户端的地址</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">    <span class="keyword">int</span> connfd = accept(listenfd,(struct sockaddr*)&amp;client_address,&amp;client_addrlength);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail to accept!\n"</span>);</span><br><span class="line">        close(listenfd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>]; <span class="comment">//数据接收缓冲区</span></span><br><span class="line">    fd_set read_fds;  <span class="comment">//读文件操作符</span></span><br><span class="line">    fd_set exception_fds; <span class="comment">//异常文件操作符</span></span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    FD_ZERO(&amp;exception_fds);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buff,<span class="number">0</span>,<span class="keyword">sizeof</span>(buff));</span><br><span class="line">        <span class="comment">/*每次调用select之前都要重新在read_fds和exception_fds中设置文件描述符connfd，因为事件发生以后，文件描述符集合将被内核修改*/</span></span><br><span class="line">        FD_SET(connfd,&amp;read_fds);</span><br><span class="line">        FD_SET(connfd,&amp;exception_fds);</span><br><span class="line">        </span><br><span class="line">        ret = select(connfd+<span class="number">1</span>,&amp;read_fds,<span class="literal">NULL</span>,&amp;exception_fds,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Fail to select!\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(connfd, &amp;read_fds))</span><br><span class="line">        &#123;</span><br><span class="line">            ret = recv(connfd,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"get %d bytes of normal data: %s \n"</span>,ret,buff);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(FD_ISSET(connfd,&amp;exception_fds)) <span class="comment">//异常事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ret = recv(connfd,buff,<span class="keyword">sizeof</span>(buff)<span class="number">-1</span>,MSG_OOB);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"get %d bytes of exception data: %s \n"</span>,ret,buff);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(connfd);</span><br><span class="line">    close(listenfd);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用select来解决socket中的多客户问题"><a href="#用select来解决socket中的多客户问题" class="headerlink" title="用select来解决socket中的多客户问题"></a>用select来解决socket中的多客户问题</h2><p>上面提到过，，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。在网络编程中，当涉及到多客户访问服务器的情况，我们首先想到的办法就是fork出多个进程来处理每个客户连接。现在，我们同样可以使用select来处理多客户问题，而不用fork。</p><p>服务器端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> server_sockfd, client_sockfd; </span><br><span class="line">    <span class="keyword">int</span> server_len, client_len; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span> </span><br><span class="line">    <span class="keyword">int</span> result; </span><br><span class="line">    fd_set readfds, testfds; </span><br><span class="line">    server_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立服务器端socket </span></span><br><span class="line">    server_address.sin_family = AF_INET; </span><br><span class="line">    server_address.sin_addr.s_addr = htonl(INADDR_ANY); </span><br><span class="line">    server_address.sin_port = htons(<span class="number">8888</span>); </span><br><span class="line">    server_len = <span class="keyword">sizeof</span>(server_address); </span><br><span class="line">    bind(server_sockfd, (struct sockaddr *)&amp;server_address, server_len); </span><br><span class="line">    listen(server_sockfd, <span class="number">5</span>); <span class="comment">//监听队列最多容纳5个 </span></span><br><span class="line">    FD_ZERO(&amp;readfds); </span><br><span class="line">    FD_SET(server_sockfd, &amp;readfds);<span class="comment">//将服务器端socket加入到集合中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> ch; </span><br><span class="line">        <span class="keyword">int</span> fd; </span><br><span class="line">        <span class="keyword">int</span> nread; </span><br><span class="line">        testfds = readfds;<span class="comment">//将需要监视的描述符集copy到select查询队列中，select会对其修改，所以一定要分开使用变量 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"server waiting\n"</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*无限期阻塞，并测试文件描述符变动 */</span></span><br><span class="line">        result = select(FD_SETSIZE, &amp;testfds, (fd_set *)<span class="number">0</span>,(fd_set *)<span class="number">0</span>, (struct timeval *) <span class="number">0</span>); <span class="comment">//FD_SETSIZE：系统默认的最大文件描述符</span></span><br><span class="line">        <span class="keyword">if</span>(result &lt; <span class="number">1</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            perror(<span class="string">"server5"</span>); </span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/*扫描所有的文件描述符*/</span></span><br><span class="line">        <span class="keyword">for</span>(fd = <span class="number">0</span>; fd &lt; FD_SETSIZE; fd++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*找到相关文件描述符*/</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(fd,&amp;testfds)) </span><br><span class="line">            &#123; </span><br><span class="line">              <span class="comment">/*判断是否为服务器套接字，是则表示为客户请求连接。*/</span></span><br><span class="line">                <span class="keyword">if</span>(fd == server_sockfd) </span><br><span class="line">                &#123; </span><br><span class="line">                    client_len = <span class="keyword">sizeof</span>(client_address); </span><br><span class="line">                    client_sockfd = accept(server_sockfd, </span><br><span class="line">                    (struct sockaddr *)&amp;client_address, &amp;client_len); </span><br><span class="line">                    FD_SET(client_sockfd, &amp;readfds);<span class="comment">//将客户端socket加入到集合中</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"adding client on fd %d\n"</span>, client_sockfd); </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">/*客户端socket中有数据请求时*/</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123; </span><br><span class="line">                    ioctl(fd, FIONREAD, &amp;nread);<span class="comment">//取得数据量交给nread</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/*客户数据请求完毕，关闭套接字，从集合中清除相应描述符 */</span></span><br><span class="line">                    <span class="keyword">if</span>(nread == <span class="number">0</span>) </span><br><span class="line">                    &#123; </span><br><span class="line">                        close(fd); </span><br><span class="line">                        FD_CLR(fd, &amp;readfds); <span class="comment">//去掉关闭的fd</span></span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"removing client on fd %d\n"</span>, fd); </span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">/*处理客户数据请求*/</span></span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123; </span><br><span class="line">                        read(fd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">                        sleep(<span class="number">5</span>); </span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"serving client on fd %d\n"</span>, fd); </span><br><span class="line">                        ch++; </span><br><span class="line">                        write(fd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">                    &#125; </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> client_sockfd; </span><br><span class="line">    <span class="keyword">int</span> len; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span><span class="comment">//服务器端网络地址结构体 </span></span><br><span class="line">     <span class="keyword">int</span> result; </span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'A'</span>; </span><br><span class="line">    client_sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//建立客户端socket </span></span><br><span class="line">    address.sin_family = AF_INET; </span><br><span class="line">    address.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">    address.sin_port = htons(<span class="number">8888</span>); </span><br><span class="line">    len = <span class="keyword">sizeof</span>(address); </span><br><span class="line">    result = connect(client_sockfd, (struct sockaddr *)&amp;address, len); </span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">-1</span>) </span><br><span class="line">    &#123; </span><br><span class="line">         perror(<span class="string">"oops: client2"</span>); </span><br><span class="line">         <span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//第一次读写</span></span><br><span class="line">    write(client_sockfd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">    read(client_sockfd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the first time: char from server = %c\n"</span>, ch); </span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二次读写</span></span><br><span class="line">    write(client_sockfd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">    read(client_sockfd, &amp;ch, <span class="number">1</span>); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the second time: char from server = %c\n"</span>, ch);</span><br><span class="line">    </span><br><span class="line">    close(client_sockfd); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行流程：</p><p>客户端：启动-&gt;连接服务器-&gt;发送A-&gt;等待服务器回复-&gt;收到B-&gt;再发B给服务器-&gt;收到C-&gt;结束</p><p>服务器：启动-&gt;select-&gt;收到A-&gt;发A+1回去-&gt;收到B-&gt;发B+1过去</p><p>测试：我们先运行服务器，再运行客户端<br><img src="/pic/linux-select003.png" alt="img"></p><h2 id="select总结："><a href="#select总结：" class="headerlink" title="select总结："></a>select总结：</h2><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><p>1、单个进程可监视的fd数量被限制，即能监听端口的大小有限。一般来说这个数目和系统内存关系很大，具体数目可以cat/proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p><p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</p><hr><p><a href="https://www.cnblogs.com/skyfsm/p/7079458.html" target="_blank" rel="noopener">转</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux编程之select&quot;&gt;&lt;a href=&quot;#Linux编程之select&quot; class=&quot;headerlink&quot; title=&quot;Linux编程之select&quot;&gt;&lt;/a&gt;Linux编程之select&lt;/h1&gt;&lt;p&gt;select系统调用的的用途是：在一段指定的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>select-poll-epoll的简介和区别</title>
    <link href="http://www.tangyilong.com/2019/04/13/select-poll-epoll%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://www.tangyilong.com/2019/04/13/select-poll-epoll的简介和区别/</id>
    <published>2019-04-13T06:14:21.000Z</published>
    <updated>2019-04-13T06:14:50.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h1><p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><h3 id="select："><a href="#select：" class="headerlink" title="select："></a><strong>select：</strong></h3><p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p><p>1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。</p><p>​    一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p><p>2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：</p><p>   当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><p>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p><h3 id="poll："><a href="#poll：" class="headerlink" title="poll："></a><strong>poll：</strong></h3><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><p>它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：</p><p>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                   </p><p>2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll:"></a><strong>epoll:</strong></h3><p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p><strong>epoll为什么要有EPOLLET触发模式？</strong></p><p>如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率.。而采用EPOLLET这种边沿触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！<strong>这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符</strong></p><p><strong>epoll的优点：</strong></p><p>1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><p>3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</p><h3 id="select、poll、epoll-区别总结："><a href="#select、poll、epoll-区别总结：" class="headerlink" title="select、poll、epoll 区别总结："></a><strong>select、poll、epoll 区别总结：</strong></h3><p>1、支持一个进程所能打开的最大连接数</p><p>select</p><p>单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p><p>poll</p><p>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</p><p>epoll</p><p>虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</p><p>2、FD剧增后带来的IO效率问题</p><p>select</p><p>因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p><p>poll</p><p>同上</p><p>epoll</p><p>因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p><p>3、 消息传递方式</p><p>select</p><p>内核需要将消息传递到用户空间，都需要内核拷贝动作</p><p>poll</p><p>同上</p><p>epoll</p><p>epoll通过内核和用户空间共享一块内存来实现的。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p><strong>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</strong></p><p><strong>1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</strong></p><p><strong>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</strong></p><hr><p><a href="https://www.cnblogs.com/zhaodahai/p/6831456.html" target="_blank" rel="noopener">转</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;select、poll、epoll简介&quot;&gt;&lt;a href=&quot;#select、poll、epoll简介&quot; class=&quot;headerlink&quot; title=&quot;select、poll、epoll简介&quot;&gt;&lt;/a&gt;select、poll、epoll简介&lt;/h1&gt;&lt;p&gt;ep
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Struct tm</title>
    <link href="http://www.tangyilong.com/2019/04/13/Struct-tm/"/>
    <id>http://www.tangyilong.com/2019/04/13/Struct-tm/</id>
    <published>2019-04-13T06:13:28.000Z</published>
    <updated>2019-04-13T06:14:00.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间操作（struct-tm、time-t）求指定日期-前n天的日期"><a href="#时间操作（struct-tm、time-t）求指定日期-前n天的日期" class="headerlink" title="时间操作（struct tm、time_t）求指定日期 前n天的日期"></a>时间操作（struct tm、time_t）求指定日期 前n天的日期</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TM_DEFINED</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> tm_sec; <span class="comment">/* 秒–取值区间为[0,59] */</span></span><br><span class="line"><span class="keyword">int</span> tm_min; <span class="comment">/* 分 - 取值区间为[0,59] */</span></span><br><span class="line"><span class="keyword">int</span> tm_hour; <span class="comment">/* 时 - 取值区间为[0,23] */</span></span><br><span class="line"><span class="keyword">int</span> tm_mday; <span class="comment">/* 一个月中的日期 - 取值区间为[1,31] */</span></span><br><span class="line"><span class="keyword">int</span> tm_mon; <span class="comment">/* 月份（从一月开始，0代表一月） - 取值区间为[0,11] */</span></span><br><span class="line"><span class="keyword">int</span> tm_year; <span class="comment">/* 年份，其值从1900开始 */</span></span><br><span class="line"><span class="keyword">int</span> tm_wday; <span class="comment">/* 星期–取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推 */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> __int64 <span class="keyword">__time64_t</span>;     <span class="comment">/* 64-bit time value */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__time64_t</span> <span class="keyword">time_t</span>;      <span class="comment">/* time value */</span></span><br><span class="line"><span class="comment">/* time_t 是一种时间类型，一般用来存放格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数 */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNDaysGapDate</span><span class="params">(<span class="keyword">int</span> iNowDate, <span class="keyword">int</span> iNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">ptm</span>;</span></span><br><span class="line">    ptm.tm_year = iNowDate / <span class="number">10000</span> % <span class="number">10000</span> - <span class="number">1900</span>;</span><br><span class="line">    ptm.tm_mon  = iNowDate / <span class="number">100</span> % <span class="number">100</span> - <span class="number">1</span>;</span><br><span class="line">    ptm.tm_mday = iNowDate % <span class="number">100</span>;</span><br><span class="line">    ptm.tm_hour = <span class="number">0</span>;</span><br><span class="line">    ptm.tm_min  = <span class="number">0</span>;</span><br><span class="line">    ptm.tm_sec  = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">time_t</span> timep;</span><br><span class="line">    timep = mktime(&amp;ptm); <span class="comment">//mktime把struct tm类型转换成time_t</span></span><br><span class="line">    timep += iNum * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line"> </span><br><span class="line">    ptm = *localtime(&amp;timep); <span class="comment">//localtime把time_t类型转换成struct tm</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (ptm.tm_year + <span class="number">1900</span>) * <span class="number">10000</span> + (ptm.tm_mon + <span class="number">1</span>) * <span class="number">100</span> + ptm.tm_mday;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> iDate = <span class="number">20170120</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">int</span> iPre30Date = GetNDaysGapDate(iDate, (<span class="number">-1</span>)*n); <span class="comment">//获取 iDate 30天前的日期</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//距9：30的分钟数可以表示成：</span></span><br><span class="line">    min =  ptm.tm_hour*<span class="number">60</span> + ptm.tm_min - （<span class="number">9</span>*<span class="number">60</span> + <span class="number">30</span>）;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// long 型可直接赋值给 time_t 对象</span></span><br><span class="line"><span class="keyword">long</span> lTime = <span class="number">1513318455</span>;</span><br><span class="line"><span class="keyword">time_t</span> timestamp = <span class="number">1513318455</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">ptm</span>;</span></span><br><span class="line">ptm = *localtime(&amp;timestamp);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//获取当前时间戳</span></span><br><span class="line"><span class="keyword">time_t</span> timep;</span><br><span class="line">time(&amp;timep);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; timep &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/SZxiaochun/p/6377373.html" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时间操作（struct-tm、time-t）求指定日期-前n天的日期&quot;&gt;&lt;a href=&quot;#时间操作（struct-tm、time-t）求指定日期-前n天的日期&quot; class=&quot;headerlink&quot; title=&quot;时间操作（struct tm、time_t）求指
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>谷歌浏览器安装插件</title>
    <link href="http://www.tangyilong.com/2019/04/13/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
    <id>http://www.tangyilong.com/2019/04/13/谷歌浏览器安装插件/</id>
    <published>2019-04-13T06:09:23.000Z</published>
    <updated>2019-04-13T06:13:06.100Z</updated>
    
    <content type="html"><![CDATA[<p>忘记了是由于什么安全的原因，现在chrome无法直接安装插件了</p><p><img src="/pic/google001.png" alt="img1"></p><p>首先下载浏览器插件crx文件，鼠标右键修改文件名后缀由crx改为rar</p><p>解压成文件夹，打开浏览器，依次点击浏览器的右上角，更多工具，扩展程序，打开右上角的开发者模式开关。</p><p><img src="/pic/google002.png" alt="img2"></p><p>点击加载已解压的扩展程序，选择之前解压的扩展程序目录，点击确认，可以看到对应的扩展程序已经安装好了。</p><p><img src="/pic/google003.png" alt="img3"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;忘记了是由于什么安全的原因，现在chrome无法直接安装插件了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/pic/google001.png&quot; alt=&quot;img1&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先下载浏览器插件crx文件，鼠标右键修改文件名后缀由crx改为rar&lt;/p&gt;
&lt;p&gt;解压成文件夹
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>makefile &#39;@&#39; &#39;$&#39; &#39;1828&#39; &#39;-&#39; &#39;-n &#39; &#39; $^&#39;使用小结</title>
    <link href="http://www.tangyilong.com/2019/04/13/makefile-1828-n-%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
    <id>http://www.tangyilong.com/2019/04/13/makefile-1828-n-使用小结/</id>
    <published>2019-04-13T06:07:04.000Z</published>
    <updated>2019-04-13T06:08:43.085Z</updated>
    
    <content type="html"><![CDATA[<p>编译代码时，会进程接触makefile，会涉及到一些符号，由于不明白有些意思经常出现问题，在此归纳一下。</p><p>‘@’  符号的使用<br>   通常makefile会将其执行的命令行在执行前输出到屏幕上。如果将‘@’添加到命令行前，这个命令将不被make回显出来。<br>   例如：@echo –compiling module—-;  // 屏幕输出 –compiling module—-<br>         echo –compiling module—-;  // 没有@ 屏幕输出echo –compiling module—-    </p><p>‘ - ‘ 符号的使用<br>   通常删除，创建文件如果碰到文件不存在或者已经创建，那么希望忽略掉这个错误，继续执行，就可以在命令前面添加 -，<br>   -rm dir；<br>   -mkdir aaadir；</p><p><code>$</code>  符号的使用<br>   美元符号<code>$</code>，主要扩展打开makefile中定义的变量</p><p><code>$$</code>  符号的使用<br>  <code>$$</code> 符号主要扩展打开makefile中定义的shell变量</p><p>例如：<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> $(subdirs); <span class="keyword">do</span> \</span><br><span class="line">    @<span class="built_in">echo</span> compiling $$<span class="built_in">dir</span>; \</span><br><span class="line">    $(MAKE) -C</span><br><span class="line">    <span class="built_in">dir</span>||<span class="keyword">exit</span>"</span><br><span class="line">    <span class="built_in">dir</span>||<span class="keyword">exit</span>"</span><br><span class="line">    ?"; \</span><br><span class="line"> done</span><br></pre></td></tr></table></figure></p><p>以上subdir属于makefile中定义的变量，而dir则属于makefile中定义的shell变量，所有使用是使用 ‘ ​$$ ’ 而不是 ‘ $ ‘。</p><p>如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。 </p><p>而make参数“-s”或“–slient”则是全面禁止命令的显示。</p><p>补充说明自动化变量：<br><code>$@</code> 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”​$@”就是匹配于目标中模式定义的集合。</p><p><code>$%</code> 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</p><p><code>$&lt;</code>  依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p><p><code>$?</code>  所有比目标新的依赖目标的集合。以空格分隔。</p><p><code>$^</code>   所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份</p><hr><p>原文：<a href="https://blog.csdn.net/kehyuanyu/article/details/21454789" target="_blank" rel="noopener">https://blog.csdn.net/kehyuanyu/article/details/21454789</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编译代码时，会进程接触makefile，会涉及到一些符号，由于不明白有些意思经常出现问题，在此归纳一下。&lt;/p&gt;
&lt;p&gt;‘@’  符号的使用&lt;br&gt;   通常makefile会将其执行的命令行在执行前输出到屏幕上。如果将‘@’添加到命令行前，这个命令将不被make回显出来。
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo不显示图片,不需要插件,超简单</title>
    <link href="http://www.tangyilong.com/2019/02/20/Hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87-%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8F%92%E4%BB%B6-%E8%B6%85%E7%AE%80%E5%8D%95/"/>
    <id>http://www.tangyilong.com/2019/02/20/Hexo插入图片-不需要插件-超简单/</id>
    <published>2019-02-20T13:02:42.000Z</published>
    <updated>2019-02-20T13:06:34.149Z</updated>
    
    <content type="html"><![CDATA[<p>当使用Hexo创建文件搭建博客的时候，就会遇到图片插图，以及插入的图片无法显示的问题，差不多网上大多数的解决方案就是第一种（但我本人没使用这个方案）</p><h2 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h2><p>1.找到<code>Hexo</code>下的<code>_config.yml</code>里的<code>post_asset_folder</code>，把这个选项从<code>false</code>改成<code>true</code></p><p>2.在<code>Hexo</code>目录下打开Git Brsh，执行一个下载上传图片插件的命令<code>npm install hexo-asset-image --save</code>。</p><p>3.继续在Git Brsh下利用<code>hexo n &quot;xxxx&quot;</code>来生成md的文件（” “里的内容填自己的文件名），这时就会在同级的目录下生成一个同名的文件夹。</p><p>4.在<code>.md</code>的文件中要插入图片时，先要把所要插入的图片放在生成的同名文件夹下。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">你想输入的替代文字</span>](<span class="link">xxxx/图片名.jpg</span>)</span><br></pre></td></tr></table></figure><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><p>上面的方案是一种解决方法，那么接下来我自己找到解决方案分享给大家，个人感觉更加简单方便。</p><p>在Hexo的目录source中创建一个图片文件夹，例如pic</p><p><img src="/pic/Hexo-pic001.png" alt="img1"></p><p>把你要插入的图片文件放到该目录下面，在你的文章中正常使用markdown的语法插入图片即可</p><p>例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">img</span>](<span class="link">/pic/xxx.png</span>)</span><br></pre></td></tr></table></figure><p>到此你就完成了插图，并且图片在你的博客上面也会正常显示！</p><p>记住在pic前面有一个<code>/</code>,表示根目录的意思，因为对于hexo来说它的资源文件的根目录就是source,当然你也可以修改_config.yml改变这个配置</p><p><img src="/pic/Hexo-pic002.png" alt="img2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当使用Hexo创建文件搭建博客的时候，就会遇到图片插图，以及插入的图片无法显示的问题，差不多网上大多数的解决方案就是第一种（但我本人没使用这个方案）&lt;/p&gt;
&lt;h2 id=&quot;第一种&quot;&gt;&lt;a href=&quot;#第一种&quot; class=&quot;headerlink&quot; title=&quot;第一种&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vim快速查找</title>
    <link href="http://www.tangyilong.com/2019/02/20/vim%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE/"/>
    <id>http://www.tangyilong.com/2019/02/20/vim快速查找/</id>
    <published>2019-02-20T11:40:46.000Z</published>
    <updated>2019-02-20T11:41:10.304Z</updated>
    
    <content type="html"><![CDATA[<p> vim有强大的字符串查找功能。</p><p>   我们通常在vim下要查找字符串的时候， 都是输入 / 或者 ？  加 需要查找的字符串来进行搜索，比如想搜索 super 这个单词， 可以输入  /super  或者  ？super，  两者的区别是前者是从上往下搜索，后者是从下往上搜索。<br>   那么如果我想搜索本行中某个单词，并且这个单词很长的时候， 手动输入该字符串是非常麻烦的， 当然可以使用模糊匹配(如* 或 ？)来做， 不过这样可能搜得到很多其他的，不完全匹配的字符串。<br>   可以使用如下方式来实现快速查找：</p><p>1， 最快的方式是让光标停留在想要查找的单词的任意一个字母上面， 然后输入<code>Shift + *</code>，即可快速选中该单词，并且可以通过<code>n</code>或<code>N</code>进行上一个或下一个的匹配。</p><p>2， 让光标停留在单词的第一个字母上， 然后输入yw拷贝该单词， 然后输入 / (Ctrl + R) 0 （即 /“0），回车， 就查找到了第一个匹配的单词， 并且可以通过<code>n</code>或<code>N</code>进行上一个或下一个的匹配。</p><p>解释一下：</p><p>Ctrl + r 是指使用寄存器 ， 你会发现先输入/ ， 然后输入 Ctrl + r , 会立刻变为 “ ， 即寄存器的前缀， 然后 “0 就可以理解了吧？ 合起来就是 /“0， 就是查找刚才复制的那个单词，</p><p>3， 还有一种方式， 和第二种方式差不多，不过是将单词拷贝到系统剪贴板， 然后再从系统剪贴板拿出来。 即选中需要查找的单词， 然后输入 “”+y， 然后输入/（Shfit + Ctrl + v）， 就查找到了第一个匹配的单词， 并且可以通过<code>n</code>或<code>N</code>进行上一个或下一个的匹配。</p><p>以上， 最方便的还是第一种， 高效快捷， 值得推荐！！</p><hr><p>原文：<a href="https://blog.csdn.net/ballack_linux/article/details/53187283" target="_blank" rel="noopener">https://blog.csdn.net/ballack_linux/article/details/53187283</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; vim有强大的字符串查找功能。&lt;/p&gt;
&lt;p&gt;   我们通常在vim下要查找字符串的时候， 都是输入 / 或者 ？  加 需要查找的字符串来进行搜索，比如想搜索 super 这个单词， 可以输入  /super  或者  ？super，  两者的区别是前者是从上往下搜索，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>container_of图文分析</title>
    <link href="http://www.tangyilong.com/2019/02/20/container-of%E5%9B%BE%E6%96%87%E5%88%86%E6%9E%90/"/>
    <id>http://www.tangyilong.com/2019/02/20/container-of图文分析/</id>
    <published>2019-02-20T11:39:45.000Z</published>
    <updated>2019-02-20T12:21:16.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="container-of-函数分析"><a href="#container-of-函数分析" class="headerlink" title="container of()函数分析"></a>container of()函数分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Container_of在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲<strong>就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。</strong></p><p>Container_of的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> container_of(ptr, type, member) (&#123;    \</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">typeof</span><span class="params">( ((type *)<span class="number">0</span>)-&gt;member )</span> *__mptr </span>= (ptr);    \</span><br><span class="line">(type *)( (<span class="keyword">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure><p><img src="/pic/container_of.png" alt="img"></p><p> 其实，原理很简单：  已知结构体type的成员member的地址ptr，求解结构体type的起始地址。</p><p>​                  type的起始地址 = ptr - size      (这里需要都转换为char *，因为它为单位字节)。</p><p>具体来说分为两步：</p><p>   第一步，首先定义一个临时的数据类型（通过typeof( ((type *)0)-&gt;member )获得）与ptr相同的指针变量__mptr，然后用它来保存ptr的值。<br>   第二步，用(char *)__mptr减去member在结构体中的偏移量，得到的值就是整个结构体变量的首地址（整个宏的返回值就是这个首地址）。</p><p>==把mptr指针强转成(char *)是因为，char指针减法只移一个字节，如果这样才可能得出准确的地址，否则，改为int类型，在减1就移动4个就乱了。==</p><h2 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h2><p>其中的语法难点就是如何得出成员相对结构体的偏移量？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-2.6.38.8/include/linux/compiler-gcc4.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __compiler_offsetof(a,b) __builtin_offsetof(a,b)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* linux-2.6.38.8/include/linux/stddef.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> offsetof</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __compiler_offsetof</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">float</span> fl;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offsetof(struct test_struct, num) = %d\n"</span>, </span><br><span class="line">offsetof(struct test_struct, num));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offsetof(struct test_struct,  ch) = %d\n"</span>, </span><br><span class="line">offsetof(struct test_struct, ch));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"offsetof(struct test_struct,  fl) = %d\n"</span>, </span><br><span class="line">offsetof(struct test_struct, fl));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明，__builtin_offsetof(a,b)是GCC的内置函数，可认为它的实现与((size_t) &amp;((TYPE *)0)-&gt;MEMBER)这段代码是一致的。</p><p>​    例子输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">offsetof(struct test_struct, num) = 0</span><br><span class="line">offsetof(struct test_struct,  ch) = 4</span><br><span class="line">offsetof(struct test_struct,  fl) = 8</span><br></pre></td></tr></table></figure><p>其中代码难以理解的地方就是它灵活地运用了0地址。如果觉得&amp;( (struct test_struct <em>)0 )-&gt;ch这样的代码不好理解，那么我们可以假设在0地址分配了一个结构体变量struct test_struct a，然后定义结构体指针变量p并指向a（struct test_struct </em>p = &amp;a），如此我们就可以通过&amp;p-&gt;ch获得成员ch的地址。由于a的首地址为0x0，所以成员ch的首地址为0x4</p><p><img src="/pic/container_of002.gif" alt="img2"></p><p>最后通过强制类型转换（size_t）把一个地址值转换为一个整数</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   container_of（ptr, type,member）函数的实现包括两部分：</p><p>​    1、判断ptr 与 member 是否为同意类型</p><p>​    2、计算size大小，结构体的起始地址 = (type <em>)((char </em>)ptr - size)   (注：强转为该结构体指针)</p><p>   现在我们知道container_of()的作用就是通过一个结构变量中一个成员的地址找到这个结构体变量的首地址。</p><p>   container_of(ptr,type,member),这里面有ptr,type,member分别代表指针、类型、成员。</p><hr><p><a href="https://blog.csdn.net/npy_lp/article/details/7010752" target="_blank" rel="noopener">https://blog.csdn.net/npy_lp/article/details/7010752</a></p><p><a href="https://blog.csdn.net/s2603898260/article/details/79371024" target="_blank" rel="noopener">https://blog.csdn.net/s2603898260/article/details/79371024</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;container-of-函数分析&quot;&gt;&lt;a href=&quot;#container-of-函数分析&quot; class=&quot;headerlink&quot; title=&quot;container of()函数分析&quot;&gt;&lt;/a&gt;container of()函数分析&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
