<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>as3522</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.tangyilong.com/"/>
  <updated>2019-07-28T11:24:21.891Z</updated>
  <id>http://www.tangyilong.com/</id>
  
  <author>
    <name>as3522</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PF_PACKET</title>
    <link href="http://www.tangyilong.com/2019/07/28/PF-PACKET/"/>
    <id>http://www.tangyilong.com/2019/07/28/PF-PACKET/</id>
    <published>2019-07-28T11:09:36.000Z</published>
    <updated>2019-07-28T11:24:21.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PF-PACKET"><a href="#PF-PACKET" class="headerlink" title="PF_PACKET"></a>PF_PACKET</h1><p>瞅代码的时候，看到一个很奇特的socket，sock=socket(PF_PACKET, SOCK_RAW, htons(0x8888))</p><p>那什么是PF_PACKET?我在网上翻了一下，找到了一片不错的文章，详细</p><p>sock_raw（注意一定要在root下使用）原始套接字编程可以接收到本机网卡上的数据帧或者数据包,对于监听网络的流量和分析是很有作用的.一共可以有3种方式创建这种socket</p><p>1.socket(AF_INET, SOCK_RAW, IPPROTO_TCP|IPPROTO_UDP|IPPROTO_ICMP)发送接收ip数据包，不能用IPPROTO_IP，因为如果是用了IPPROTO_IP，系统根本就不知道该用什么协议。<br>2.socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))发送接收以太网数据帧<br>3.socket(AF_INET, SOCK_PACKET, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))过时了,不要用啊</p><p>1.介绍<br>在linux中提供了PF_PACKET接口可以操作链路层的数据。</p><p>2.使用方法<br>定义一个pf_packet = socket(PF_SOCKET, SOCK_RAW, htons(ETH_P_RARP));<br>就可以利用函数sendto和recefrom来读取和发送链路层的数据包了（当然，发送ARP包，上面第三个参数要变为 htons(ETH_P_ARP)，或者IP的包为ETH_P_IP，可查看文件/usr/include/linux/if_ether.h文件看到所有支持的协议）。</p><p>3.在使用SOCK_RAW, SOCK_DGRAM和SOCK_PACKET的区别<br>在socket的第一个参数使用PF_PACKET的时候，上述三种socket的类型都可以使用。但是有区别。<br>(1)使用SOCK_RAW发送的数据必须包含链路层的协议头，接受得到的数据包，包含链路层协议头。而使用SOCK_DGRAM则都不含链路层的协议头。<br>(2)SOCK_PACKET也是可以使用的，但是已经废弃，以后不保证还能支持，不推荐使用。<br>(3)在使用SOCK_RAW或SOCK_DGRAM和SOCK_PACKET时，在sendto和recvfrom中使用的地址类型不同，前两者使用sockaddr_ll类型的地址，而后者使用sockaddr类型的地址。<br>(4)如socket的第一个参数使用PF_INET，第二个参数使用SOCK_RAW，则可以得到原始的IP包。</p><h2 id="1-什么PF-PACKET类型的socket"><a href="#1-什么PF-PACKET类型的socket" class="headerlink" title="1. 什么PF_PACKET类型的socket"></a>1. 什么PF_PACKET类型的socket</h2><p>创建socket的函数如下：</p><p>   fd = socket(int domain, int type, int protocol)</p><p>   基于TCP/IP的传输层实现的：</p><p>   文件传送协议ftp，基于tcp实现，用下面的方式创建socket：</p><p>   fd = socket(AF_INET, SOCK_STREAM, IPPTORO_TCP)</p><p>   自动地址分配协议dhcp，基于udp实现，用下面的方式创建socket：</p><p>   fd = socket(AF_INET, SOCK_DGRAM, IPPTORO_UDP)</p><p>   基于TCP/IP的网络层实现的：</p><p>   消息控制协议icmp，基于raw ip实现，用下面的方式创建socket：</p><p>   fd = socket(AF_INET, SOCK_RAW, IPPTORO_ICMP)</p><p>   组播控制协议igmp，基于raw ip实现，用下面的方式创建socket：</p><p>   fd = socket(AF_INET, SOCK_RAW, IPPTORO_IGMP)</p><p>   socket是基于tcp/ip的网络编程接口，用于收发数据报，设置接收内核的某些状态以及事件。pf_packet类型的socket，是用来与驱动层面收发数据报的，接收和发送报文包含链路层信息，详细的信息参考：<a href="http://swoolley.org/man.cgi/7/packet。" target="_blank" rel="noopener">http://swoolley.org/man.cgi/7/packet。</a></p><p>   socket的介绍使用，编程参考：<a href="https://blog.csdn.net/somyjun/article/details/84303074" target="_blank" rel="noopener">https://blog.csdn.net/somyjun/article/details/84303074</a></p><h2 id="2-PF-PACKET类型socket应用场合"><a href="#2-PF-PACKET类型socket应用场合" class="headerlink" title="2. PF_PACKET类型socket应用场合"></a>2. PF_PACKET类型socket应用场合</h2><p>抓包，分析（如tcpdump）<br>   所有链接层的报文，单播、组播、广播，目的MAC地址，IP地址是设备本身配置的，或者是其他设备的，都通过socket发给用户态的抓包、分析程序。</p><p>   一般链路层在处理收到的报文时，会依据目的MAC、目的IP地址，如果它们不是设备本身配置的（还有一些广播、组播除外），都会丢弃。因此，需要设置设备网络设备为混杂模式（promiscuous）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq</span> <span class="title">mr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;mr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mr));</span><br><span class="line"></span><br><span class="line">mr.mf_ifindex = dev_id;</span><br><span class="line"></span><br><span class="line">mr.mr_type = PACKET_MR_PROMISC; <span class="comment">// 用于激活混杂模式以接受所有网络包;</span></span><br><span class="line"></span><br><span class="line">fd = socket(PF_PACKET, SOCK_RAW, &lt;font color=#ff0000&gt;ETH_P_ALL&lt;/font&gt;)  <span class="comment">// 所有类型的报文</span></span><br><span class="line"></span><br><span class="line">setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP,&amp;mr,<span class="keyword">sizeof</span>(mr))</span><br></pre></td></tr></table></figure></p><p> 跑在用户态的网络协议<br>   Linux内核并不是纯粹的操作系统，它实现了很多功能，包括二三层协议。一方面考虑到性能，另一方面移植性，现在有不少网络设备产商，二三层协议的实现是放在用户态的。</p><p>   fd = socket(PF_PACKET, SOCK_RAW, ETH_P_8021Q)  // linux/if_ether.h，8021Q类型的报文</p><h2 id="3-数据层面：驱动程序怎么把报文送到相应的socket-buffer"><a href="#3-数据层面：驱动程序怎么把报文送到相应的socket-buffer" class="headerlink" title="3. 数据层面：驱动程序怎么把报文送到相应的socket buffer"></a>3. 数据层面：驱动程序怎么把报文送到相应的socket buffer</h2><p>Linux内核，网络收报文有两个接口：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netif_rx_ni</span><span class="params">(struct sk_buff *skb)</span>  <span class="comment">// loopback，tun之类的设备收报文调用</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">netif_rx</span><span class="params">(struct sk_buff *skb)</span>      <span class="comment">// 中断上下文调用</span></span></span><br></pre></td></tr></table></figure></p><p>   上面两个接口的区别与实现，请查看相应的源代码。</p><p>   内核在收报文处理方式，有NAPI和非NAPI两张模式，参考下面的图。<br><img src="/pic/pf-packet001.jpg" alt="img001"></p><p>区别在于非NAPI方式，在中断上下文里构造sk_buff，完成数据的拷贝后放到相关的队列里，底半部处理过程就是deque，然后传递给相关的处理模块，这种方式，CPU可能会陷入频繁的中断，无法处理别的任务；NAPI方式是一中Polling方式，中断上下文激活Polling，在底半部调用驱动的收报文接口。</p><p>   open_softirq(NET_RX_SOFTIRQ, net_rx_action)     // softirq，底半部</p><p>   前面过了下linux驱动收包的机制，重点来了，收到的报文，沿着怎样的路径送到咱们上面讲的pf_packet类型的socket buffer的呢？</p><p>   在底半部的softirq，都会调用这个函数：</p><p>int __netif_receive_skb(struct sk_buff *skb)</p><p>int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)</p><p>下面来看看这个函数的重点逻辑部分（代码里vlan相关的部分略去）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;      <span class="comment">// 第一次循环，ptype_all，未绑定到设备的ETH_ALL类似的socket</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pt_prev)    </span><br><span class="line">    </span><br><span class="line">  ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">    </span><br><span class="line">  pt_prev = ptype;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list_for_each_entry_rcu(ptype, &amp;skb-&gt;dev-&gt;ptype_all, <span class="built_in">list</span>) &#123;    <span class="comment">// 第二次循环，ptype_all，绑定到设备的ETH_ALL类似的socket</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (pt_prev)</span><br><span class="line">    </span><br><span class="line">   ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">    </span><br><span class="line">   pt_prev = ptype;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dev_add_pack</span><span class="params">(struct packet_type *pt)</span>    </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">head</span> = <span class="title">ptype_head</span>(<span class="title">pt</span>);</span></span><br><span class="line">   </span><br><span class="line">   spin_lock(&amp;ptype_lock);</span><br><span class="line">    </span><br><span class="line">   list_add_rcu(&amp;pt-&gt;<span class="built_in">list</span>, head);</span><br><span class="line">    </span><br><span class="line">   spin_unlock(&amp;ptype_lock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct list_head *<span class="title">ptype_head</span><span class="params">(<span class="keyword">const</span> struct packet_type *pt)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (pt-&gt;type == htons(&lt;font color=#ff0000&gt;ETH_P_ALL&lt;/font&gt;))     <span class="comment">//  AF_PACKET类型的socket，要接收所有类型的报文</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> pt-&gt;dev ? &amp;pt-&gt;dev-&gt;ptype_all : &amp;ptype_all;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> pt-&gt;dev ? &amp;pt-&gt;dev-&gt;ptype_specific :&amp;ptype_base[ntohs(pt-&gt;type) &amp; PTYPE_HASH_MASK];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   从上面四个函数的逻辑就可看出，如果有类似tcpdump这样的在用户态抓包分析的程序，就调用deliver_skb。</p><p>这里逻辑上的讲究是：</p><p>   1）dev-&gt;ptype_all : ptype_all，用户态的pf_packet类型的套接字如果有bind到某个设备，就是设备单独维护的链表dev-&gt;ptype_all。</p><p>   2）pt_prev初始化是NULL的指针，linux内核维护的双向链表，链表头不是个有意义的实体，所以，每次循环结束，最后一个ptype要等到后面的判断代码再执行一遍：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pt_prev = <span class="literal">NULL</span>;    <span class="comment">// 初始化是空指针</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (pt_prev)</span><br><span class="line">    </span><br><span class="line">   ret = deliver_skb(skb, pt_prev, orig_dev);  </span><br><span class="line">    </span><br><span class="line">   pt_prev = ptype;     <span class="comment">// 赋值，下一次才会执行</span></span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span>(pt_prev)&#123;   <span class="comment">// 不为空，执行</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span>(unlikely(skb_orphan_frags_rx(skb,GFP_ATOMIC)))</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">goto</span> drop;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 这里执行最后一次回调，既然是最后一次调用，sbk就不需要clone了，这个就是与调用deliver_skb的区别</span></span><br><span class="line">    </span><br><span class="line">   ret = pt_prev-&gt;func(skb,skb-&gt;dev,pt_prev,orig_dev);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>下面来看看这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">deliver_skb</span><span class="params">(struct sk_buff *skb,struct packet_type *pt_prev,struct net_device *orig_dev)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (unlikely(skb_orphan_frags_rx(skb, GFP_ATOMIC)))</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">  refcount_inc(&amp;skb-&gt;users);    <span class="comment">// 增加计数，释放时用的；</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);   <span class="comment">// 函数指针，在下面的函数赋值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在af_packet.c这个文件里，这个函数是创建socket：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_create</span><span class="params">(struct net *net, struct socket *sock, <span class="keyword">int</span> protocol,<span class="keyword">int</span> kern)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">packet_sock</span> *<span class="title">po</span>;</span></span><br><span class="line"></span><br><span class="line">   po-&gt;prot_hook.func = packet_rcv;   <span class="comment">// func回调函数</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> (proto) &#123;</span><br><span class="line">    </span><br><span class="line">   po-&gt;prot_hook.type = proto;</span><br><span class="line">    </span><br><span class="line">   register_prot_hook(sk);        <span class="comment">// 注册到ptype_all链表中</span></span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   再来看看这个收包处理函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">packet_rcv</span><span class="params">(struct sk_buff *skb, struct net_device *dev,struct packet_type *pt, struct net_device *orig_dev)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (skb_shared(skb)) &#123;     <span class="comment">// deliver_skb函数调用了refcount_inc，需要skb_clone</span></span><br><span class="line">    </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">nskb</span> = <span class="title">skb_clone</span>(<span class="title">skb</span>, <span class="title">GFP_ATOMIC</span>);</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> (nskb == <span class="literal">NULL</span>)</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">goto</span> drop_n_acct;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skb_head != skb-&gt;data) &#123;</span><br><span class="line">    </span><br><span class="line">   skb-&gt;data = skb_head;</span><br><span class="line">    </span><br><span class="line">   skb-&gt;len = skb_len;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   consume_skb(skb);</span><br><span class="line">    </span><br><span class="line">   skb = nskb;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   spin_lock(&amp;sk-&gt;sk_receive_queue.lock);</span><br><span class="line">    </span><br><span class="line">   po-&gt;stats.stats1.tp_packets++;</span><br><span class="line">    </span><br><span class="line">   sock_skb_set_dropcount(sk, skb);</span><br><span class="line">    </span><br><span class="line">   __skb_queue_tail(&amp;sk-&gt;sk_receive_queue, skb);   <span class="comment">// 添加到队列尾巴</span></span><br><span class="line">    </span><br><span class="line">   spin_unlock(&amp;sk-&gt;sk_receive_queue.lock);</span><br><span class="line">    </span><br><span class="line">   sk-&gt;sk_data_ready(sk);  <span class="comment">// 唤醒处于TASK_INTERRUPTIBLE的等待线程</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，驱动到socket buffer，这条路就通了。</p><h2 id="4-数据层面：内核驱动可以与用户态零拷贝吗？"><a href="#4-数据层面：内核驱动可以与用户态零拷贝吗？" class="headerlink" title="4. 数据层面：内核驱动可以与用户态零拷贝吗？"></a>4. 数据层面：内核驱动可以与用户态零拷贝吗？</h2><p>socket buffer到用户态，在调用recvfrom接收报文时，是存在数据从内核态拷贝到用户态的，另外也会导致内核态和用户态的频繁切换。</p><p>下面探讨下，用户态和内核态数据零拷贝的可行性方案！</p><p><img src="/pic/pf_packet002.png" alt="img002"></p><p>上图所示，描述了试想可行的改动方案：</p><p>  1）创建buf_pool，其原理基于内核态和用户态虚拟地址，其实都对应一个物理地址，既然这样，我们创建一个基于这个基准地址的buf poll。它们通过操作自己的内存池控制块，来共同管理内存。不同空间，虽然是两个不同的基地址，k_ptr和u_ptr，其实，它们是在不同地址空间的映射而已，对于物理内存，是同样的。然后，每次操作，传递的是，与自己的基地址的偏移，到了另外一个空间，基地址加上这个偏移地址，不就是要访问的地址了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd =open(/dev/mem, rw)    </span><br><span class="line">u_ptr = mmap(<span class="number">0</span>,...fd,...,phy_addr)      <span class="comment">// phy_addr，通过sys_call获得</span></span><br><span class="line">recv_pkt     msg1: offset1、size1           <span class="comment">// 消息传递的是偏移和大小</span></span><br></pre></td></tr></table></figure></p><hr><p>原文1：<a href="https://blog.csdn.net/somyjun/article/details/84589579" target="_blank" rel="noopener">https://blog.csdn.net/somyjun/article/details/84589579</a> </p><p>原文2：<a href="https://www.cnblogs.com/cdwodm/archive/2012/09/22/2698163.html" target="_blank" rel="noopener">https://www.cnblogs.com/cdwodm/archive/2012/09/22/2698163.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PF-PACKET&quot;&gt;&lt;a href=&quot;#PF-PACKET&quot; class=&quot;headerlink&quot; title=&quot;PF_PACKET&quot;&gt;&lt;/a&gt;PF_PACKET&lt;/h1&gt;&lt;p&gt;瞅代码的时候，看到一个很奇特的socket，sock=socket(PF_PACKE
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SO_BINDTODEVICE</title>
    <link href="http://www.tangyilong.com/2019/07/28/SO-BINDTODEVICE/"/>
    <id>http://www.tangyilong.com/2019/07/28/SO-BINDTODEVICE/</id>
    <published>2019-07-28T11:07:45.000Z</published>
    <updated>2019-07-28T11:08:21.075Z</updated>
    
    <content type="html"><![CDATA[<p>man socket(7)里对该选项的描述：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SO_BINDTODEVICE</span><br><span class="line">        Bind this socket to a particular device like “eth0”, as speci‐</span><br><span class="line">        fied <span class="keyword">in</span> the passed interface name.  If the name is an empty</span><br><span class="line">        string or the option length is zero, the socket device binding</span><br><span class="line">        is removed.  The passed option is a variable-length null-ter‐</span><br><span class="line">        minated interface name string with the maximum size of IFNAM‐</span><br><span class="line">        SIZ.  If a socket is bound to an interface, only packets</span><br><span class="line">        received from that particular interface are processed by the</span><br><span class="line">        socket.  Note that this works only <span class="keyword">for</span> some socket types, par‐</span><br><span class="line">        ticularly AF_INET sockets.  It is not supported <span class="keyword">for</span> packet</span><br><span class="line">        sockets (use normal <span class="built_in">bind</span>(2) there).</span><br><span class="line"> </span><br><span class="line">        Before Linux 3.8, this socket option could be <span class="built_in">set</span>, but could</span><br><span class="line">        not retrieved with getsockopt(2).  Since Linux 3.8, it is</span><br><span class="line">        readable.  The optlen argument should contain the buffer size</span><br><span class="line">        available to receive the device name and is recommended to be</span><br><span class="line">        IFNAMSIZ bytes.  The real device name length is reported back</span><br><span class="line">        <span class="keyword">in</span> the optlen argument.</span><br></pre></td></tr></table></figure><ol><li>将套接字绑定到指定接口，例如eth0等。如果绑定了接口，这个套接字只能处理由该接口收到的数据。</li><li>注意，并不是所有套接字类型都有这个选项。AF_INET套接字支持，但是packet 套接字不支持(不过，可以使用bind函数绑定地址)</li></ol><p>SOL_BINDTODEVICE是setsockopt设置中的一种套接口选项.当套接口被绑定到</p><p>指定的网络设备接口之后，只有来自该设备的数据包才会被套接口处理。</p><p>在Linux下， 对网络设备的引用是通过struct ifreq来完成.通过设置struct</p><p>ifreq中的 ifr_name[IFNAMSIZ]来指定网络设备接口.举例如下:</p><p>struct ifreq interface;</p><p>char *inf = “eth0”;</p><p>strncpy(interface.ifr_name, inf, IFNAMSIZ);</p><p>这样再通过设置:</p><p>if (setsockopt(fd, SOL_SOCKET, <strong>SO_</strong>BINDTODEVICE,(char *)&amp;interface, sizeof(interface)) &lt; 0)</p><p>{</p><p>​    close(fd);</p><p>​    return -1;</p><p>}</p><p>就绑定到了接口”eth0”上,所有数据报的收发都只经过这个接口.</p><p>对于SOL_BINDTODEVICE的总结如下:</p><p>（1）对于TCP套接口、UDP套接口、RAW套接口，可以通过SO_BINDTODEVICE套接口选项将套接口绑定到指定的网络接口上。绑定之后，套接口的所有数据包收发都只经过指定的网络接口；</p><p>（2）对于PF_PACKET类型的套接口，不能通过SO_BINDTODEVICE绑定到指定 的网络接口上，而要通过<strong>bind</strong>(2)来与特定的网络接口绑定，所用的套接口地址结构为struct sockaddr_ll，此套 接口地址结构是链路层的地址结构，独立于具体的网络设备。比如，该地址结构既可以用于表示PPP设备，也能用于表示ethernet设备。</p><p>（3）SO_BINDTODEVICE套接口选项只适用于Linux系统。如果要编写运行在多操作系统平台上的程序，不能依赖SO_BINDTODEVICE来完成套接口 与具体设备的绑定</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;man socket(7)里对该选项的描述：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Socket-filter</title>
    <link href="http://www.tangyilong.com/2019/07/28/Socket-filter/"/>
    <id>http://www.tangyilong.com/2019/07/28/Socket-filter/</id>
    <published>2019-07-28T11:06:46.000Z</published>
    <updated>2019-07-28T11:07:20.004Z</updated>
    
    <content type="html"><![CDATA[<p>看代码的时候突然遇到了一个很奇怪的结构体</p><p>struct sock_filter</p><p>当时就是一脸茫然，这是什么？</p><p>通过百度大概了解了一下皮毛，这个是过滤器，可以配置规则来过滤一些报文，只提取自己感兴趣的报文。</p><p>比较详细的介绍可以参考<a href="https://blog.csdn.net/ljy1988123/article/details/50444693" target="_blank" rel="noopener">Linux内核工程导论——网络：Filter（LSF、BPF、eBPF）</a></p><p>本文大概简单介绍一下。</p><p>设置BPF过滤器是通过setsockopt调用来完成的，格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(sd, SOL_SOCKET, SO_ATTACH_FILTER, &amp;Filter, <span class="keyword">sizeof</span>(Filter));</span><br></pre></td></tr></table></figure><p>参数FilterFilter的定义是struct sock_fprog Filter; 此结构在linux/filter.h当中有定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span>       /* <span class="title">Required</span> <span class="title">for</span> <span class="title">SO_ATTACH_FILTER</span>. */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span>          len;    <span class="comment">/* Number of filter blocks */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span>      *<span class="title">filter</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 其中的filter指针指向结构为struct sock_filter的BPF过滤代码。结构同样也在同一个文件当中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span>      /* <span class="title">Filter</span> <span class="title">block</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        __u16   code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">        __u8    jt;     <span class="comment">/* Jump true */</span></span><br><span class="line">        __u8    jf;     <span class="comment">/* Jump false */</span></span><br><span class="line">        __u32   k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实我们并不关心如何具体的编写struct sock_filter内的东西，因为tcpdump已经内置了这样的功能。例如，想要对所接受的数据包过滤，只想接收udp数据包，那么在tcpdump当中的命令就是tcpdump udp。如果你想让tcpdump帮你编译这样的过滤器，则用tcpdump udp -d，可以得到输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@as3522:~<span class="comment"># tcpdump udp -d</span></span><br><span class="line">(000) ldh      [12]</span><br><span class="line">(001) jeq      <span class="comment">#0x86dd          jt 2jf 7</span></span><br><span class="line">(002) ldb      [20]</span><br><span class="line">(003) jeq      <span class="comment">#0x11            jt 10jf 4</span></span><br><span class="line">(004) jeq      <span class="comment">#0x2c            jt 5jf 11</span></span><br><span class="line">(005) ldb      [54]</span><br><span class="line">(006) jeq      <span class="comment">#0x11            jt 10jf 11</span></span><br><span class="line">(007) jeq      <span class="comment">#0x800           jt 8jf 11</span></span><br><span class="line">(008) ldb      [23]</span><br><span class="line">(009) jeq      <span class="comment">#0x11            jt 10jf 11</span></span><br><span class="line">(010) ret      <span class="comment">#262144</span></span><br><span class="line">(011) ret      <span class="comment">#0</span></span><br></pre></td></tr></table></figure><p>ld开头的表示加载某地址数据，jeq是比较啦，jt就是jump when true，jf呢就是jump when false，后面表示行号。不过这样的东西用在程序里还是不习惯，再用tcpdump udp -dd，可以得到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@as3522:~<span class="comment"># tcpdump udp -dd</span></span><br><span class="line">&#123; 0x28, 0, 0, 0x0000000c &#125;,</span><br><span class="line">&#123; 0x15, 0, 5, 0x000086dd &#125;,</span><br><span class="line">&#123; 0x30, 0, 0, 0x00000014 &#125;,</span><br><span class="line">&#123; 0x15, 6, 0, 0x00000011 &#125;,</span><br><span class="line">&#123; 0x15, 0, 6, 0x0000002c &#125;,</span><br><span class="line">&#123; 0x30, 0, 0, 0x00000036 &#125;,</span><br><span class="line">&#123; 0x15, 3, 4, 0x00000011 &#125;,</span><br><span class="line">&#123; 0x15, 0, 3, 0x00000800 &#125;,</span><br><span class="line">&#123; 0x30, 0, 0, 0x00000017 &#125;,</span><br><span class="line">&#123; 0x15, 0, 1, 0x00000011 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00040000 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00000000 &#125;,</span><br></pre></td></tr></table></figure><p>像c当中的数组的定义。这个就是过滤udp包的struct sock_filter的数组代码。把这部分复制到程序当中，将Filter.filter指向这个数组，Filter.len设置长度，就可以用setsockopt设置过滤器了。</p><p>不过使用这样的过滤器还是有一些需要注意的问题的，例如，设置一个过滤器，只允许两个源MAC地址的数据包进入，我们先用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@Kernel26 root]<span class="comment"># tcpdump ether src 01:02:03:04:05:06 or ether src 04:05:06:07:08:09 -dd</span></span><br><span class="line">&#123; 0×20, 0, 0, 0×00000008 &#125;,</span><br><span class="line">&#123; 0×15, 0, 2, 0×03040506 &#125;,</span><br><span class="line">&#123; 0×28, 0, 0, 0×00000006 &#125;,</span><br><span class="line">&#123; 0×15, 3, 4, 0×00000102 &#125;,</span><br><span class="line">&#123; 0×15, 0, 3, 0×06070809 &#125;,</span><br><span class="line">&#123; 0×28, 0, 0, 0×00000006 &#125;,</span><br><span class="line">&#123; 0×15, 0, 1, 0×00000405 &#125;,</span><br><span class="line">&#123; 0×6, 0, 0, 0×00000060 &#125;,</span><br><span class="line">&#123; 0×6, 0, 0, 0×00000000 &#125;,</span><br></pre></td></tr></table></figure><p>　　 生成模板，我们注意到第2、4行比较了第一个MAC地址，第5、7行比较了第二个MAC地址，所以我们只需要在我们的程序当中动态的改变这四行当中的数值就可以了，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SetFilter(char *mac1, char *mac2)</span><br><span class="line">&#123;</span><br><span class="line">        struct sock_filter code[]=&#123;</span><br><span class="line">        &#123; 0×20, 0, 0, 0×00000008 &#125;,</span><br><span class="line">        &#123; 0×15, 0, 2, ntohl(*(unsigned int *)(mac1 + 2)) &#125;,</span><br><span class="line">        &#123; 0×28, 0, 0, 0×00000006 &#125;,</span><br><span class="line">        &#123; 0×15, 3, 4, ntohs(*(unsigned short *)mac1) &#125;,</span><br><span class="line">        &#123; 0×15, 0, 3, ntohl(*(unsigned int *)(mac2 + 2)) &#125;,</span><br><span class="line">        &#123; 0×28, 0, 0, 0×00000006 &#125;,</span><br><span class="line">        &#123; 0×15, 0, 1, ntohs(*(unsigned short *)mac2) &#125;,</span><br><span class="line">        &#123; 0×6, 0, 0, 0×00000060 &#125;,</span><br><span class="line">        &#123; 0×6, 0, 0, 0×00000000 &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　这里，需要用ntohl/ntohs等函数将网络字节序转换为主机字节序。但是这段代码是有逻辑问题的。它首先比较第一个mac地址的后4个字节，如果不正确转入比较第二个mac地址，如果正确转入比较第一个mac地址的高2个字节。因此，如果打算将这个代码用作通用的mac比较，那么在输入的两个mac地址后4字节都相同的情况下就会出现逻辑覆盖错误，即无法对满足第二个mac地址的条件进行判断。因此在这种情况下必须要准备两段比较代码，根据情况进行设置。具体不再累述。<br>  此外，这段BPF代码还存在的一个问题是，一般情况下tcpdump只返回所捕获包的头96字节，也就是0×60字节，可见代码的倒数第二行是ret #96。对于需要完整的包处理还是不行的，因此你需要将其设置为0×0000ffff，或者在用tcpdump生成的时候用tcpdump -s 65535 -dd … 来生成。<br>  最后，用tcpdump生成的BPF代码只能用于SOCK_RAW的socket，这类socket是可以直接操作数据链路层的，如果你打算将BPF用于ip层等较高层次的socket，那么你需要手工修改部分行的code.k，也就是修改如ldh [12]当中的[12]这个数值，因为这个数值的偏移量是按照从链路层开始计算得到的，在没有链路层之后，这个值就发生了变化，这个是需要注意的。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>过滤以太网报文协议是0x8888的报文,先使用tcpdumo获取BPFcode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@as3522:~<span class="comment"># tcpdump -dd ether proto 0x8888</span></span><br><span class="line">&#123; 0x28, 0, 0, 0x0000000c &#125;,</span><br><span class="line">&#123; 0x15, 0, 1, 0x00008888 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00040000 &#125;,</span><br><span class="line">&#123; 0x6, 0, 0, 0x00000000 &#125;,</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">Filter</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// tcpdump -dd ether proto 0x8888</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">BPF_code</span>[]= &#123;</span></span><br><span class="line">&#123; <span class="number">0x28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0000000c</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0x00008888</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000200</span> &#125;,</span><br><span class="line">&#123; <span class="number">0x6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x00000000</span> &#125;</span><br><span class="line">&#125;;                            </span><br><span class="line"></span><br><span class="line"><span class="comment">//init filter settings</span></span><br><span class="line">Filter.len = <span class="number">4</span>;</span><br><span class="line">Filter.filter = BPF_code;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Attach the filter to the socket */</span></span><br><span class="line"><span class="keyword">if</span>(setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;Filter, <span class="keyword">sizeof</span>(Filter))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：<a href="https://www.cnblogs.com/rollenholt/articles/2585517.html" target="_blank" rel="noopener">https://www.cnblogs.com/rollenholt/articles/2585517.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看代码的时候突然遇到了一个很奇怪的结构体&lt;/p&gt;
&lt;p&gt;struct sock_filter&lt;/p&gt;
&lt;p&gt;当时就是一脸茫然，这是什么？&lt;/p&gt;
&lt;p&gt;通过百度大概了解了一下皮毛，这个是过滤器，可以配置规则来过滤一些报文，只提取自己感兴趣的报文。&lt;/p&gt;
&lt;p&gt;比较详细的介
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sendto和recvfrom</title>
    <link href="http://www.tangyilong.com/2019/07/28/sendto%E5%92%8Crecvfrom/"/>
    <id>http://www.tangyilong.com/2019/07/28/sendto和recvfrom/</id>
    <published>2019-07-28T11:05:34.000Z</published>
    <updated>2019-07-28T11:06:12.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sendto"><a href="#sendto" class="headerlink" title="sendto"></a>sendto</h2><p>头文件</p><p>#include &lt; sys/types.h &gt;</p><p>#include &lt; sys/socket.h &gt;<br>定义函数<br>int sendto ( int s , const void <em> msg, int len, unsigned int flags, const<br>struct sockaddr </em> to , int tolen ) ;<br>函数说明<br>  s：一个标识套接口的描述字。<br>  buf：包含待发送数据的缓冲区。<br>  len：buf缓冲区中数据的长度。<br>  flags：调用方式标志位。<br>  to：（可选）指针，指向目的套接口的地址。<br>  tolen：to所指地址的长度。<br>    sendto() 用来将数据由指定的socket传给对方主机。参数s为已建好连线的socket,如果利用UDP协议则不需经过连线操作。参数msg指向欲连线的数据内容，参数flags 一般设0，详细描述请参考send()。参数to用来指定欲传送的网络地址，结构sockaddr请参考bind()。参数tolen为sockaddr的结果长度。<br>    sendto()适用于已连接的数据报或流式套接口发送数据。对于数据报类套接口，必需注意发送数据长度不应超过通讯子网的IP包最大长度。<br>    请注意成功地完成sendto()调用并不意味着数据传送到达。</p><p>返回值<br>成功则返回实际传送出去的字符数，失败返回－1，错误原因存于errno 中。<br>错误代码<br>EBADF 参数s非法的socket处理代码。<br>EFAULT 参数中有一指针指向无法存取的内存空间。<br>WNOTSOCK canshu s为一文件描述词，非socket。<br>EINTR 被信号所中断。<br>EAGAIN 此动作会令进程阻断，但参数s的soket为补课阻断的。<br>ENOBUFS 系统的缓冲内存不足。<br>EINVAL 传给系统调用的参数不正确。</p><h2 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h2><p>头文件</p><p>#include&lt;sys/types.h&gt;</p><p>#include&lt;sys/socket.h&gt;<br>定义函数<br>int recvfrom(int s,void <em>buf,int len,unsigned int flags ,struct sockaddr </em>from ,int *fromlen);<br>函数说明</p><p>  s：标识一个已连接套接口的描述字。<br>  buf：接收数据缓冲区。<br>  len：缓冲区长度。<br>  flags：调用操作方式。<br>  from：（可选）指针，指向装有源地址的缓冲区。<br>  fromlen：（可选）指针，指向from缓冲区长度值。</p><p>本函数由于从（已连接）套接口上接收数据，并捕获数据发送源的地址。<br>  对于SOCK_STREAM类型的套接口，最多可接收缓冲区大小个数据。对于SOCK_STREAM类型套接口，忽略from和fromlen参数。<br>  对于数据报类套接口，队列中第一个数据报中的数据被解包，但最多不超过缓冲区的大小。如果数据报大于缓冲区，那么缓冲区中只有数据报的前面部分，其他的数据都丢失了，并且recvfrom()函数返回错误。<br>  若from非零，且套接口为SOCK_DGRAM类型，则发送数据源的地址被复制到相应的sockaddr结构中。fromlen所指向的值初始化时为这个结构的大小，当调用返回时按实际地址所占的空间进行修改。<br>  如果没有数据待读，那么除非是非阻塞模式，不然的话套接口将一直等待数据的到来，此时将返回SOCKET_ERROR错误，。用select()可以获知何时数据到达。<br>  如果套接口为SOCK_STREAM类型，并且远端“优雅”地中止了连接，那么recvfrom()一个数据也不读取，立即返回。</p><p>​    recv()用来接收远程主机经指定的socket 传来的数据，并把数据存到由参数buf 指向的内存空间，参数len 为可接收数据的最大长度。参数flags 一般设0，其他数值定义请参考recv()。参数from用来指定欲传送的网络地址，结构sockaddr 请参考bind()。参数fromlen为sockaddr的结构长度。<br>返回值<br>​    成功则返回接收到的字符数，失败则返回-1，错误原因存于errno中。<br>错误代码<br>EBADF 参数s非合法的socket处理代码<br>EFAULT 参数中有一指针指向无法存取的内存空间。<br>ENOTSOCK 参数s为一文件描述词，非socket。<br>EINTR 被信号所中断。<br>EAGAIN 此动作会令进程阻断，但参数s的socket为不可阻断。<br>ENOBUFS 系统的缓冲内存不足<br>ENOMEM 核心内存不足<br>EINVAL 传给系统调用的参数不正确。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sendto&quot;&gt;&lt;a href=&quot;#sendto&quot; class=&quot;headerlink&quot; title=&quot;sendto&quot;&gt;&lt;/a&gt;sendto&lt;/h2&gt;&lt;p&gt;头文件&lt;/p&gt;
&lt;p&gt;#include &amp;lt; sys/types.h &amp;gt;&lt;/p&gt;
&lt;p&gt;#incl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>memalign-calloc-malloc-realloc-free-alloca</title>
    <link href="http://www.tangyilong.com/2019/07/28/memalign-calloc-malloc-realloc-free-alloca/"/>
    <id>http://www.tangyilong.com/2019/07/28/memalign-calloc-malloc-realloc-free-alloca/</id>
    <published>2019-07-28T11:04:17.000Z</published>
    <updated>2019-07-28T11:05:01.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="memalign"><a href="#memalign" class="headerlink" title="memalign"></a>memalign</h2><p> 在GNU系统中，malloc或realloc返回的内存块地址都是8的倍数（如果是64位系统，则为16的倍数）。如果你需要更大的粒度，请使用memalign或valloc。这些函数在头文件“stdlib.h”中声明。</p><p>​    在GNU库中，可以使用函数free释放memalign和valloc返回的内存块。但无法在BSD系统中使用，而且BSD系统中并未提供释放这样的内存块的途径。</p><p>​    函数：void * memalign (size_t boundary, size_t size)<br>​    函数memalign将分配一个由size指定大小，地址是boundary的倍数的内存块。<font color="#ff0000">参数boundary必须是2的幂！</font>函数memalign可以分配较大的内存块，并且可以为返回的地址指定粒度。</p><p>​    函数：void <em> valloc (size_t size)<br>​    使用函数valloc与使用函数memalign类似，函数valloc的内部实现里，使用页的大小作为对齐长度，使用memalign来分配内存。它的实现如下所示：<br>​    void </em><br>​    valloc (size_t size)<br>​    {<br>​      return memalign (getpagesize (), size);<br>​    }  </p><h2 id="malloc-calloc-realloc-alloca内存分配函数"><a href="#malloc-calloc-realloc-alloca内存分配函数" class="headerlink" title="malloc/calloc/realloc/alloca内存分配函数"></a>malloc/calloc/realloc/alloca内存分配函数</h2><p>calloc(), malloc(), realloc(), free(),alloca()</p><p>内存区域可以分为栈、堆、静态存储区和常量存储区，局部变量，函数形参，临时变量都是在栈上获得内存的，它们获取的方式都是由编译器自动执行的。<br>利用指针，我们可以像汇编语言一样处理内存地址，C 标准函数库提供了许多函数来实现对堆上内存管理，其中包括：malloc函数，free函数，calloc函数和realloc函数。使用这些函数需要包含头文件stdlib.h。</p><p>四个函数之间的有区别，也有联系，我们应该学会把握这种关系，从而编出精炼而高效的程序。</p><p>在说明它们具体含义之前，先简单从字面上加以认识，前3个函数有个共同的特点，就是都带有字符”alloc”，就是”allocate”，”分配”的意思，也就是给对象分配足够的内存，” calloc()”是”分配内存给多个对象”，” malloc()”是”分配内存给一个对象”，”realloc()”是”重新分配内存”之意。”free()”就比较简单了，”释放”的意思，就是把之前所分配的内存空间给释放出来。</p><p>void *calloc(size_t nobj, size_t size);</p><p>分配足够的内存给nobj个大小为size的对象组成的数组, 并返回指向所分配区域的第一个字节的指针;<br>若内存不够,则返回NULL. 该空间的初始化大小为0字节.<br>char <em>p = (char </em>) calloc(100,sizeof(char));</p><p>void *malloc(size_t size);</p><p>分配足够的内存给大小为size的对象, 并返回指向所分配区域的第一个字节的指针;<br>若内存不够,则返回NULL. 不对分配的空间进行初始化.<br>char <em>p = (char </em>)malloc(sizeof(char));</p><p>void <em>realloc(void </em>p, size_t size);</p><p>将p所指向的对象的大小改为size个字节.<br>如果新分配的内存比原内存大, 那么原内存的内容保持不变, 增加的空间不进行初始化.<br>如果新分配的内存比原内存小, 那么新内存保持原内存的内容, 增加的空间不进行初始化.<br>返回指向新分配空间的指针; 若内存不够,则返回NULL, 原p指向的内存区不变.<br>char <em>p = (char </em>)malloc(sizeof(char));<br>p= (char *)realloc(p, 256);</p><p>void free(void *p);</p><p>释放p所指向的内存空间; 当p为NULL时, 不起作用.<br>p必先调用calloc, malloc或realloc.</p><p>值得注意的有以下5点：</p><p>（1）通过malloc函数得到的堆内存必须使用memset函数来初始化</p><p>malloc函数分配得到的内存空间是未初始化的。因此，一般在使用该内存空间时，要调用另一个函数memset来将其初始化为全0，memset函数的声明如下：void <em> memset (void </em> p,int c,int n) ;</p><p>该函数可以将指定的内存空间按字节单位置为指定的字符c，其中，p为要清零的内存空间的首地址，c为要设定的值，n为被操作的内存空间的字节长度。如果要用memset清0，变量c实参要为0。</p><p>malloc函数和memset函数的操作语句一般如下：</p><p>int * p=NULL;</p><p>p=(int*)malloc(sizeof(int));</p><p>if(p==NULL)</p><p>printf(“Can’t get memory!\n”);</p><p>memset(p,0,siezeof(int));</p><p>（2）使用malloc函数分配的堆空间在程序结束之前必须释放</p><p>从堆上获得的内存空间在程序结束以后，系统不会将其自动释放，需要程序员来自己管理。一个程序结束时，必须保证所有从堆上获得的内存空间已被安全释放，否则，会导致内存泄露。</p><p>我们可以使用free()函数来释放内存空间，但是，free函数只是释放指针指向的内容，而该指针仍然指向原来指向的地方，此时，指针为野指针，如果此时操作该指针会导致不可预期的错误。安全做法是：在使用free函数释放指针指向的空间之后，将指针的值置为NULL。</p><p>（3）calloc函数的分配的内存也需要自行释放</p><p>calloc函数的功能与malloc函数的功能相似，都是从堆分配内存,它与malloc函数的一个显著不同时是，calloc函数得到的内存空间是经过初始化的，其内容全为0。calloc函数适合为数组申请空间，可以将size设置为数组元素的空间长度，将n设置为数组的容量。</p><p>（4）如果要使用realloc函数分配的内存，必须使用memset函数对其内存初始化</p><p>realloc函数的功能比malloc函数和calloc函数的功能更为丰富，可以实现内存分配和内存释放的功能。realloc 可以对给定的指针所指的空间进行扩大或者缩小，无论是扩张或是缩小，原有内存的中内容将保持不变。当然，对于缩小，则被缩小的那一部分的内容会丢失。realloc 并不保证调整后的内存空间和原来的内存空间保持同一内存地址。相反，realloc 返回的指针很可能指向一个新的地址。</p><p>所以，在代码中，我们必须将realloc返回的值，重新赋值给 p :</p><p>p = (int <em>) realloc(p, sizeof(int) </em>15);</p><p>甚至，你可以传一个空指针（0）给 realloc ，则此时realloc 作用完全相当于malloc。</p><p>int<em> p = (int </em>)realloc (0,sizeof(int) * 10); //分配一个全新的内存空间，</p><p>这一行，作用完全等同于：</p><p>int<em> p = (int </em>)malloc(sizeof(int) * 10);</p><p>（5）关于alloca()函数</p><p>还有一个函数也值得一提，这就是alloca()。其调用序列与malloc相同，但是它是在当前函数的栈帧上分配存储空间，而不是在堆中。其优点是：当 函数返回时，自动释放它所使用的栈帧，所以不必再为释放空间而费心。其缺点是：某些系统在函数已被调用后不能增加栈帧长度，于是也就不能支持alloca 函数。尽管如此，很多软件包还是使用alloca函数，也有很多系统支持它。</p><font color="#ff0000">总结：应用时候需要记得，只有calloc可以指定个数和大小，而且能够对分配内存进行初始化，其余函数均不会对内存进行初始化工作，需要自行调用memset（）函数.</font><hr><p><a href="https://www.cnblogs.com/3me-linux/p/3962152.html" target="_blank" rel="noopener">https://www.cnblogs.com/3me-linux/p/3962152.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;memalign&quot;&gt;&lt;a href=&quot;#memalign&quot; class=&quot;headerlink&quot; title=&quot;memalign&quot;&gt;&lt;/a&gt;memalign&lt;/h2&gt;&lt;p&gt; 在GNU系统中，malloc或realloc返回的内存块地址都是8的倍数（如果是64位系统
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络编程设置TTL</title>
    <link href="http://www.tangyilong.com/2019/07/28/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E8%AE%BE%E7%BD%AETTL/"/>
    <id>http://www.tangyilong.com/2019/07/28/网络编程设置TTL/</id>
    <published>2019-07-28T11:00:55.000Z</published>
    <updated>2019-07-28T11:03:42.485Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个问题，领导让我查一下关于多播的TTL配置的问题，我也是看了diam之后才知道的原来TTL可以通过编程来实现，说起来网络编程能力欠佳啊</p><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>TTL是 Time To Live的缩写，该字段指定IP包被路由器丢弃之前允许通过的最大网段数量。TTL是IPv4包头的一个8 bit字段.</p><p>在IPv4包头中TTL是一个8 bit字段，它位于IPv4包的第9个字节。如下图所示，每</p><p>一行表示 32 bit（4字节），位从0开始编号，即0~31。</p><p><img src="/pic/TTL001.jpg" alt="img1"></p><p>TTL的作用是限制IP数据包在计算机网络中的存在的时间。TTL的最大值是255，TTL的一个推荐值是64.</p><p>虽然TTL从字面上翻译，是可以存活的时间，但实际上TTL是IP数据包在计算机网络中可以转发的最大跳数。TTL字段由IP数据包的发送者设置，在IP数据包从源到目的的整个转发路径上，每经过一个路由器，路由器都会修改这个TTL字段值，具体的做法是把该TTL的值减1，然后再将IP包转发出去。如果在IP包到达目的IP之前，TTL减少为0，路由器将会丢弃收到的TTL=0的IP包并向IP包的发送者发送 ICMP time exceeded消息。</p><p>TTL的主要作用是避免IP包在网络中的无限循环和收发，节省了网络资源，并能使IP包的发送者能收到告警消息。</p><p>TTL 是由发送主机设置的，以防止数据包不断在IP互联网络上永不终止地循环。转发IP数据包时，要求路由器至少将 TTL 减小 1。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>TTL值的注册表位置HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters 其中有个DefaultTTL的DWORD值，其数据就是默认的TTL值了，我们可以修改，但不能大于十进制的255。Windows系统设置后重启才生效。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p> linux系统 TTL值的修改位置是/proc/sys/net/ipv4/ip_default_ttl，</p><p> echo 128 &gt; /proc/sys/net/ipv4/ip_default_ttl</p><p>　　若要设置长久的可以：</p><p>　　修改/etc/sysctl.conf配置文件，添加如下一行</p><p>　　net.ipv4.ip_default_ttl=128</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> *optlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ttl = <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">int</span> yes = <span class="number">1</span>;</span><br><span class="line">  setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL, (<span class="keyword">char</span> *)&amp;ttl, <span class="keyword">sizeof</span>(ttl));  <span class="comment">//设置组播TTL</span></span><br><span class="line">  setsockopt(fd, IPPROTO_IP, IP_TTL, (<span class="keyword">char</span> *)&amp;ttl, <span class="keyword">sizeof</span>(ttl)); <span class="comment">//set ttl  on all sockets</span></span><br><span class="line">  setsockopt(fd, IPPROTO_IP, IP_RECVTTL , &amp;yes, <span class="keyword">sizeof</span>(yes));<span class="comment">//Tell me the TTL of incomming packets.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近遇到一个问题，领导让我查一下关于多播的TTL配置的问题，我也是看了diam之后才知道的原来TTL可以通过编程来实现，说起来网络编程能力欠佳啊&lt;/p&gt;
&lt;h2 id=&quot;TTL&quot;&gt;&lt;a href=&quot;#TTL&quot; class=&quot;headerlink&quot; title=&quot;TTL&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开源协议GPL</title>
    <link href="http://www.tangyilong.com/2019/07/28/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AEGPL/"/>
    <id>http://www.tangyilong.com/2019/07/28/开源协议GPL/</id>
    <published>2019-07-28T10:59:52.000Z</published>
    <updated>2019-07-28T11:00:34.039Z</updated>
    
    <content type="html"><![CDATA[<p>最近添加了一个功能，需要用到开源库，然后是GPLv2。由于GPL的传染性，所以后面就直接拉了一个进程来添加这个新功能。所以相关的协议还是要去了解的。</p><h2 id="GPL-协议"><a href="#GPL-协议" class="headerlink" title="GPL 协议"></a>GPL 协议</h2><p>即通用性公开许可证(General Public License，简称GPL)。</p><p>GPL同其它的自由软件许可证一样，许可社会公众享有：运行、复制软件的自由，发行传播软件的自由，获得软件源码的自由，改进软件并将自己作出的改进版本向社会发行传播的自由。 </p><p>GPL还规定：只要这种修改文本在整体上或者其某个部分来源于遵循GPL的程序，该修改文本的 整体就必须按照GPL流通，不仅该修改文本的源码必须向社会公开，而且对于这种修改文本的流通不准许附加修改者自己作出的限制。因此，一项遵循GPL流通 的程序不能同非自由的软件合并。GPL所表达的这种流通规则称为copyleft，表示与copyright(版权)的概念“相左”。</p><p>GPL协议最主要的几个原则：</p><p>1、确保软件自始至终都以开放源代码形式发布，保护开发成果不被窃取用作商业发售。任何一套软 件，只要其中使用了受 GPL 协议保护的第三方软件的源程序，并向非开发人员发布时，软件本身也就自动成为受 GPL 保护并且约束的实体。也就是说，此时它必须开放源代码。</p><p>2、GPL 大致就是一个左侧版权（Copyleft，或译为“反版权”、“版权属左”、“版权所无”、“版责”等）的体现。你可以去掉所有原作的版权 信息，只要你保持开源，并且随源代码、二进制版附上 GPL 的许可证就行，让后人可以很明确地得知此软件的授权信息。GPL 精髓就是，只要使软件在完整开源 的情况下，尽可能使使用者得到自由发挥的空间，使软件得到更快更好的发展。</p><p>3、无论软件以何种形式发布，都必须同时附上源代码。例如在 Web 上提供下载，就必须在二进制版本（如果有的话）下载的同一个页面，清楚地提供源代码下载的链接。如果以光盘形式发布，就必须同时附上源文件的光盘。</p><p>4、开发或维护遵循 GPL 协议开发的软件的公司或个人，可以对使用者收取一定的服务费用。但还是一句老话——必须无偿提供软件的完整源代码，不得将源代码与服务做捆绑或任何变相捆绑销售。</p><p><a href="http://zh.wikipedia.org/wiki/GNU通用公共许可证" target="_blank" rel="noopener">GPL详细信息</a></p><h2 id="ADPL协议"><a href="#ADPL协议" class="headerlink" title="ADPL协议"></a>ADPL协议</h2><p>原有的GPL协议，由于现在网络服务公司兴起（如：google）产生了一定的漏洞，比如使用GPL的自由软件，但是并不发布与网络之中，则可以自由的使 用GPL协议确不开源自己私有的解决方案。AGPL则增加了对此做法的约束。</p><p>这样如果不“发布”就可以不受约束了。比如使用GPL组件编写一个Web系统，不发布这个系统，但是用这个系统在线提供服务，同时不开源系统代码。</p><p><a href="http://zh.wikipedia.org/wiki/Affero通用公共许可证" target="_blank" rel="noopener">AGPL详细信息</a></p><h1 id="LGPL协议"><a href="#LGPL协议" class="headerlink" title="LGPL协议"></a>LGPL协议</h1><p>宽松公共许可证（Lesser General Public License）或库通用公共许可证（Library General Public License）</p><p>基于 LGPL 的软件也允许商业化销售，但不允许封闭源代码。<br>如果您对遵循 LGPL 的软件进行任何改动和/或再次开发并予以发布，则您的产品必须继承 LGPL 协议，不允许封闭源代码。但是如果您的程序对遵循 LGPL 的软件进行任何连接、调用而不是包含，则允许封闭源代码。</p><p><a href="http://www.oschina.net/question/12_2827" target="_blank" rel="noopener">LGPL详细信息</a></p><hr><p><a href="https://my.oschina.net/yangsheng/blog/190917" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近添加了一个功能，需要用到开源库，然后是GPLv2。由于GPL的传染性，所以后面就直接拉了一个进程来添加这个新功能。所以相关的协议还是要去了解的。&lt;/p&gt;
&lt;h2 id=&quot;GPL-协议&quot;&gt;&lt;a href=&quot;#GPL-协议&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux本地套接字</title>
    <link href="http://www.tangyilong.com/2019/07/01/linux%E6%9C%AC%E5%9C%B0%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <id>http://www.tangyilong.com/2019/07/01/linux本地套接字/</id>
    <published>2019-07-01T03:14:51.000Z</published>
    <updated>2019-07-01T03:20:57.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux网络编程——Unix本地套接字"><a href="#Linux网络编程——Unix本地套接字" class="headerlink" title="Linux网络编程——Unix本地套接字"></a>Linux网络编程——Unix本地套接字</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>　　今天给大家讲解网络编程中的一个内容——Unix 本地套接字。<br>　　发现很多人不知道或者不太了解 Unix 本地套接字这个概念，这也难怪，socket API 原本就是为多台主机之间网络通信设计的，并且这种网络 socket 同样支持单台主机上的进程间通信，当然这样做的话，仍然需要 IP 地址和端口号（通过 loopback 地址 127.0.0.1）。Unix本地套接字，其实就是一种专门用于本地（也就是单个主机上的）网络通信的一种方法，它所用的 API 跟我们之前用的网络 socket API 是一样的。<br>　　本文要介绍的 Unix 本地套接字是在 socket 的框架上发展出一种 IPC 机制，即 UNIX Domain Socket，也就是 UNIX 本地套接字，或者称为 UNIX 域套接字。相比于网络 socket 和 IPC，Unix本地套接字有其自身的特点和优势，下面我们就来看一下吧。<br>　　虽然在很多教材中经常把Unix本地套接字放在网络编程里面进行讲解，但实际上，这种通信方式更类似于我们之前所学的IPC（进程间通信）的方式，比如无名管道（pipe）、有名管道（mkfifo）。但是，Unix域套接字所提供的控制方式会更多一些，比如说TCP（字节流套接字）提供等待连接的功能，UDP（数据报套接字）提供帧同步功能，同时也是全双工的（比如使用 socketpair 创建的流管道中的两个描述符都是既可读又可写的）。 　　</p><h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><p>　　首先，我们回顾一下，TCP 和 UDP 套接字的服务端和客户端，从 socket 的创建，到连接，到数据传输，再到关闭 socket 的整个流程。<br>　　TCP 是一种面向连接的字节流套接字，所以服务端需要通过 listen() 转变为被动 socket，通过 accept() 等待连接。</p><p><img src="/pic/uinx-soket001.png" alt="img"></p><pre><code>图1. TCP 客户/服务器通信流程</code></pre><p>　　而对于 UDP 来说，就比较简单了，因为它是一种无连接的数据报套接字，实际上，客户/服务端的概念也弱化了。</p><p><img src="/pic/uinx-soket002.png" alt="img2"></p><pre><code>图2. UDP 通信流程</code></pre><h2 id="Unix-本地套接字-API"><a href="#Unix-本地套接字-API" class="headerlink" title="Unix 本地套接字 API"></a>Unix 本地套接字 API</h2><p>　　前面我们说过，Unix 域套接字所使用的 API 其实跟我们之前用的 socket API 是一样的，并且对于 TCP 和 UDP，其工作流程跟上图的网络 socket 完全一样。<br>　　那么，下面我们就来看一下如何通过这些 API 来创建并使用我们的 Unix 本地套接字，以及它们之间有什么区别，然后再通过一个简单的示例程序来体验一下。</p><h2 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h2><p>　　首先是 socket 的创建。同样使用 socket() 这个函数。</p><p><img src="/pic/uinx-soket003.png" alt="img3"></p><p>　　但是它的第一个参数 domain 不再是 <code>AF_INET</code> 或者 <code>PF_INET</code>，而是 <code>AF_UNIX</code>，表示的就是 Unix 域本地套接字。那 <code>AF_LOCAL</code> 又是什么呢？这其实是历史原因造成的，我们的主题是“Unix本地套接字”或者“Unix域套接字”，但实际上我们用是Linux，对吧。那其实，为了消除它对 Unix 操作系统的依赖，在 POSIX 标准中，早就已经将 <code>AF_UNIX</code> 变成 <code>AF_LOCAL</code> 了，但是尽管如此，我们依然习惯使用“Unix域”这个称谓，因此，更推荐大家使用 <code>AF_LOCAL</code>。<br>　　第二个参数的话，跟 Internet 域套接字一样，可以是 <code>SOCK_STREAM</code>、<code>SOCK_DGRAM</code> 和 <code>SOCK_RAW</code>，但实际上，几乎没见过使用原始套接字的。所以一般来说 Unix 提供两类套接字，也就是字节流套接字（类似于TCP）和数据报套接字（类似于UDP）。<br>　　第三个参数 Protocol，显然，因为第二个参数 type 不是原始套接字，所以 protocol 一般填 0 就可以了。</p><h2 id="绑定地址"><a href="#绑定地址" class="headerlink" title="绑定地址"></a>绑定地址</h2><p>　　创建完套接字，接下来就是通过 bind() 函数绑定地址，但对于 Unix 本地套接字来说，绑定的地址就不是原来的“IP地址 + 端口号”了，而是一个有效的路径。</p><p><img src="/pic/uinx-soket004.png" alt="img4"></p><p>　　本地套接字的地址结构体 sockaddr_un 的后缀是 <code>_un</code>，表示 Unix，而不是原来的 <code>sockaddr_in</code>（Internet）。我们来看一下这个Unix域套接字的地址结构体中包含哪些内容：</p><p><img src="/pic/uinx-soket005.png" alt="img5"></p><p>　　Unix 本地套接字的地址结构体中包含两个成员，其中 sun_family 表示协议族，填 AF_LOCAL 或 AF_UNIX 即可；sun_path 表示一个路径名。<br>　　从这里面可以很明显得看出 Unix 域套接字与原来的 网络套接字的区别，Unix 域中用于标识客户和服务器的协议地址是普通文件系统中的<strong>路径名</strong>，而这个文件就称为<strong>套接字文件</strong>。<br>　　这里要强调一下的是，Unix 本地套接字关联的这个路径名应该是一个<strong>绝对路径名</strong>，而不是一个相对路径名。为什么呢？因为解析相对路径依赖于调用者的当前工作目录，也就是说，要是服务器绑定了一个相对路径名，那么客户端也得在与服务端相同的目录中才能成功调用connect（连接）或者sendto（发送）这样一些函数。显然，这样就会导致程序出现异常情况，所以建议大家最好使用一个绝对路径名。<br>　　这个路径名，其实还要分为两种，一种是我们上面所提到的普通路径名，另一种是抽象路径名。普通路径名是一个正常的字符串，也就是说，sun_path 字段是以空字符（’\0’）结尾的。而抽象路径名，sun_path 字段的第一个字节需要设置成 NULL（’\0’），所以在计算抽象路径名的长度的时候就要特别小心了，否则在解析抽象路径名时就有可能出现异常情况，因为抽象路径名不是像解析普通路径名那样，解析到第一个 NULL 就可以停止了。<br>　　使用抽象路径名的好处是，因为不会再在文件系统中创建文件了，所以对于抽象路径名来说，就不需要担心与文件系统中已存在的文件产生名字冲突的问题了，也不需要在使用完套接字之后删除附带产生的这个文件了，当套接字被关闭之后会自动删除这个抽象名。</p><h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><p>　　其他的一些 API，比如 listen()、accept()、connect()，以及数据通信用的 read()、write()、recv()、send()、recvfrom()、sendto()、recvmsg()、sendmsg()，用法跟网络 socket 基本一样，主要是地址结构体需要注意一下。</p><p><img src="/pic/uinx-soket006.png" alt="img6"></p><p>　　另外，在 Unix 本地套接字的使用中，还经常用到这些 API：</p><p>　　（1）用于创建类似于无名管道（pipe）的本地套接字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>　　（2）当不再需要这个 Unix 域套接字时，应删除路径名对应的文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure></p><p>　　注意，如果是抽象路径名，就不需要在使用完本地套接字后手动删除对应的套接字文件，因为当本地套接字被关闭之后，内核会自动删除这个抽象名。</p><p>　　（3）获取本地套接字的地址信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="TCP（字节流套接字）"><a href="#TCP（字节流套接字）" class="headerlink" title="TCP（字节流套接字）"></a>TCP（字节流套接字）</h3><p>　　在这个例子中，我们使用绝对路径名”/tmp/unix.str”来实现一个字节流的本地套接字，服务端接收数据，客户端发送数据。</p><p>【unixstr_serv.c】<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIXSTR_PATH <span class="meta-string">"/tmp/unix.str"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listenfd, connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (listenfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    unlink(UNIXSTR_PATH);</span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, UNIXSTR_PATH);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(listenfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    listen(listenfd, LISTENQ);</span><br><span class="line">    </span><br><span class="line">    len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == (connfd = accept(listenfd, (struct sockaddr *)&amp;cliaddr, &amp;len)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"accept"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(read(connfd, buf, BUFFER_SIZE) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Receive: %s"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(listenfd);</span><br><span class="line">    close(connfd);</span><br><span class="line">    unlink(UNIXSTR_PATH);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【unixstr_cli.c】<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIXSTR_PATH <span class="meta-string">"/tmp/unix.str"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, UNIXSTR_PATH);</span><br><span class="line">    </span><br><span class="line">    connect(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(buf, <span class="keyword">sizeof</span>(BUFFER_SIZE));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"&gt;&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span>(fgets(buf, BUFFER_SIZE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(sockfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　有兴趣的童鞋可以自己编译、执行，看看运行效果，我们这里来看一下 /tmp/unix.str 这个文件吧。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rudy@ubuntu12:/tmp$ ls -l unix.str </span><br><span class="line">srwxrwxr-x 1 rudy rudy 0 10月 26 11:58 unix.str</span><br></pre></td></tr></table></figure></p><p>　　显然，文件类型为“s”，代表套接字文件，也就是 S_IFSOCK 类型。</p><h3 id="UDP（数据报套接字）"><a href="#UDP（数据报套接字）" class="headerlink" title="UDP（数据报套接字）"></a>UDP（数据报套接字）</h3><p>　　类似于上面 TCP 的例子，我们使用绝对路径名”/tmp/unix.dg”来实现一个数据报的本地套接字，一端接收数据，一端发送数据。</p><p>【unixdg_serv.c】<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIXDG_PATH <span class="meta-string">"/tmp/unix.dg"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_LOCAL, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    unlink(UNIXDG_PATH);</span><br><span class="line">    </span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, UNIXDG_PATH);</span><br><span class="line">    </span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(buf, BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == recvfrom(sockfd, buf, BUFFER_SIZE, <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, &amp;len))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"recvfrom: %s"</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(sockfd);</span><br><span class="line">    unlink(UNIXDG_PATH);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【unixdg_cli.c】<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIXDG_PATH <span class="meta-string">"/tmp/unix.dg"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">servaddr</span>, <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len;</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_LOCAL, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* local address */</span></span><br><span class="line">    bzero(&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    cliaddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(cliaddr.sun_path, UNIXDG_PATH);</span><br><span class="line">    bind(sockfd, (struct sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* remote address */</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(servaddr.sun_path, UNIXDG_PATH);</span><br><span class="line">    len = <span class="keyword">sizeof</span>(servaddr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(buf, BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"&gt;&gt; "</span>);</span><br><span class="line">        <span class="keyword">if</span>(fgets(buf, BUFFER_SIZE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sendto(sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;servaddr, len);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(sockfd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　需要注意的是，跟网络套接字不一样，对于 Unix 域套接字的 UDP 客户端，必须 bind 一个路径名到 UDP 套接字，以使得 UDP 服务器有发送应答的目的地。</p><p>总结<br>　　通过上面简单的示例，我们可以看到 Unix 本地套接字跟 Internet 套接字虽然使用相同的 API，但用法上又有些不同，跟IPC（比如管道、消息队列、共享内存等）相比，也有不同。我们可以简单地把 Unix 本地套接字看成是 socket 和管道的混合体。<br>　　可以这么说，Unix 本地套接字的优势体现在它所使用的 API 几乎等同于网络 socket（客户/服务器）使用的 API，但是与客户端和服务端都在同一主机上的 TCP 相比，Unix 本地字节流套接字有性能上的优势。在单个主机，使用 Unix 域套接字来替代 Internet 域套接字是有好处的。<br>　　最后，总结一下：<br>　　（1）Socket 同样可以用于本地通信。<br>　　（2）创建套接字时使用本地协议 AF_LOCAL。<br>　　（3）分为流式套接字（SOCK_STREAM）和数据报套接字（SOCK_DGRAM） 。<br>　　（4）和其他进程间通信方式相比，Unix 本地套接字使用方便，效率也高 。因为它不需要经过网络协议栈、不需要打包拆包、不需要计算校验和、不需要维护序号和应答等、只是将应用层数据从一个进程拷贝到另一个进程……<br>　　（5）常用于前后台进程通信，比如 X Window。<br>　　（6）另外，Unix 本地套接字可用于传递文件描述符、传递用户凭证等场景。</p><hr><p>原文：<a href="https://blog.csdn.net/lu_embedded/article/details/78352230" target="_blank" rel="noopener">https://blog.csdn.net/lu_embedded/article/details/78352230</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux网络编程——Unix本地套接字&quot;&gt;&lt;a href=&quot;#Linux网络编程——Unix本地套接字&quot; class=&quot;headerlink&quot; title=&quot;Linux网络编程——Unix本地套接字&quot;&gt;&lt;/a&gt;Linux网络编程——Unix本地套接字&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux-unlink</title>
    <link href="http://www.tangyilong.com/2019/07/01/linux-unlink/"/>
    <id>http://www.tangyilong.com/2019/07/01/linux-unlink/</id>
    <published>2019-07-01T03:13:05.000Z</published>
    <updated>2019-07-01T03:13:49.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux下unlink函数的使用"><a href="#Linux下unlink函数的使用" class="headerlink" title="Linux下unlink函数的使用"></a>Linux下unlink函数的使用</h1><p>一、头文件</p><p>#include&lt;unistd.h&gt;</p><p>二、函数原型<br>int unlink(const char *pathname);</p><p>三、函数介绍<br>unlink()函数功能即为删除文件。执行unlink()函数会删除所给参数指定的文件。</p><p>注意：</p><font color="0xff0000">执行unlink()函数并不一定会真正的删除文件，它先会检查文件系统中此文件的连接数是否为1，如果不是1说明此文件还有其他链接对象，因此只对此文件的连接数进行减1操作。若连接数为1，并且在此时没有任何进程打开该文件，此内容才会真正地被删除掉。在有进程打开此文件的情况下，则暂时不会删除，直到所有打开该文件的进程都结束时文件就会被删除。</font><p>返回值：成功返回0，失败返回 -1<br>在文件打开的情况下unlink()并不会立即删除，并且对文件依然可以进行读写操作，在进程结束之后文件就会被删除掉！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux下unlink函数的使用&quot;&gt;&lt;a href=&quot;#Linux下unlink函数的使用&quot; class=&quot;headerlink&quot; title=&quot;Linux下unlink函数的使用&quot;&gt;&lt;/a&gt;Linux下unlink函数的使用&lt;/h1&gt;&lt;p&gt;一、头文件&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>popen</title>
    <link href="http://www.tangyilong.com/2019/05/15/popen/"/>
    <id>http://www.tangyilong.com/2019/05/15/popen/</id>
    <published>2019-05-15T07:13:14.000Z</published>
    <updated>2019-05-15T07:13:40.922Z</updated>
    
    <content type="html"><![CDATA[<p> popen()可以执行shell命令，并读取此命令的返回值；　　</p><p>   popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。可以通过这个管道执行标准输入输出操作。<strong>这个管道<font color="#ff0000">必须由pclose()函数关闭，必须由pclose()函数关闭，必须由pclose()函数关闭</font>，而不是fclose()函数（若使用fclose则会产生僵尸进程）。</strong>pclose()函数关闭标准I/O流，等待命令执行结束，然后返回shell的终止状态。如果shell不能被执行，则pclose()返回的终止状态与shell已执行exit一样。</p><p>　type参数只能是读或者写中的一种，得到的返回值（标准I/O流）也具有和type相应的只读或只写类型。如果type是”r”则文件指针连接到command的标准输出；如果type是”w”则文件指针连接到command的标准输入。</p><p>　　command参数是一个指向以NULL结束的shell命令字符串的指针。这行命令将被传到bin/sh并使用-c标志，shell将执行这个命令。</p><p>　　popen()的返回值是个标准I/O流，必须由pclose来终止。前面提到这个流是单向的（只能用于读或写）。向这个流写内容相当于写入该命令的标准输入，命令的标准输出和调用popen()的进程相同；与之相反的，从流中读数据相当于读取命令的标准输出，命令的标准输入和调用popen()的进程相同。</p><p><strong>返回值</strong><br>　　如果调用fork()或pipe()失败，或者不能分配内存将返回NULL，否则返回标准I/O流。popen()没有为内存分配失败设置errno值。如果调用fork()或pipe()时出现错误，errno被设为相应的错误类型。如果type参数不合法，errno将返回EINVAL。</p><p>函数原型</p><p>FILE <em>popen(const char </em>command, const char <em>type);<br>int pclose(FILE </em>stream);</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">print_result(FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n&gt;&gt;&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)), fgets(buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, fp) != <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n&lt;&lt;&lt;\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                fp = <span class="literal">NULL</span>;</span><br><span class="line">                fp = popen(<span class="string">"ls"</span>, <span class="string">"r"</span>);</span><br><span class="line">                <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">                        perror(<span class="string">"popen"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                print_result(fp);</span><br><span class="line">                pclose(fp);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; popen()可以执行shell命令，并读取此命令的返回值；　　&lt;/p&gt;
&lt;p&gt;   popen()函数通过创建一个管道，调用fork()产生一个子进程，执行一个shell以运行命令来开启一个进程。可以通过这个管道执行标准输入输出操作。&lt;strong&gt;这个管道&lt;font 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sqlite3 pragma</title>
    <link href="http://www.tangyilong.com/2019/05/15/pragma/"/>
    <id>http://www.tangyilong.com/2019/05/15/pragma/</id>
    <published>2019-05-15T07:11:39.000Z</published>
    <updated>2019-05-15T07:15:16.661Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://iihero.iteye.com/blog/1189633" target="_blank" rel="noopener">原文</a></p><p>PRAGMA语句是SQLITE数据的SQL扩展，是它独有的特性，主要用于修改SQLITE库或者内数据查询的操作。它采用与SELECT、INSERT等语句一样的形式来发出请求，但也有几个重要的不同： </p><ol><li>特定的PRAGMA语句可能被移走，新的PRAGMA语句可能在新的版本中添加。因此，后向兼容无法保证。 </li><li>未知的PRAGMA命令不会有错误消息出现，它只是简单的忽略。 </li><li>有些PRAGMA只在SQL的编译阶段起作用，而不是执行阶段。　这意味着如果使用C语言，sqlite3_prepare(), sqlite3_step(), sqlite3_finalize()这几个API，pragma命令可能只在prepare()的调用里运行，而不是在后两个API当中执行。或者，pragma可能在sqlite3_step()执行的时候运行。到底在哪个阶段执行，取决于pragma从本身，以及是哪个sqlite的release版本。 </li><li>pragma命令是sqlite特有的，基本上不可能与其它数据库保持兼容。 </li></ol><p>PRAGMA命令的语法格式如下图： </p><p><img src="/pic/sqlite1.jpg" alt="img1"></p><p>它可以不带参数，或者只带一个参数。这个参数可以是等号赋值，也可以用括号括起来。两者效果一样。很多情况下，参数值是布尔型，值为(1,yes,true 或on)或者(0, no, false, off)<br>关键字参数，可以使用引号括起来，e.g. ‘yes’ [FALSE]。有些pragma命令会使用字符串作为参数，”0”和”no”表示相同的含义。当查询某设置的值时，很多情况下返回的是数值，而不是关键字。 </p><p>pragma名之前，可以选带数据库的名字。数据库名是被”attach”（关联）上的数据库名字，或者是”main”, “temp”来表示主数据库和临时数据库。如果可选的数据库名被略去，则默认为”main”数据库。在有些pragma命令里，数据库名没有意义，则简单的忽略掉。 </p><p>下面我们看看sqlite到底有些有用的pragma命令：<br>auto_vacuum<br>automatic_index<br>cache_size<br>case_sensitive_like<br>checkpoint_fullfsync<br>collation_list<br>compile_options<br>count_changes¹<br>database_list<br>default_cache_size¹<br>empty_result_callbacks¹<br>encoding<br>foreign_key_list<br>foreign_keys<br>freelist_count<br>full_column_names¹<br>fullfsync<br>ignore_check_constraints<br>incremental_vacuum<br>index_info<br>index_list<br>integrity_check<br>journal_mode<br>journal_size_limit<br>legacy_file_format<br>locking_mode<br>max_page_count<br>page_count<br>page_size<br>parser_trace²<br>quick_check<br>read_uncommitted<br>recursive_triggers<br>reverse_unordered_selects<br>schema_version<br>secure_delete<br>short_column_names¹<br>synchronous<br>table_info<br>temp_store<br>temp_store_directory¹<br>user_version<br>vdbe_listing²<br>vdbe_trace²<br>wal_autocheckpoint<br>wal_checkpoint<br>writable_schema<br>这里边有几个标了右上标为1的，似乎已经被obsoleted掉了。标为2的，只被用于debug,仅当sqlite在预编译宏SQLITE_DEBUG下build出来，才有用。 </p><p>下面看看这些命令的具体用法： </p><ol><li><p>PRAGMA auto_vacuum;<br>PRAGMA auto_vacuum = 0 或 NONE | 1 或 FULL | 2 或 INCREMENTAL;<br>这里，0和NONE表示的含义相同。<br>缺省值为0, 表示禁用auto vacuum. 除非SQLITE_DEFAULT_AUTOVACUUM宏在编译的时候定义了。数据删除的时候，数据库大小不会改变。没用的数据库文件页面会被添加到freelist里头，用于将来重用。这时，使用VACUUM命令，可以重建整个数据库，以回收无用的磁盘空间。<br>值为1时，所有的freelist页会被移动到文件末尾，每次事务提交的时候文件会被截短。注意，自动vacuum只是从文件是截断freelist页，并没有进行碎片重整等操作，也就是说，它没有VACUUM命令来得彻底。事实上，自动vacuum会让碎片更多。<br>只有在数据库存储某些附加信息的时候，它允许每个数据库页来跟踪它的引用页，自动vacuum才用得上。它必须在没有创建任何表的情况下启用。在一个表已经创建了之后，是不能启用和停用auto-vacuum的。<br>值为2时，表示增量vacuum，意味着并不是在每次提交事务的时候自动vacuum，需要调用一个独立的incremental_vacuum语句来触发auto-vacuum。<br>数据库可以在1和2两种vacuum模式下进行切换。但是不能从none到full或incremental间切换。要想切换，要么数据库是全新的数据库（没有任何表），　或者单独运行vacuum命令以后。改变自动vacuum模式，首先执行auto_vacuum语句设置新的模式，然后调用VACUUM来重整数据库。<br>不带参数的auto_vacuum语句返回当前的auto_vacuum模式值。 </p></li><li><p>PRAGMA automatic_index;<br>PRAGMA automatic_index = boolean;<br>查询，设置或者清除自动索引的功能。缺省值为true (1). </p></li><li><p>PRAGMA cache_size;<br>PRAGMA cache_size = <number of="" pages="">;<br>查询或者修改打开的数据库内存里头能容纳的最多的数据库页数。缺省值是2000.　这样设定只会改变当前会话中的cache size，当数据库重新打开，又会恢复默认值。你可以使用default_cache_size来设定所有会话中的cache size </number></p></li><li><p>PRAGMA case_sensitive_like=boolean;<br>默认行为是忽略ascii字符的大小写。’a’ LIKE ‘A’会是true. 当禁用case_sensitive_like时，会用默认的like行为。当启用它时，就会区分大小写。 </p></li><li><p>PRAGMA checkpoint_fullfsync<br>PRAGMA checkpoint_fullfsync=boolean;<br>查询或设置fullfsync的标志值。如果设置了该值，则F_FULLFSYNC同步方法会在checkpoint操作时调用，默认值是off。只有Mac OS-X操作系统支持F_FULLFSYNC。另外，如果设定了fullfsync值，那么F_FULLFSYNC同步方法会在所有sync操作里使用，也checkpoint_fullfsync标志完全无关。 </p></li><li><p>PRAGMA collation_list;<br>返回当前数据库连接定义的所有排序顺序。 </p></li><li><p>PRAGMA compile_options;<br>这个要赞，返回编译SQLITE时使用的所有预编译宏。当然，以”SQLITE_”打头的前缀会被忽略。实际上它是通过调用sqlite3_compileoption_get()方法返回的。 </p></li><li><p>PRAGMA count_changes;<br>PRAGMA count_changes=boolean;<br>该命令已经停用. 只是为了保持后向兼容. 如果不设置此值，INSERT, UPDATE, DELETE语句不会返回多少行改变的数据。<br>事实上，sqlite3_changes()可以获取改变的行数。 </p></li><li><p>PRAGMA database_list;<br>返回当前数据库连接关联的数据库列表. </p></li><li><p>PRAGMA default_cache_size;<br>PRAGMA default_cache_size = Number-of-pages;<br>设置缺省的cache sie, 是以页为单位。不幸的是，该命令也将被废弃。 </p></li><li><p>PRAGMA empty_result_callbacks;<br>PRAGMA empty_result_callbacks = boolean;<br>仅作后向兼容用。如果将该标志值清除，sqlite3_exec()提供的回调函数（返回0或多行数据）将不被触发。 </p></li><li><p>PRAGMA encoding;<br>PRAGMA encoding = “UTF-8”;<br>PRAGMA encoding = “UTF-16”;<br>PRAGMA encoding = “UTF-16le”;<br>PRAGMA encoding = “UTF-16be”;<br>缺省值是utf-8。如果使用attach命令，则会要求使用与main数据库相同的字符集编码，如果新的数据库编码与main不同，则会失败。 </p></li><li><p>PRAGMA foreign_key_list(table-name);<br>返回外键列表 </p></li><li><p>PRAGMA foreign_keys;<br>PRAGMA foreign_keys = boolean;<br>查询设置或者清除关于外键的限制, 外键限制只有在BEGIN或者SAVEPOINT不在PENDING状态时设置才有效。<br>　　改变该设置会影响所有已经准备好的SQL语句的执行。<br>从3.6.19开始，默认的FK强制限制是OFF。也就是说，不会强制外键依赖。 </p></li><li><p>PRAGMA freelist_count;<br>返回数据库文件中未使用页的数目 </p></li><li><p>PRAGMA full_column_names;<br>PRAGMA full_column_names = boolean;<br>deprecated. </p><ol><li>如果有AS子句，列名就会用AS后的别名 </li><li>如果结果只是普通的表达式，而不是源表的列名，则采用表达式的文本 </li><li>如果使用了short_column_names开关为ON，则采用源表列名，并且不带表名前缀 </li><li>如果两个开关都设为OFF，则采用第2个规则。 </li><li>结果列是学有源表源列的组合：TABLE.COLUMN </li></ol></li><li><p>PRAGMA fullfsync;<br>PRAGMA fullfsync = boolean;<br>缺省值为OFF，也只有MAC os支持F_FULLFSYNC </p></li><li><p>PRAGMA ignore_check_constraints = boolean;<br>是否强制check约束，缺省值为off </p></li><li><p>PRAGMA incremental_vacuum(N);<br>N页从freelist中移除。用于设定此参数。每次截短相同的页数。该命令必须是在auto_vacuum=incremental模式下才有效。如果freelist中的页数少于N，或者N小于1，或者N被完全忽略，那么整个freelist会被清除。 </p></li><li><p>PRAGMA index_info(index-name);<br>获取具名的index信息。 </p></li><li><p>PRAGMA index_list(table-name);<br>获取与目标表关联的索引的的相关信息 </p></li><li><p>PRAGMA integrity_check;<br>PRAGMA integrity_check(integer);<br>执行整个库的完全性检查，会查看错序的记录、丢失的页，毁坏的索引等。 </p></li><li><p>PRAGMA journal_mode;<br>PRAGMA database.journal_mode;<br>PRAGMA journal_mode = DELETE | TRUNCATE | PERSIST | MEMORY | WAL | OFF<br>PRAGMA database.journal_mode = DELETE | TRUNCATE | PERSIST | MEMORY | WAL | OFF<br>用于设置数据库的journal_mode. DELETE是缺省的行为。在此模式下，每次事务终止的时候，journal文件会被删除，它会导致事务提交。<br>TRUNCATE模式，通过将回滚journal截短成0，而不是删除它。大多数情情况下，它要比DELETE模式速度快(因为不用删除文件）<br>PERSIST模式，每次事务结束时，并不删除rollback journal，而只是在journal的头部填充0，这样会阻止别的数据库连接来rollback. 该模式在某些平台下，是一种优化，特别是删除或者truncate一个文件比覆盖文件的第一块代价高的时候。<br>MEMORY模式，只将rollback日志存储到RAM中，节省了磁盘I/O，但带来的代价是稳定性和完整性上的损失。如果中间crash掉了，数据库有可能损坏。<br>WAL模式，也就是write-ahead　log取代rollback journal。该模式是持久化的，跨多个数据为连接，在重新打开数据库以后，仍然有效。该模式只在3.7.0以后才有效。<br>(经过实验，发现，它会生成两个文件：.shm和.wal)<br>OFF模式，这样就没有事务支持了。　<br>另外要注意的是，对于memory数据库，只有两种模式: MEMORY或者OFF。并且，当前如果有活跃的事务，则不允许改变事务模式。 </p></li><li><p>PRAGMA journal_size_limit<br>PRAGMA journal_size_limit = N ;<br>如果连接时，用了”exclusive mode(PRAGMA locking_mode=exclusive)或者(PRAGMA journal_mode=persist), 提交事务以后，journal文件会仍然在文件系系统当中。这可能会提高了效率，但是也损耗了空间。一个大的事务（如VACUUM)，会耗费大量的磁盘空间。<br>该设置会限制journal文件的大小。默认值是－1。 </p></li><li><p>PRAGMA legacy_file_format;<br>PRAGMA legacy_file_format = boolean;<br>如果该值为ON，则会采用3.0.0文件格式，如果为off, 则会采用最新的文件格式，可能导致旧版本的sqlite无法打开该文件。<br>第一次新文件格式的sqlite3数据库打开时，该值为off.但是默认值会是on. </p></li><li><p>PRAGMA locking_mode;<br>PRAGMA locking_mode = NORMAL | EXCLUSIVE<br>缺省值是NORMAL. 数据库连接在每一个读或写事务终点的时候放掉文件锁。如果是EXCLUSIVE模式，连接永远不会释放文件锁。在此模式下，第一次执行读操作时，会获取并持有共享锁，第一次写，会获取并持有排它锁。<br>释放排它锁，仅当关闭数据库连接，或者将锁模式改回为NORMAL时，再次访问数据库文件（读或写）才会放掉。简单的设置为NORMAL是不够的，只有当下次再访问时才会释放排它锁。<br>有下述三个理由，去设置锁模式为EXCLUSIVE </p><ol><li>应用程序需要阻止其它进程访问数据库文件 </li><li>文件系统的系统调用数量减少了，导致些许性能下降 </li><li>WAL日志模式可以在EXCLUSIVE模式下使用，而不需要用到共享内存<br>当指定数据库名时，只能目标数据库生效。如：<br>PRAGMA main.locking_mode=EXCLUSIVE;  不指定数据库名时，则对所有打开的数据库生效。temp或者memory数据库总是使用exclusive锁模式。<br>　　第一次进入WAL日志模式时，锁模式使用的是exclusive，这以后，锁模式也不能改变，直到退出WAL日志模式，如果锁模式开始时使用的是NORMAL，第一次进入WAL，这时锁模式可以改变，并且不需要退出WAL模式。 </li></ol></li><li><p>PRAGMA max_page_count;<br>PRAGMA max_page_count = N;<br>查询或者设置数据库文件的最大页数 </p></li><li><p>PRAGMA page_count;<br>返回数据库文件的页数 </p></li><li><p>PRAGMA page_size;<br>PRAGMA page_size = bytes;<br>查询或者设置数据库文件的页大小, 必须是2的乘方，并且介于512和65536之间。<br>创建数据库时，会给定一个缺省的大小。page_size命令会立即改变页大小（如果数据库是空的话，就是说在没有创建任何表的情况下）。如果指定了新大小，是在运行VACUUM命令之间，同时数据库不是在WAL日志模式下，那么VACUUM命令会将页大小调整到新的大小（这时应该没有是事创建表的限制）<br>SQLITE_DEFAULT_PAGE_SIZE 缺省值是1024，最大的缺省页大小是8192. windows下，有时候可能缺省页大小大于1024，取决于GetDiskFreeSpace()来获取真实的设置扇区大小。 </p></li><li><p>PRAGMA parser_trace = boolean;<br>用在DEBUG的时候。 </p></li><li><p>PRAGMA quick_check;<br>PRAGMA quick_check(integer)<br>与integrity_check相像，但是略去了对索引内容与表内容匹配的校验。 </p></li><li><p>PRAGMA read_uncommitted;<br>PRAGMA read_uncommitted = boolean;<br>读未提交开关。缺省的事务隔离级是：可串行化。任何进程或线程都可以设置读未提交隔离级，但是，SERIALIZABLE仍被使用，除了共享某页和表模式的缓存的那些连接。 </p></li><li><p>PRAGMA recursive_triggers;<br>PRAGMA recursive_triggers = boolean;<br>会影响所有的语句执行。3.6.18以前，这个开关是不支持的。缺省值是off. </p></li><li><p>PRAGMA reverse_unordered_selects;<br>PRAGMA reverse_unordered_selects = boolean;<br>当开启此开关时，不带order by的select语句，会输出相反顺序的结果。 </p></li><li><p>PRAGMA schema_version;<br>PRAGMA schema_version = integer ;<br>PRAGMA user_version;<br>PRAGMA user_version = integer ;<br>schema和user version是在数据库文件头40，60字节处的32位整数（大端表示）。<br>schema版本由sqlite内部维护，当schema改变时，就会增加该值。显式改变该值非常危险。<br>user版本可以被应用程序使用。 </p></li><li><p>PRAGMA secure_delete;<br>PRAGMA database.secure_delete;<br>PRAGMA secure_delete = boolean<br>PRAGMA database.secure_delete = boolean<br>设为ON时，删除的内容会用0来覆盖。缺省值由宏SQLITE_SECURE_DELETE 决定。那就是OFF了。 </p></li><li><p>PRAGMA short_column_names;<br>PRAGMA short_column_names = boolean;<br>deprecated. </p></li><li><p>PRAGMA synchronous;<br>PRAGMA synchronous = 0 | OFF | 1 | NORMAL | 2 | FULL;<br>查询设置sync标志值。缺省值是FULL. </p></li><li><p>PRAGMA table_info(table-name);<br>返回表的基本信息 </p></li><li><p>PRAGMA temp_store;<br>PRAGMA temp_store = 0 | DEFAULT | 1 | FILE | 2 | MEMORY;<br>查询或设置temp_store参数值。<br>SQLITE_TEMP_STORE PRAGMA temp_store Storage used forTEMP tables<br>0    any    file<br>1    0    file<br>1    1    file<br>1    2    memory<br>2    0    memory<br>2    1    file<br>2    2    memory<br>3    any    memory </p></li><li><p>PRAGMA temp_store_directory;<br>PRAGMA temp_store_directory = ‘directory-name’;<br>设置或改变temp_store的目录位置. deprecated. </p></li><li><p>PRAGMA vdbe_listing = boolean;<br>用于DEBUG </p></li><li><p>PRAGMA vdbe_trace = boolean;<br>用于DEBUG </p></li><li><p>PRAGMA wal_autocheckpoint;<br>PRAGMA wal_autocheckpoint=N;<br>设置WAL自动检查点的间隔（以页为单位）, 缺省值是1000。 </p></li><li><p>PRAGMA database.wal_checkpoint;<br>PRAGMA database.wal_checkpoint(PASSIVE);<br>PRAGMA database.wal_checkpoint(FULL);<br>PRAGMA database.wal_checkpoint(RESTART); </p></li><li><p>PRAGMA writable_schema = boolean;<br>当设为ON时，SQLITE_MASTER表可以执行CUD操作。这样做很危险!! </p></li></ol><p>(finished!!!) </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://iihero.iteye.com/blog/1189633&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PRAGMA语句是SQLITE数据的SQL扩展，是它独有的特性，主要用于修改SQLITE
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>哈佛和冯诺依曼架构</title>
    <link href="http://www.tangyilong.com/2019/05/15/%E5%93%88%E4%BD%9B%E5%92%8C%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%9E%B6%E6%9E%84/"/>
    <id>http://www.tangyilong.com/2019/05/15/哈佛和冯诺依曼架构/</id>
    <published>2019-05-15T07:09:19.000Z</published>
    <updated>2019-05-15T07:17:27.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a><strong>哈佛结构</strong></h2><p><img src="/pic/哈佛.png" alt="img1"></p><p>(英语：<strong><em>Harvard architecture</em></strong>)是一种将程序指令储存和数据储存分开的存储器结构。中央处理器首先到程序指令储存器中读取程序指令内容，解码后得到数据地址，再到相应的数据储存器中读取数据，并进行下一步的操作（通常是执行）。程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度，如Microchip公司的PIC16芯片的程序指令是14位宽度，而数据是8位宽度。</p><font color="#FF0000">与冯.诺曼结构处理器比较，哈佛结构处理器有两个明显的特点：</font><p>1、使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存；</p><p>2、使用独立的两条总线，分别作为CPU与每个存储器之间的专用通信路径，而这两条总线之间毫无关联。</p><p><font color="#FF0000">改进的哈佛结构，其结构特点为：</font><br>1、使用两个独立的存储器模块，分别存储指令和数据，每个存储模块都不允许指令和数据并存，以便实现并行处理；<br>2、具有一条独立的地址总线和一条独立的数据总线，利用公用地址总线访问两个存储模块（程序存储模块和数据存储模块），公用数据总线则被用来完成程序存储模块或数据存储模块与CPU之间的数据传输；</p><p>   哈佛结构的微处理器通常具有较高的执行效率。其程序指令和数据指令分开组织和储存的，执行时可以预先读取下一条指令。目前使用哈佛结构的中央处理器和微控制器有很多，除了上面提到的Microchip公司的PIC系列芯片，还有摩托罗拉公司的MC68系列、Zilog公司的Z8系列、ATMEL公司的AVR系列和安谋公司的ARM9、ARM10和ARM11。</p><h2 id="冯·诺伊曼结构"><a href="#冯·诺伊曼结构" class="headerlink" title="冯·诺伊曼结构"></a><strong>冯·诺伊曼结构</strong></h2><p><img src="/pic/哈佛2.png" alt="img1"></p><p>（<strong>von Neumann architecture</strong>），也称<strong>普林斯顿结构</strong>，是一种将程序指令存储器和数据存储器合并在一起的电脑设计概念结构。本词描述的是一种实作通用图灵机的计算装置，以及一种相对于平行计算的序列式结构参考模型（referential model）。</p><p>本结构隐约指导了将储存装置与中央处理器分开的概念，因此依本结构设计出的计算机又称<strong>储存程式型</strong>电脑。</p><p>   冯.诺曼结构处理器具有以下几个特点：</p><p>必须有一个存储器；</p><p>必须有一个控制器；</p><p>必须有一个运算器，用于完成算术运算和逻辑运算；</p><p>必须有输入和输出设备，用于进行人机通信。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>随着半导体工业的发展，很多东西可以集成到芯片内部。在芯片内部走线比在PCB外部走线成本要低出很多。</p><p>也就是说，哈佛结构很适合被设计到芯片内部。而冯诺依曼结构仍然存在于芯片外部。</p><p>于是乎，便出现了现在的冯诺依曼和哈佛结构并存的混合式结构：</p><p><img src="/pic/哈佛3.jpg" alt="img1"></p><p>这种结构就是目前ARM的结构，将两种结构扬其长，避其短。其中，芯片内部的cache，表示高速缓存（cache一词据说来自法语，难道cache是法国人发明的？哈哈。）Dcache用来缓存部分代码，icache用来缓存部分数据。只有需要改变时，cache才会到RAM中加载新的数据。所以大部分时间CPU都是通过哈佛结构和cache（高速缓存）通讯，这个速度是非常快的～～</p><p>这样在芯片外部，利用冯诺依曼结构，节省了外部的PCB走线资源。</p><p>在芯片内部，利用哈佛结构提高了CPU访问数据的速度。可谓是两全其美～～</p><hr><p><a href="http://www.cnblogs.com/douzi2/" target="_blank" rel="noopener">出处1</a></p><p><a href="https://blog.csdn.net/zhaoguanghua0407/article/details/78534281" target="_blank" rel="noopener">出处2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;哈佛结构&quot;&gt;&lt;a href=&quot;#哈佛结构&quot; class=&quot;headerlink&quot; title=&quot;哈佛结构&quot;&gt;&lt;/a&gt;&lt;strong&gt;哈佛结构&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/pic/哈佛.png&quot; alt=&quot;img1&quot;&gt;&lt;/p&gt;
&lt;p&gt;(英语
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MarkDown语法</title>
    <link href="http://www.tangyilong.com/2019/05/15/MarkDown%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.tangyilong.com/2019/05/15/MarkDown语法/</id>
    <published>2019-05-15T06:31:02.000Z</published>
    <updated>2019-05-15T07:08:17.817Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qcx321/article/details/53780672" target="_blank" rel="noopener">https://blog.csdn.net/qcx321/article/details/53780672</a></p><p>markdown语法实例<br>[TOC]</p><h3 id="1-强调"><a href="#1-强调" class="headerlink" title="1 强调"></a>1 强调</h3><p>星号与下划线都可以，单是斜体，双是粗体，符号可跨行，符号可加空格<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**一个人来到田纳西**</span><br><span class="line"><span class="symbol">__</span>毫无疑问<span class="symbol">__</span></span><br><span class="line"></span><br><span class="line">*我做的馅饼</span><br><span class="line">是全天下*</span><br><span class="line"></span><br><span class="line"><span class="symbol">_</span>最好吃的<span class="symbol">_</span></span><br></pre></td></tr></table></figure></p><p><strong>一个人来到田纳西</strong><br><strong>毫无疑问</strong></p><p><em>我做的馅饼<br>是全天下</em></p><p><em>最好吃的</em></p><h3 id="2-分割线"><a href="#2-分割线" class="headerlink" title="2 分割线"></a>2 分割线</h3><p>三个或更多-_*，必须单独一行，可含空格<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">___</span></span><br></pre></td></tr></table></figure></p><hr><hr><hr><h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a>3 引用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用</span></span><br></pre></td></tr></table></figure><blockquote><p>引用</p></blockquote><p>内层符号前的空格必须要<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用</span><br><span class="line"><span class="meta">&gt;&gt;</span>引用中的引用</span><br></pre></td></tr></table></figure></p><blockquote><p>引用</p><blockquote><p>引用中的引用</p></blockquote></blockquote><h3 id="4-标题：Setext方式"><a href="#4-标题：Setext方式" class="headerlink" title="4 标题：Setext方式"></a>4 标题：Setext方式</h3><p>三个或更多<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大标题</span><br><span class="line">===</span><br><span class="line">小标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><h3 id="5-标题：Atx方式"><a href="#5-标题：Atx方式" class="headerlink" title="5 标题：Atx方式"></a>5 标题：Atx方式</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h3 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6 无序列表"></a>6 无序列表</h3><p>符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表，内容可超长<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>无序列表</span><br><span class="line"><span class="bullet">- </span>无序列表</span><br><span class="line"><span class="bullet">- </span>无序列表</span><br><span class="line"><span class="bullet">- </span>无序列表：我很长。我也很长！那比一比啊</span><br></pre></td></tr></table></figure></p><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li><li>无序列表：我很长。我也很长！那比一比啊</li></ul><p>符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>无序列表</span><br><span class="line"><span class="bullet">* </span>无序列表</span><br><span class="line"><span class="bullet">* </span>无序列表</span><br><span class="line"><span class="bullet">* </span>无序列表：我很长。我也很长！那比一比啊</span><br></pre></td></tr></table></figure></p><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li><li>无序列表：我很长。我也很长！那比一比啊<h3 id="7-有序列表"><a href="#7-有序列表" class="headerlink" title="7 有序列表"></a>7 有序列表</h3><font color="#ff0000">数字不能省略但可无序，点号之后的空格不能少</font></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>有序列表</span><br><span class="line"><span class="bullet">2. </span>有序列表</span><br><span class="line"><span class="bullet">3. </span>有序列表</span><br><span class="line"><span class="bullet">8. </span>有序列表</span><br></pre></td></tr></table></figure><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li><li>有序列表<br>嵌套列表<br>-+*可循环使用，但符号之后的空格不能少，符号之前的空格也不能少<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 嵌套列表<span class="number">1</span></span><br><span class="line"> + 嵌套列表<span class="number">2</span></span><br><span class="line"> + 嵌套列表<span class="number">3</span></span><br><span class="line">  - 嵌套列表<span class="number">4</span></span><br><span class="line">   * 嵌套列表<span class="number">5</span></span><br><span class="line">- 嵌套列表<span class="number">6</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>嵌套列表1<ul><li>嵌套列表2</li><li>嵌套列表3</li></ul><ul><li>嵌套列表4<ul><li>嵌套列表5</li></ul></li></ul></li><li>嵌套列表6<br>8 文字超链：Inline方式<br>Tooltips可省略<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">as3522</span>](<span class="link">http://www.as3522.com "博客"</span>)</span><br></pre></td></tr></table></figure></li></ul><p><a href="http://www.as3522.com" title="博客" target="_blank" rel="noopener">as3522</a></p><h3 id="8-图片超链"><a href="#8-图片超链" class="headerlink" title="8 图片超链"></a>8 图片超链</h3><p>多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">GitHub Mark</span>](<span class="link">http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png "GitHub Mark"</span>)</span><br></pre></td></tr></table></figure></p><p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png&quot;GitHub Mark&quot;" alt="GitHub Mark"></p><h3 id="9-索引超链：Reference方式"><a href="#9-索引超链：Reference方式" class="headerlink" title="9 索引超链：Reference方式"></a>9 索引超链：Reference方式</h3><p>索引，1 可以是任意字符<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">as3522</span>][<span class="symbol">1</span>]</span><br><span class="line">[<span class="symbol">1</span>]:<span class="link">http://www.as3522.com</span></span><br></pre></td></tr></table></figure></p><p><a href="http://www.as3522.com" target="_blank" rel="noopener">as3522</a></p><h3 id="10-自动链接"><a href="#10-自动链接" class="headerlink" title="10 自动链接"></a>10 自动链接</h3><p>尖括号<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="string">http:</span><span class="comment">//ibruce.info&gt;</span></span><br><span class="line">&lt;bu.ru<span class="meta">@qq</span>.com&gt;</span><br></pre></td></tr></table></figure></p><p><a href="http://ibruce.info" target="_blank" rel="noopener">http://ibruce.info</a></p><p><a href="mailto:&#x62;&#x75;&#x2e;&#114;&#x75;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x62;&#x75;&#x2e;&#114;&#x75;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;</a></p><h3 id="11-代码：行内代码"><a href="#11-代码：行内代码" class="headerlink" title="11 代码：行内代码"></a>11 代码：行内代码</h3><p>在第一行后指定编程语言，也可以不指定<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">​``` python</span><br><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可代码高亮</span><br><span class="line">​``` python</span><br><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></table></figure><h3 id="12-代码：段落代码"><a href="#12-代码：段落代码" class="headerlink" title="12 代码：段落代码"></a>12 代码：段落代码</h3><p>每行文字前加4个空格或者1个Tab</p><pre><code>    val s = &quot;hello Markdown&quot;    println( s )    val s = &quot;hello Markdown&quot;    println( s )val s = &quot;hello Markdown&quot;println( s )val s = &quot;hello Markdown&quot;println( s )</code></pre><h3 id="13-注释"><a href="#13-注释" class="headerlink" title="13 注释"></a>13 注释</h3><p>用html的注释，好像只有这样？</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="14-转义字符"><a href="#14-转义字符" class="headerlink" title="14 转义字符"></a>14 转义字符</h3><p>Markdown中的转义字符为\，转义的有：<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">\\</span> 反斜杠</span><br><span class="line"></span><br><span class="line"><span class="symbol">\`</span> 反引号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\*</span> 星号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\_</span> 下划线</span><br><span class="line"></span><br><span class="line"><span class="symbol">\&#123;</span><span class="symbol">\&#125;</span> 大括号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\[</span><span class="symbol">\]</span> 中括号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\(</span><span class="symbol">\)</span> 小括号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\#</span> 井号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\+</span> 加号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\-</span> 减号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\.</span> 英文句号</span><br><span class="line"></span><br><span class="line"><span class="symbol">\!</span> 感叹号</span><br></pre></td></tr></table></figure></p><p>\ 反斜杠</p><p>` 反引号</p><p>* 星号</p><p>_ 下划线</p><p>{} 大括号</p><p>[] 中括号</p><p>() 小括号</p><p># 井号</p><p>+ 加号</p><p>- 减号</p><p>. 英文句号</p><p>! 感叹号</p><h3 id="15-表格"><a href="#15-表格" class="headerlink" title="15 表格"></a>15 表格</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">| Tables        |</span>      Are      <span class="params">|  Cool |</span></span><br><span class="line"><span class="params">| ------------- |</span> <span class="symbol">:-----------</span>: <span class="params">| ----: |</span></span><br><span class="line"><span class="params">| col 3 is      |</span> right-aligned <span class="params">| $1600 |</span></span><br><span class="line"><span class="params">| col 2 is      |</span>   centered    <span class="params">|   $12 |</span></span><br><span class="line"><span class="params">| zebra stripes |</span>   are neat    <span class="params">|    $1 |</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><p>或者<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> 项目     </span>|<span class="string"> 价格  </span>|</span><br><span class="line">|<span class="string"> -------- </span>|<span class="string"> ----- </span>|</span><br><span class="line">|<span class="string"> Computer </span>|<span class="string"> $1600 </span>|</span><br><span class="line">|<span class="string"> Phone    </span>|<span class="string"> $12   </span>|</span><br><span class="line">|<span class="string"> Pipe     </span>|<span class="string"> $1    </span>|</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><h3 id="16-其他"><a href="#16-其他" class="headerlink" title="16 其他"></a>16 其他</h3><p>段落缩进（空格）<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">半方大的空白<span class="variable">&amp;ensp</span>;或&amp;<span class="meta">#8194;看，飞碟</span></span><br><span class="line">全方大的空白<span class="variable">&amp;emsp</span>;或&amp;<span class="meta">#8195;看，飞碟</span></span><br><span class="line">不断行的空白格<span class="variable">&amp;nbsp</span>;或&amp;<span class="meta">#160;看，飞碟</span></span><br><span class="line"><span class="variable">&amp;emsp</span>;<span class="variable">&amp;emsp</span>;段落从此开始。</span><br></pre></td></tr></table></figure></p><p>半方大的空白&ensp;或&#8194;看，飞碟<br>全方大的空白&emsp;或&#8195;看，飞碟<br>不断行的空白格&nbsp;或&#160;看，飞碟<br>&emsp;&emsp;段落从此开始。</p><h3 id="17-字体、字号、颜色"><a href="#17-字体、字号、颜色" class="headerlink" title="17 字体、字号、颜色"></a>17 字体、字号、颜色</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;font <span class="attribute">face</span>=<span class="string">"黑体"</span>&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">face</span>=<span class="string">"微软雅黑"</span>&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">face</span>=<span class="string">"STCAIYUN"</span>&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">color</span>=#0099ff <span class="attribute">size</span>=12 <span class="attribute">face</span>=<span class="string">"黑体"</span>&gt;黑体&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">color</span>=#00ffff <span class="attribute">size</span>=3&gt;null&lt;/font&gt;</span><br><span class="line">&lt;font <span class="attribute">color</span>=gray <span class="attribute">size</span>=5&gt;gray&lt;/font&gt;</span><br></pre></td></tr></table></figure><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#0099ff" size="12" face="黑体">黑体</font><br><font color="#00ffff" size="3">null</font><br><font color="gray" size="5">gray</font><h3 id="18-标签"><a href="#18-标签" class="headerlink" title="18 标签"></a>18 标签</h3><p>行内标签`<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快捷键 `Ctrl + D` 来收藏本页</span><br></pre></td></tr></table></figure></p><p>快捷键 <code>Ctrl + D</code> 来收藏本页</p><p>原文：<a href="https://blog.csdn.net/qcx321/article/details/53780672" target="_blank" rel="noopener">https://blog.csdn.net/qcx321/article/details/53780672</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qcx321/article/details/53780672&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qcx321/article/detai
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux_strace</title>
    <link href="http://www.tangyilong.com/2019/05/15/Linux-strace/"/>
    <id>http://www.tangyilong.com/2019/05/15/Linux-strace/</id>
    <published>2019-05-15T06:30:04.000Z</published>
    <updated>2019-05-15T07:19:18.735Z</updated>
    
    <content type="html"><![CDATA[<p> strace是个功能强大的Linux调试分析诊断工具，可用于跟踪程序执行时进程系统调用(system call)和所接收的信号，尤其是针对源码不可读或源码无法再编译的程序。</p><p>   在Linux系统中，用户程序运行在一个沙箱(sandbox)里，用户进程不能直接访问计算机硬件设备。当进程需要访问硬件设备(如读取磁盘文件或接收网络数据等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可跟踪进程产生的系统调用，包括参数、返回值和执行所消耗的时间。若strace没有任何输出，并不代表此时进程发生阻塞；也可能程序进程正在自己的沙箱里执行某些不需要与系统其它部分发生通信的事情。strace从内核接收信息，且无需以任何特殊方式来构建内核。</p><p> strace命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">strace [-dffhiqrtttTvVxx] [-a column] [-e expr] [-o file] [-p pid] [-s strsize] [-u username] [-E var=val] [<span class="built_in">command</span> [arg ...]] 或</span><br><span class="line"></span><br><span class="line">strace -c [-e expr] [-O overhead] [-S sortby] [-E var=val] [<span class="built_in">command</span> [arg ...]]</span><br></pre></td></tr></table></figure><p>   通过不同的选项开关，strace提供非常丰富的跟踪功能。最简单的应用是，跟踪可执行程序运行时的整个生命周期，将所调用的系统调用的名称、参数和返回值输出到标准错误输出stderr(即屏幕)或-o选项所指定的文件。<font color="#0099FF">注意，命令(command)必须位于选项列表之后。</font></p><p>   详细的strace命令选项列举如下：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-c</td><td>统计和报告每个系统调用所执行的时间、调用次数和出错次数等</td></tr><tr><td>-d</td><td>输出strace关于标准错误的调试信息</td></tr><tr><td>-f</td><td>跟踪当前进程及其通过fork系统调用所创建的子进程</td></tr><tr><td>-ff</td><td>常与-o选项联合使用，不同进程(子进程)的跟踪结果分别输出到相应的filename. pid文件中，pid是各个进程号</td></tr><tr><td>-F</td><td>尝试跟踪vfork系统调用。否则即使打开-f选项，vfork也不会被跟踪</td></tr><tr><td>-h</td><td>显示帮助信息</td></tr><tr><td>-i</td><td>显示发生系统调用时的指令指针(IP)寄存器值</td></tr><tr><td>-q</td><td>抑制(禁止输出)关于结合(attaching)、脱离(detaching)的消息。当输出重定向到一个文件时，自动抑制此类消息</td></tr><tr><td>-r</td><td>显示每个系统调用发生时的相对时间戳，即连续的系统调用起点之间的时间差</td></tr><tr><td>-t-tt-ttt</td><td>-t在每行输出前添加绝对时间戳(当前时钟)信息，精确到秒级-tt在每行输出前添加绝对时间戳信息，精确到微秒级-ttt在每行输出前添加相对时间信息，格式为”自纪元时间起经历的秒数.微秒数”</td></tr><tr><td>-T</td><td>显示每个系统调用所耗费的时间，其时间开销在输出行最右侧的尖括号内</td></tr><tr><td>-V</td><td>显示strace的版本信息</td></tr><tr><td>-v</td><td>冗余显示模式：显示系统调用中argv[]、envp[]、stat、termio(s)等数组/结构体参数所有的元素/成员内容。这些数组/结构体因使用频繁，默认仅显示其元素/成员的合理子集</td></tr><tr><td>-x</td><td>以16进制形式显示非标准(non-ascii)字符串，如”/x08”。默认为8进制，如”/10”</td></tr><tr><td>-xx</td><td>以16进制形式显示所有字符串</td></tr><tr><td>-a column</td><td>设置显示系统调用返回值的列位置，默认为40(从0开始)，即”=”出现在第40列</td></tr><tr><td>-e expr</td><td>指定一个表达式，用于限定跟踪哪些事件及如何跟踪。其格式为[qualifier=][!]all或[qualifier=][!]value1[,value2]…。qualifier取值为trace(默认)、abbrev、verbose、raw、signal、read或write。value是用于限定的符号(包括all和none)或数字。感叹号为否定符号，如-eopen等价于-e trace=open，表示只跟踪open系统调用；而-e trace=!open表示跟踪除open外的其他系统调用。注意某些shell用!表示执行历史记录里的命令，此时可能借助引号、转义符号(/)。-e trace=set：跟踪指定的系统调用列表，如-e trace=open,close,read,write表示只跟踪这四种系统调用。默认为set=all。-e trace=file：跟踪以指定文件名做参数的所有系统调用。-e trace=process：跟踪涉及进程管理的所有系统调用，可用于观察进程的fork、wait和exec阶段。-e trace=network：跟踪网络相关的所有系统调用。-e strace=signal：跟踪所有与系统信号相关的系统调用。-e trace=ipc：跟踪所有与进程间通信有关的系统调用。-e abbrev=set：指定哪些系统调用中的大型数组或结构体内容缩减显示，如strace -e abbrev=execve ./test仅显示execve调用中argv[]和envp[]的部分内容。默认为abbrev=all， abbrev=none等价于-v选项。-e verbose=set：指定哪些系统调用中的大型数组或结构体内容完整显示，集合外的调用其数组或结构体显示为地址。默认为verbose=all。-e raw=set：指定哪些系统调用中的参数以原始未解码的形式(即16进制)显示。当用户不信任strace解码或需要了解参数实际数值时有用。-e signal=set：跟踪指定的信号列表，默认为signal=all。如signal=!SIGIO(或signal=!io)表示不跟踪SIGIO信号。-e read=set：以16进制和ASCII码对照形式显示从指定文件描述符中读出的所有数据，如-e read=3,5可观察文件描述符3和5上的输入动作。该选项独立于系统调用read的常规跟踪(由-e trace=read选项控制)。-e write=set：以16进制和ASCII码对照形式显示写入指定文件描述符的所有数据。</td></tr><tr><td>-o file</td><td>strace输出信息默认显示到标准错误输出，该选项将输出信息写入文件file中。以下两条命令等效：strace -c -o test.txt ./teststrace -c ./test 2&gt;test.txt</td></tr><tr><td>-O overhead</td><td>Set the overhead for tracing system calls to overhead microseconds. This is useful for overriding the default heuristic for guessing how much time is spent in mere measuring when timing system calls using the -c option. The acuracy of the heuristic can be gauged by timing a given program run without tracing (使用time命令) and comparing the accumulated system call time to the total produced using -c.</td></tr><tr><td>-p pid</td><td>指定待跟踪的进程号(pid)，可用Ctrl-C终止跟踪而被跟踪进程继续运行。可指定多达32个(-p pid)选项以同时跟踪多个进程。该选项常用于调试后台进程</td></tr><tr><td>-s strsize</td><td>限制每行输出中字符串(如read参数)的最大显示长度，默认32字节。但文件名总是完整显示</td></tr><tr><td>-S sortby</td><td>按指定规则对-c选项的输出直方图进行排序。sortby取值可为time、calls、name和nothing(默认time)</td></tr><tr><td>-u username</td><td>用指定用户的UID和/或GID身份运行待跟踪程序</td></tr><tr><td>-E var=val</td><td>将var=val放入命令的环境变量列表</td></tr><tr><td>-E var</td><td>从命令的环境变量列表中移除var</td></tr></tbody></table><p>   例如，命令strace -o out.txt -T -tt -e trace=all -p 2899表示跟踪2899进程的所有系统调用，并统计系统调用的时间开销，以及调用起始时间(以可视化的时分秒格式显示)，最后将记录结果存入out.txt文件。</p><hr><p><a href="https://www.cnblogs.com/clover-toeic/p/3738156.html" target="_blank" rel="noopener">参(抄)考(袭)资料</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; strace是个功能强大的Linux调试分析诊断工具，可用于跟踪程序执行时进程系统调用(system call)和所接收的信号，尤其是针对源码不可读或源码无法再编译的程序。&lt;/p&gt;
&lt;p&gt;   在Linux系统中，用户程序运行在一个沙箱(sandbox)里，用户进程不能直
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lsof命令</title>
    <link href="http://www.tangyilong.com/2019/05/14/lsof%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.tangyilong.com/2019/05/14/lsof命令/</id>
    <published>2019-05-14T13:25:22.000Z</published>
    <updated>2019-05-15T03:11:50.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-lsof命令详解"><a href="#Linux-lsof命令详解" class="headerlink" title="Linux lsof命令详解"></a>Linux lsof命令详解</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如TC和UDP等，系统在后台都为该应用程序分配了一个<strong>文件描述符</strong>，无论这个文件的本质如何，<strong>该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口</strong>。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的</p><p>在终端下输入lsof即可显示系统打开的文件，因为 lsof 需要访问核心内存和各种文件，所以必须以 root 用户的身份运行它才能够充分地发挥其功能。</p><h2 id="lsof命令输出说明"><a href="#lsof命令输出说明" class="headerlink" title="lsof命令输出说明"></a>lsof命令输出说明</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof [参数][文件]</span><br></pre></td></tr></table></figure><p><strong>lsof输出各列信息的意义如下：</strong></p><p>COMMAND：进程的名称</p><p>PID：进程标识符</p><p>PPID：父进程标识符（需要指定-R参数）</p><p>USER：进程所有者</p><p>FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等</p><p>DEVICE：指定磁盘的名称</p><p>SIZE：文件的大小</p><p>NODE：索引节点（文件在磁盘上的标识）</p><p>NAME：打开文件的确切名称</p><p>FD 列中的文件描述符cwd 值表示应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改,txt 类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序。</p><p>其次数值表示应用程序的文件描述符，这是打开该文件时返回的一个整数。如上的最后一行文件/dev/initctl，其文件描述符为 10。u 表示该文件被打开并处于读取/写入模式，而不是只读(r)或只写 (w) 模式。同时还有大写 的W 表示该应用程序具有对整个文件的写锁。该文件描述符用于确保每次只能打开一个应用程序实例。初始打开每个应用程序时，都具有三个文件描述符，从 0 到 2，分别表示标准输入、输出和错误流。所以大多数应用程序所打开的文件的 FD 都是从 3 开始。</p><p>与 FD 列相比，Type 列则比较直观。文件和目录分别称为 REG 和 DIR。而CHR 和 BLK，分别表示字符和块设备；或者 UNIX、FIFO 和 IPv4，分别表示 UNIX 域套接字、先进先出 (FIFO) 队列和网际协议 (IP) 套接字。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lsof abc.txt 显示开启文件abc.txt的进程</span><br><span class="line">      lsof -c abc 显示abc进程现在打开的文件</span><br><span class="line">      lsof -c -p 1234 列出进程号为1234的进程所打开的文件</span><br><span class="line">      lsof -g gid 显示归属gid的进程情况</span><br><span class="line">      lsof +d /usr/local/ 显示目录下被进程开启的文件</span><br><span class="line">      lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长</span><br><span class="line">      lsof -d 4 显示使用fd为4的进程</span><br><span class="line">      lsof -i 用以显示符合条件的进程情况</span><br><span class="line">      lsof -i[46] [protocol][@hostname|hostaddr][:service|port]</span><br><span class="line">                 --&gt; IPv4 <span class="keyword">or</span> IPv6</span><br><span class="line">                protocol --&gt; TCP <span class="keyword">or</span> UDP</span><br><span class="line">                hostname --&gt; Internet host name</span><br><span class="line">                hostaddr --&gt; IPv4地址</span><br><span class="line">               <span class="built_in"> service </span>--&gt; /etc/service中的<span class="built_in"> service </span>name (可以不止一个)</span><br></pre></td></tr></table></figure><h2 id="怎样使用lsof"><a href="#怎样使用lsof" class="headerlink" title="怎样使用lsof"></a><strong>怎样使用lsof</strong></h2><p>这里主要用案例的形式来介绍lsof 命令的<a href="javascript:;" target="_blank" rel="noopener"><strong>使用</strong></a></p><p><strong>1.列出所有打开的文件:</strong></p><p>lsof</p><p>备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位</p><p><strong>2. 查看谁正在使用某个文件</strong></p><p>lsof   /filepath/file</p><p><strong>3.递归查看某个目录的文件信息</strong></p><p>lsof +D /filepath/filepath2/</p><p>备注: 使用了+D，对应目录下的所有子目录和文件都会被列出</p><p><strong>4. 比使用+D选项，遍历查看某个目录的所有文件信息 的方法</strong></p><p>lsof | grep ‘/filepath/filepath2/’</p><p><strong>5. 列出某个用户打开的文件信息</strong></p><p>lsof  -u username</p><p>备注: -u 选项，u其实是user的缩写</p><p><strong>6. 列出某个程序所打开的文件信息</strong></p><p><strong>lsof -c mysql</strong></p><p>备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成<strong>lsof | grep mysql,</strong>但是第一种方法明显比第二种方法要少打几个字符了</p><p><strong>7. 列出多个程序多打开的文件信息</strong></p><p>lsof -c mysql -c apache</p><p><strong>8. 列出某个用户以及某个程序所打开的文件信息</strong></p><p>lsof -u <a href="javascript:;" target="_blank" rel="noopener"><strong>test</strong></a> -c mysql</p><p><strong>9. 列出除了某个用户外的被打开的文件信息</strong></p><p>lsof   -u ^root</p><p>备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示</p><p><strong>10. 通过某个进程号显示该进行打开的文件</strong></p><p>lsof -p 1</p><p><strong>11. 列出多个进程号对应的文件信息</strong></p><p>lsof -p 123,456,789</p><p><strong>12. 列出除了某个进程号，其他进程号所打开的文件信息</strong></p><p>lsof -p ^1</p><p><strong>13 . 列出所有的网络连接</strong></p><p><strong>lsof -i</strong></p><p><strong>14. 列出所有tcp 网络连接信息</strong></p><p>lsof  -i tcp</p><p><strong>15. 列出所有udp网络连接信息</strong></p><p>lsof  -i udp</p><p><strong>16. 列出谁在使用某个端口</strong></p><p>lsof -i :3306</p><p><strong>17. 列出谁在使用某个特定的udp端口</strong></p><p>lsof -i udp:55</p><p><strong>特定的tcp端口</strong></p><p>lsof -i tcp:80</p><p><strong>18. 列出某个用户的所有活跃的网络端口</strong></p><p>lsof  -a -u test -i</p><p><strong>19. 列出所有网络文件系统</strong></p><p>lsof -N</p><p><strong>20.域名socket文件</strong></p><p>lsof -u</p><p><strong>21.某个用户组所打开的文件信息</strong></p><p>lsof -g 5555</p><p><strong>22. 根据文件描述列出对应的文件信息</strong></p><p>lsof -d description(like 2)</p><p><strong>23. 根据文件描述范围列出文件信息</strong></p><p>lsof -d 2-3</p><hr><p><a href="https://www.cnblogs.com/sparkbj/p/7161669.html" target="_blank" rel="noopener">转</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-lsof命令详解&quot;&gt;&lt;a href=&quot;#Linux-lsof命令详解&quot; class=&quot;headerlink&quot; title=&quot;Linux lsof命令详解&quot;&gt;&lt;/a&gt;Linux lsof命令详解&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows7上开启ftp服务器功能</title>
    <link href="http://www.tangyilong.com/2019/04/13/Windows7%E4%B8%8A%E5%BC%80%E5%90%AFftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.tangyilong.com/2019/04/13/Windows7上开启ftp服务器功能/</id>
    <published>2019-04-13T06:43:10.000Z</published>
    <updated>2019-04-13T06:44:07.178Z</updated>
    
    <content type="html"><![CDATA[<p>Windows7上开启ftp服务器功能</p><p><a href="https://www.cnblogs.com/liangxuru/p/6148212.html" target="_blank" rel="noopener">https://www.cnblogs.com/liangxuru/p/6148212.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Windows7上开启ftp服务器功能&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liangxuru/p/6148212.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解strncpy这个函数</title>
    <link href="http://www.tangyilong.com/2019/04/13/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3strncpy%E8%BF%99%E4%B8%AA%E5%87%BD%E6%95%B0/"/>
    <id>http://www.tangyilong.com/2019/04/13/深入理解strncpy这个函数/</id>
    <published>2019-04-13T06:42:11.000Z</published>
    <updated>2019-04-13T06:42:39.423Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weibo1230123/article/details/80382614" target="_blank" rel="noopener">https://blog.csdn.net/weibo1230123/article/details/80382614</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weibo1230123/article/details/80382614&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/weibo1230123/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ioctl()分析——从用户空间到设备驱动</title>
    <link href="http://www.tangyilong.com/2019/04/13/ioctl-%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E4%BB%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%88%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <id>http://www.tangyilong.com/2019/04/13/ioctl-分析——从用户空间到设备驱动/</id>
    <published>2019-04-13T06:40:52.000Z</published>
    <updated>2019-04-13T06:41:28.687Z</updated>
    
    <content type="html"><![CDATA[<p>ioctl()分析——从用户空间到设备驱动</p><p><a href="https://blog.csdn.net/zifehng/article/details/59576539" target="_blank" rel="noopener">https://blog.csdn.net/zifehng/article/details/59576539</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ioctl()分析——从用户空间到设备驱动&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zifehng/article/details/59576539&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字母对应的ASCII码和CTRL加字母的</title>
    <link href="http://www.tangyilong.com/2019/04/13/%E5%AD%97%E6%AF%8D%E5%AF%B9%E5%BA%94%E7%9A%84ASCII%E7%A0%81%E5%92%8CCTRL%E5%8A%A0%E5%AD%97%E6%AF%8D%E7%9A%84/"/>
    <id>http://www.tangyilong.com/2019/04/13/字母对应的ASCII码和CTRL加字母的/</id>
    <published>2019-04-13T06:22:22.000Z</published>
    <updated>2019-04-13T06:22:45.864Z</updated>
    
    <content type="html"><![CDATA[<p>对于字母的ASCII码来说。网上已经罗列出来了，这是很容易就获取的，然后对于ctrl+字母的以及shift+字母的却有点小难了。</p><p>最近在写脚本的时候，需要用到一些组合键，但是苦于不知道这些组合键对应的键盘码，就很尴尬</p><h2 id="CTRL-字母"><a href="#CTRL-字母" class="headerlink" title="CTRL+字母"></a>CTRL+字母</h2><p>  ASCII码1，2，3…分别依次对应键盘按键的Ctrl+A键，Ctrl+B键，Ctrl+C键，…Ctrl+Z键的ASCII为26.参考大写字母后的编码，按键Ctrl+[键产生ASCII码27，Ctrl+\键产生ASCII码28，Ctrl+]键产生ASCII码29，Ctrl+^键产生ASCII码30。常用的控制字符有退格（8），制表符（9），换行（10）.流量控制字符Xoff（17）和Xon（19），对应的按键分别是Ctrl+S，Ctrl+Q。 </p><p>  按照控制字符ASCII码于键盘按键的对应关系，在一个字符终端输入数据时，按下Ctrl+M与按下回车键的效果相同，应为回车的ASCII是13，M在字母表中排在第13位。同样按下Ctrl+J实际上是一个换行符，没有响应键盘按键对应。按下Ctrl+I与按下Tab键的效果相同，Ctrl+[与ESC相同。可以用Ctrl+H代替BackSpace键，在没有BackSpace的终端上，就是直接按Ctrl+H键。</p><p>ctrl+字母的ASCII码=字母的ASCII码&amp;0x1f</p><p>最后分享一个小软件可以查看对应的按键码，</p><p><a href="https://download.csdn.net/download/softimite_zifeng/9688867" target="_blank" rel="noopener">KeyCode</a></p><h2 id="键盘各键对应的编码值（key-code）"><a href="#键盘各键对应的编码值（key-code）" class="headerlink" title="键盘各键对应的编码值（key code）"></a>键盘各键对应的编码值（key code）</h2><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody><tr><td>backspace</td><td>8</td></tr><tr><td>tab</td><td>9</td></tr><tr><td>enter</td><td>13</td></tr><tr><td>shift</td><td>16</td></tr><tr><td>ctrl</td><td>17</td></tr><tr><td>alt</td><td>18</td></tr><tr><td>pause/break</td><td>19</td></tr><tr><td>caps lock</td><td>20</td></tr><tr><td>escape</td><td>27</td></tr><tr><td>page up</td><td>33</td></tr><tr><td>page down</td><td>34</td></tr><tr><td>end</td><td>35</td></tr><tr><td>home</td><td>36</td></tr><tr><td>left arrow</td><td>37</td></tr><tr><td>up arrow</td><td>38</td></tr><tr><td>right arrow</td><td>39</td></tr><tr><td>down arrow</td><td>40</td></tr><tr><td>insert</td><td>45</td></tr><tr><td>delete</td><td>46</td></tr><tr><td>0</td><td>48</td></tr><tr><td>1</td><td>49</td></tr><tr><td>2</td><td>50</td></tr><tr><td>3</td><td>51</td></tr><tr><td>4</td><td>52</td></tr><tr><td>5</td><td>53</td></tr><tr><td>6</td><td>54</td></tr><tr><td>7</td><td>55</td></tr><tr><td>8</td><td>56</td></tr><tr><td>9</td><td>57</td></tr><tr><td>a</td><td>65</td></tr><tr><td>b</td><td>66</td></tr><tr><td>c</td><td>67</td></tr><tr><td>d</td><td>68</td></tr></tbody></table><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody><tr><td>e</td><td>69</td></tr><tr><td>f</td><td>70</td></tr><tr><td>g</td><td>71</td></tr><tr><td>h</td><td>72</td></tr><tr><td>i</td><td>73</td></tr><tr><td>j</td><td>74</td></tr><tr><td>k</td><td>75</td></tr><tr><td>l</td><td>76</td></tr><tr><td>m</td><td>77</td></tr><tr><td>n</td><td>78</td></tr><tr><td>o</td><td>79</td></tr><tr><td>p</td><td>80</td></tr><tr><td>q</td><td>81</td></tr><tr><td>r</td><td>82</td></tr><tr><td>s</td><td>83</td></tr><tr><td>t</td><td>84</td></tr><tr><td>u</td><td>85</td></tr><tr><td>v</td><td>86</td></tr><tr><td>w</td><td>87</td></tr><tr><td>x</td><td>88</td></tr><tr><td>y</td><td>89</td></tr><tr><td>z</td><td>90</td></tr><tr><td>left window key</td><td>91</td></tr><tr><td>right window key</td><td>92</td></tr><tr><td>select key</td><td>93</td></tr><tr><td>numpad 0</td><td>96</td></tr><tr><td>numpad 1</td><td>97</td></tr><tr><td>numpad 2</td><td>98</td></tr><tr><td>numpad 3</td><td>99</td></tr><tr><td>numpad 4</td><td>100</td></tr><tr><td>numpad 5</td><td>101</td></tr><tr><td>numpad 6</td><td>102</td></tr><tr><td>numpad 7</td><td>103</td></tr></tbody></table><table><thead><tr><th>Key</th><th>Code</th></tr></thead><tbody><tr><td>numpad 8</td><td>104</td></tr><tr><td>numpad 9</td><td>105</td></tr><tr><td>multiply</td><td>106</td></tr><tr><td>add</td><td>107</td></tr><tr><td>subtract</td><td>109</td></tr><tr><td>decimal point</td><td>110</td></tr><tr><td>divide</td><td>111</td></tr><tr><td>f1</td><td>112</td></tr><tr><td>f2</td><td>113</td></tr><tr><td>f3</td><td>114</td></tr><tr><td>f4</td><td>115</td></tr><tr><td>f5</td><td>116</td></tr><tr><td>f6</td><td>117</td></tr><tr><td>f7</td><td>118</td></tr><tr><td>f8</td><td>119</td></tr><tr><td>f9</td><td>120</td></tr><tr><td>f10</td><td>121</td></tr><tr><td>f11</td><td>122</td></tr><tr><td>f12</td><td>123</td></tr><tr><td>num lock</td><td>144</td></tr><tr><td>scroll lock</td><td>145</td></tr><tr><td>semi-colon</td><td>186</td></tr><tr><td>equal sign</td><td>187</td></tr><tr><td>comma</td><td>188</td></tr><tr><td>dash</td><td>189</td></tr><tr><td>period</td><td>190</td></tr><tr><td>forward slash</td><td>191</td></tr><tr><td>grave accent</td><td>192</td></tr><tr><td>open bracket</td><td>219</td></tr><tr><td>back slash</td><td>220</td></tr><tr><td>close braket</td><td>221</td></tr><tr><td>single quote</td><td>222</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于字母的ASCII码来说。网上已经罗列出来了，这是很容易就获取的，然后对于ctrl+字母的以及shift+字母的却有点小难了。&lt;/p&gt;
&lt;p&gt;最近在写脚本的时候，需要用到一些组合键，但是苦于不知道这些组合键对应的键盘码，就很尴尬&lt;/p&gt;
&lt;h2 id=&quot;CTRL-字母&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>select一直返回0的问题解决和总结</title>
    <link href="http://www.tangyilong.com/2019/04/13/select%E4%B8%80%E7%9B%B4%E8%BF%94%E5%9B%9E0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://www.tangyilong.com/2019/04/13/select一直返回0的问题解决和总结/</id>
    <published>2019-04-13T06:21:29.000Z</published>
    <updated>2019-04-13T06:23:31.902Z</updated>
    
    <content type="html"><![CDATA[<p>select是Linux/Unix环境下的高级网络I/O编程接口，它使我们能够进行基于I/O多路转接。I/0多路转接（multiplexing）的核心思想是：先构造一张有关描述符的列表，然后调用一个函数，直到这些描述符中的一个已经准备好进行I/O时，该函数才返回。在返回时，它告诉进程哪些描述符已准备好可以进行I/O操作。</p><p>在Linux中，我们可以使用select函数实现I/O端口的复用（多路转接），传递给select函数的参数会告诉内核：</p><ul><li><p>我们所关心的描述符，可能为文件描述符或网络套接字描述符。</p></li><li><p>对每个描述符，我们所关心的状态。(我们是要想从一个文件描述符中读或者写，还是关注一个描述符中是否出现异常)</p></li><li><p>我们愿意等待多长时间。(可以无限等待，等待固定的一段时间，或者完全不等待)</p></li></ul><p>从 select函数返回后，内核告诉我们一下信息：</p><ul><li><p>对我们的要求已经做好准备的描述符的个数</p></li><li><p>对于三种状态（读，写或异常）中的每一个，哪些描述符已经做好准备.</p><p>有了这些返回信息，我们可以调用合适的I/O函数(通常是 read 或 write)，并且这些函数不会再阻塞.</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout)</span></span>;</span><br><span class="line">返回值：做好准备的文件描述符的个数，超时为<span class="number">0</span>，错误为 <span class="number">-1.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span>      </span><br><span class="line">    <span class="keyword">long</span> tv_sec;   <span class="comment">/*秒 */</span>  </span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">/*微秒 */</span>     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   首先我们先看一下最后一个参数。它指明我们要等待的时间，有如下三种情况：</p><ul><li><p>timeout == NULL  等待无限长的时间。等待可以被一个信号中断。当有一个描述符做好准备或者是捕获到一个信号时函数会返回。如果捕获到一个信号， select函数将返回 -1,并将变量 erro设为 EINTR。</p></li><li><p>timeout-&gt;tv_sec == 0 &amp;&amp;timeout-&gt;tv_usec == 0不等待，直接返回。加入描述符集的描述符都会被测试，并且返回满足要求的描述符的个数。这种方法通过轮询，无阻塞地获得了多个文件描述符状态。</p></li><li><p>timeout-&gt;tv_sec !=0 ||timeout-&gt;tv_usec!= 0 等待指定的时间。当有描述符符合条件或者超过超时时间的话，函数返回。在超时时间即将用完但又没有描述符合条件的话，返回 0。对于第一种情况，等待也会被信号所中断。</p><p>接着，我们看看中间的三个参数 readset, writset, exceptset,指向描述符集。这些参数指明了我们关心哪些描述符，和需要满足什么条件(可写，可读，异常)。一个文件描述集保存在 fd_set 类型中。fd_set类型变量每一位代表了一个描述符。我们也可以认为它只是一个由很多二进制位构成的数组。</p><p>理解select模型的关键在于理解fd_set,为说明方便，取fd_set长度为1字节，fd_set中的每一bit可以对应一个文件描述符fd。则1字节长的fd_set最大可以对应8个fd。<br>（1）执行fd_set set;<br>(2) FD_ZERO(&amp;set);则set用位表示是0000,0000。<br>（3）若fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000(第5位置为1)<br>（4）若再加入fd＝2，fd=1,则set变为0001,0011<br>（5）执行select(6,&amp;set,0,0,0)阻塞等待<br>（6）若fd=1,fd=2上都发生可读事件，则select返回，此时set变为0000,0011。注意：没有事件发生的fd=5被清空。</p><p>由于我是服务器端主程序，只关心是否收到对端发来的消息或通知事件，因此我只需要监听某个端口，采用select检查相应的套接字描述符是否有数据可读。调用FD_ZERO(&amp;readfds)将一个指定的fd_set变量（read_fds）所有位设置为0，调用FD_SET(m_server_sock, &amp;readfds)将read_fds变量的第m_server_sock个位置1。</p></li><li><p>如果select返回-1，说明有错误；如果为0， 说明超时了；否者说明我们关心的描述符准备好了。对于本文，我关心的是只有一个读文件描述符，当有数据可读时，内核(I/O)根据状态修改文件描述符集，select返回一个大于0的数,该数值表示已经准备好的描述符个数（本文是1，由于我只关心一个描述符）。准备好是什么意思呢？意思是，我关心的读集readfds中的其中一个描述符m_sock_fd描述符，有数据可读了，对其read操作不会阻塞。</p></li></ul><p>select调用是在while 循环loop里，而FD的设置却在while loop之外，即：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fd_set readfds<span class="comment">;</span></span><br><span class="line">FD_ZERO(&amp;readfds)<span class="comment">;</span></span><br><span class="line">FD_SET(m_server_sock, &amp;readfds)<span class="comment">;</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> sockfd = <span class="number">-1</span><span class="comment">;</span></span><br><span class="line">  <span class="built_in">int</span> ret = <span class="keyword">select</span>(m_server_sock +<span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)<span class="comment">;</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是这个逻辑有问题呢？于是想到试试看：把FD_SET操作都放到select之前，即统一放到while Loop循环里。没想到，这么一改问题直接就解决了。</p><p>初步分析认为：</p><p>select返回后, 会把以前加入的但并无事件发生的fd从fd_set清除，因此需要重新调用select 前再次把关心的fd添加到FD_SET。否则就会出现本文的现象。</p><p>问题解决：每次调用select之前，调用FD_ZERO清空可读文件句柄集，并调用FD_SET把TCP套接字添加到该fd_set类型的集合中。<br>代码对比：</p><p><img src="/pic/select001.png" alt="img"></p><hr><p><a href="https://blog.csdn.net/acs713/article/details/17531827" target="_blank" rel="noopener">原文</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;select是Linux/Unix环境下的高级网络I/O编程接口，它使我们能够进行基于I/O多路转接。I/0多路转接（multiplexing）的核心思想是：先构造一张有关描述符的列表，然后调用一个函数，直到这些描述符中的一个已经准备好进行I/O时，该函数才返回。在返回时，
      
    
    </summary>
    
    
  </entry>
  
</feed>
